
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model CountryLanguage
 * 
 */
export type CountryLanguage = $Result.DefaultSelection<Prisma.$CountryLanguagePayload>
/**
 * Model CountryCurrency
 * 
 */
export type CountryCurrency = $Result.DefaultSelection<Prisma.$CountryCurrencyPayload>
/**
 * Model Pathway
 * 
 */
export type Pathway = $Result.DefaultSelection<Prisma.$PathwayPayload>
/**
 * Model PathwayPipeline
 * 
 */
export type PathwayPipeline = $Result.DefaultSelection<Prisma.$PathwayPipelinePayload>
/**
 * Model PathwayRestrictedNationality
 * 
 */
export type PathwayRestrictedNationality = $Result.DefaultSelection<Prisma.$PathwayRestrictedNationalityPayload>
/**
 * Model PathwayDocuments
 * 
 */
export type PathwayDocuments = $Result.DefaultSelection<Prisma.$PathwayDocumentsPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model Documents
 * 
 */
export type Documents = $Result.DefaultSelection<Prisma.$DocumentsPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagHierarchy
 * 
 */
export type TagHierarchy = $Result.DefaultSelection<Prisma.$TagHierarchyPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model BlockField
 * 
 */
export type BlockField = $Result.DefaultSelection<Prisma.$BlockFieldPayload>
/**
 * Model PostBlock
 * 
 */
export type PostBlock = $Result.DefaultSelection<Prisma.$PostBlockPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model UserSocial
 * 
 */
export type UserSocial = $Result.DefaultSelection<Prisma.$UserSocialPayload>
/**
 * Model UserRoles
 * 
 */
export type UserRoles = $Result.DefaultSelection<Prisma.$UserRolesPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Social
 * 
 */
export type Social = $Result.DefaultSelection<Prisma.$SocialPayload>
/**
 * Model PostVersionHistory
 * 
 */
export type PostVersionHistory = $Result.DefaultSelection<Prisma.$PostVersionHistoryPayload>
/**
 * Model PathwayTypes
 * 
 */
export type PathwayTypes = $Result.DefaultSelection<Prisma.$PathwayTypesPayload>
/**
 * Model PathwayCategories
 * 
 */
export type PathwayCategories = $Result.DefaultSelection<Prisma.$PathwayCategoriesPayload>
/**
 * Model ContentResourceType
 * 
 */
export type ContentResourceType = $Result.DefaultSelection<Prisma.$ContentResourceTypePayload>
/**
 * Model ContentResourceArea
 * 
 */
export type ContentResourceArea = $Result.DefaultSelection<Prisma.$ContentResourceAreaPayload>
/**
 * Model ContentResource
 * 
 */
export type ContentResource = $Result.DefaultSelection<Prisma.$ContentResourcePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PathwayType: {
  ASYLUM: 'ASYLUM',
  VISA: 'VISA'
};

export type PathwayType = (typeof PathwayType)[keyof typeof PathwayType]


export const PathwayPipelines: {
  CITIZENSHIP: 'CITIZENSHIP',
  RESIDENCY: 'RESIDENCY',
  REUNIFICATION: 'REUNIFICATION'
};

export type PathwayPipelines = (typeof PathwayPipelines)[keyof typeof PathwayPipelines]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const DocumentType: {
  GENERAL: 'GENERAL',
  FINANCIAL: 'FINANCIAL',
  IDENTIFICATION: 'IDENTIFICATION',
  EVIDENCE: 'EVIDENCE',
  SUPPORTING: 'SUPPORTING',
  SPONSORSHIP: 'SPONSORSHIP',
  INSURANCE: 'INSURANCE',
  PLAN: 'PLAN'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const TagColor: {
  amber: 'amber',
  blue: 'blue',
  cyan: 'cyan',
  emerald: 'emerald',
  fuchsia: 'fuchsia',
  green: 'green',
  indigo: 'indigo',
  lime: 'lime',
  orange: 'orange',
  pink: 'pink',
  purple: 'purple',
  red: 'red',
  rose: 'rose',
  sky: 'sky',
  teal: 'teal',
  violet: 'violet',
  yellow: 'yellow',
  zinc: 'zinc'
};

export type TagColor = (typeof TagColor)[keyof typeof TagColor]


export const PathwayNoteType: {
  GENERAL: 'GENERAL',
  LIMITATION: 'LIMITATION',
  REQUIREMENT: 'REQUIREMENT'
};

export type PathwayNoteType = (typeof PathwayNoteType)[keyof typeof PathwayNoteType]

}

export type PathwayType = $Enums.PathwayType

export const PathwayType: typeof $Enums.PathwayType

export type PathwayPipelines = $Enums.PathwayPipelines

export const PathwayPipelines: typeof $Enums.PathwayPipelines

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type TagColor = $Enums.TagColor

export const TagColor: typeof $Enums.TagColor

export type PathwayNoteType = $Enums.PathwayNoteType

export const PathwayNoteType: typeof $Enums.PathwayNoteType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.settings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countryLanguage`: Exposes CRUD operations for the **CountryLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryLanguages
    * const countryLanguages = await prisma.countryLanguage.findMany()
    * ```
    */
  get countryLanguage(): Prisma.CountryLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countryCurrency`: Exposes CRUD operations for the **CountryCurrency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryCurrencies
    * const countryCurrencies = await prisma.countryCurrency.findMany()
    * ```
    */
  get countryCurrency(): Prisma.CountryCurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathway`: Exposes CRUD operations for the **Pathway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pathways
    * const pathways = await prisma.pathway.findMany()
    * ```
    */
  get pathway(): Prisma.PathwayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathwayPipeline`: Exposes CRUD operations for the **PathwayPipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PathwayPipelines
    * const pathwayPipelines = await prisma.pathwayPipeline.findMany()
    * ```
    */
  get pathwayPipeline(): Prisma.PathwayPipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathwayRestrictedNationality`: Exposes CRUD operations for the **PathwayRestrictedNationality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PathwayRestrictedNationalities
    * const pathwayRestrictedNationalities = await prisma.pathwayRestrictedNationality.findMany()
    * ```
    */
  get pathwayRestrictedNationality(): Prisma.PathwayRestrictedNationalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathwayDocuments`: Exposes CRUD operations for the **PathwayDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PathwayDocuments
    * const pathwayDocuments = await prisma.pathwayDocuments.findMany()
    * ```
    */
  get pathwayDocuments(): Prisma.PathwayDocumentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **Documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.DocumentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagHierarchy`: Exposes CRUD operations for the **TagHierarchy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagHierarchies
    * const tagHierarchies = await prisma.tagHierarchy.findMany()
    * ```
    */
  get tagHierarchy(): Prisma.TagHierarchyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockField`: Exposes CRUD operations for the **BlockField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockFields
    * const blockFields = await prisma.blockField.findMany()
    * ```
    */
  get blockField(): Prisma.BlockFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postBlock`: Exposes CRUD operations for the **PostBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostBlocks
    * const postBlocks = await prisma.postBlock.findMany()
    * ```
    */
  get postBlock(): Prisma.PostBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSocial`: Exposes CRUD operations for the **UserSocial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSocials
    * const userSocials = await prisma.userSocial.findMany()
    * ```
    */
  get userSocial(): Prisma.UserSocialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRoles`: Exposes CRUD operations for the **UserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRoles.findMany()
    * ```
    */
  get userRoles(): Prisma.UserRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.social`: Exposes CRUD operations for the **Social** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Socials
    * const socials = await prisma.social.findMany()
    * ```
    */
  get social(): Prisma.SocialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postVersionHistory`: Exposes CRUD operations for the **PostVersionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostVersionHistories
    * const postVersionHistories = await prisma.postVersionHistory.findMany()
    * ```
    */
  get postVersionHistory(): Prisma.PostVersionHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathwayTypes`: Exposes CRUD operations for the **PathwayTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PathwayTypes
    * const pathwayTypes = await prisma.pathwayTypes.findMany()
    * ```
    */
  get pathwayTypes(): Prisma.PathwayTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathwayCategories`: Exposes CRUD operations for the **PathwayCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PathwayCategories
    * const pathwayCategories = await prisma.pathwayCategories.findMany()
    * ```
    */
  get pathwayCategories(): Prisma.PathwayCategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentResourceType`: Exposes CRUD operations for the **ContentResourceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentResourceTypes
    * const contentResourceTypes = await prisma.contentResourceType.findMany()
    * ```
    */
  get contentResourceType(): Prisma.ContentResourceTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentResourceArea`: Exposes CRUD operations for the **ContentResourceArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentResourceAreas
    * const contentResourceAreas = await prisma.contentResourceArea.findMany()
    * ```
    */
  get contentResourceArea(): Prisma.ContentResourceAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentResource`: Exposes CRUD operations for the **ContentResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentResources
    * const contentResources = await prisma.contentResource.findMany()
    * ```
    */
  get contentResource(): Prisma.ContentResourceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Settings: 'Settings',
    Country: 'Country',
    CountryLanguage: 'CountryLanguage',
    CountryCurrency: 'CountryCurrency',
    Pathway: 'Pathway',
    PathwayPipeline: 'PathwayPipeline',
    PathwayRestrictedNationality: 'PathwayRestrictedNationality',
    PathwayDocuments: 'PathwayDocuments',
    Currency: 'Currency',
    Documents: 'Documents',
    Language: 'Language',
    Post: 'Post',
    PostTag: 'PostTag',
    Tag: 'Tag',
    TagHierarchy: 'TagHierarchy',
    Resource: 'Resource',
    Block: 'Block',
    BlockField: 'BlockField',
    PostBlock: 'PostBlock',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    UserSocial: 'UserSocial',
    UserRoles: 'UserRoles',
    Roles: 'Roles',
    Social: 'Social',
    PostVersionHistory: 'PostVersionHistory',
    PathwayTypes: 'PathwayTypes',
    PathwayCategories: 'PathwayCategories',
    ContentResourceType: 'ContentResourceType',
    ContentResourceArea: 'ContentResourceArea',
    ContentResource: 'ContentResource'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "settings" | "country" | "countryLanguage" | "countryCurrency" | "pathway" | "pathwayPipeline" | "pathwayRestrictedNationality" | "pathwayDocuments" | "currency" | "documents" | "language" | "post" | "postTag" | "tag" | "tagHierarchy" | "resource" | "block" | "blockField" | "postBlock" | "session" | "user" | "verificationToken" | "userSocial" | "userRoles" | "roles" | "social" | "postVersionHistory" | "pathwayTypes" | "pathwayCategories" | "contentResourceType" | "contentResourceArea" | "contentResource"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      CountryLanguage: {
        payload: Prisma.$CountryLanguagePayload<ExtArgs>
        fields: Prisma.CountryLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          findFirst: {
            args: Prisma.CountryLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          findMany: {
            args: Prisma.CountryLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>[]
          }
          create: {
            args: Prisma.CountryLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          createMany: {
            args: Prisma.CountryLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryLanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>[]
          }
          delete: {
            args: Prisma.CountryLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          update: {
            args: Prisma.CountryLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          deleteMany: {
            args: Prisma.CountryLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryLanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>[]
          }
          upsert: {
            args: Prisma.CountryLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryLanguagePayload>
          }
          aggregate: {
            args: Prisma.CountryLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryLanguage>
          }
          groupBy: {
            args: Prisma.CountryLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<CountryLanguageCountAggregateOutputType> | number
          }
        }
      }
      CountryCurrency: {
        payload: Prisma.$CountryCurrencyPayload<ExtArgs>
        fields: Prisma.CountryCurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryCurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryCurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          findFirst: {
            args: Prisma.CountryCurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryCurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          findMany: {
            args: Prisma.CountryCurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>[]
          }
          create: {
            args: Prisma.CountryCurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          createMany: {
            args: Prisma.CountryCurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>[]
          }
          delete: {
            args: Prisma.CountryCurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          update: {
            args: Prisma.CountryCurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CountryCurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryCurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryCurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CountryCurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCurrencyPayload>
          }
          aggregate: {
            args: Prisma.CountryCurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryCurrency>
          }
          groupBy: {
            args: Prisma.CountryCurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryCurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCurrencyCountAggregateOutputType> | number
          }
        }
      }
      Pathway: {
        payload: Prisma.$PathwayPayload<ExtArgs>
        fields: Prisma.PathwayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          findFirst: {
            args: Prisma.PathwayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          findMany: {
            args: Prisma.PathwayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          create: {
            args: Prisma.PathwayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          createMany: {
            args: Prisma.PathwayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          delete: {
            args: Prisma.PathwayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          update: {
            args: Prisma.PathwayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          deleteMany: {
            args: Prisma.PathwayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          upsert: {
            args: Prisma.PathwayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          aggregate: {
            args: Prisma.PathwayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathway>
          }
          groupBy: {
            args: Prisma.PathwayGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayCountAggregateOutputType> | number
          }
        }
      }
      PathwayPipeline: {
        payload: Prisma.$PathwayPipelinePayload<ExtArgs>
        fields: Prisma.PathwayPipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayPipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayPipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          findFirst: {
            args: Prisma.PathwayPipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayPipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          findMany: {
            args: Prisma.PathwayPipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>[]
          }
          create: {
            args: Prisma.PathwayPipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          createMany: {
            args: Prisma.PathwayPipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayPipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>[]
          }
          delete: {
            args: Prisma.PathwayPipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          update: {
            args: Prisma.PathwayPipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          deleteMany: {
            args: Prisma.PathwayPipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayPipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayPipelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>[]
          }
          upsert: {
            args: Prisma.PathwayPipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPipelinePayload>
          }
          aggregate: {
            args: Prisma.PathwayPipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathwayPipeline>
          }
          groupBy: {
            args: Prisma.PathwayPipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayPipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayPipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayPipelineCountAggregateOutputType> | number
          }
        }
      }
      PathwayRestrictedNationality: {
        payload: Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>
        fields: Prisma.PathwayRestrictedNationalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayRestrictedNationalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayRestrictedNationalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          findFirst: {
            args: Prisma.PathwayRestrictedNationalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayRestrictedNationalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          findMany: {
            args: Prisma.PathwayRestrictedNationalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>[]
          }
          create: {
            args: Prisma.PathwayRestrictedNationalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          createMany: {
            args: Prisma.PathwayRestrictedNationalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayRestrictedNationalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>[]
          }
          delete: {
            args: Prisma.PathwayRestrictedNationalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          update: {
            args: Prisma.PathwayRestrictedNationalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          deleteMany: {
            args: Prisma.PathwayRestrictedNationalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayRestrictedNationalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayRestrictedNationalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>[]
          }
          upsert: {
            args: Prisma.PathwayRestrictedNationalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayRestrictedNationalityPayload>
          }
          aggregate: {
            args: Prisma.PathwayRestrictedNationalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathwayRestrictedNationality>
          }
          groupBy: {
            args: Prisma.PathwayRestrictedNationalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayRestrictedNationalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayRestrictedNationalityCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayRestrictedNationalityCountAggregateOutputType> | number
          }
        }
      }
      PathwayDocuments: {
        payload: Prisma.$PathwayDocumentsPayload<ExtArgs>
        fields: Prisma.PathwayDocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayDocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayDocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          findFirst: {
            args: Prisma.PathwayDocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayDocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          findMany: {
            args: Prisma.PathwayDocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>[]
          }
          create: {
            args: Prisma.PathwayDocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          createMany: {
            args: Prisma.PathwayDocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayDocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>[]
          }
          delete: {
            args: Prisma.PathwayDocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          update: {
            args: Prisma.PathwayDocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          deleteMany: {
            args: Prisma.PathwayDocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayDocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayDocumentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>[]
          }
          upsert: {
            args: Prisma.PathwayDocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayDocumentsPayload>
          }
          aggregate: {
            args: Prisma.PathwayDocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathwayDocuments>
          }
          groupBy: {
            args: Prisma.PathwayDocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayDocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayDocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayDocumentsCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      Documents: {
        payload: Prisma.$DocumentsPayload<ExtArgs>
        fields: Prisma.DocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findFirst: {
            args: Prisma.DocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          findMany: {
            args: Prisma.DocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          create: {
            args: Prisma.DocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          createMany: {
            args: Prisma.DocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          delete: {
            args: Prisma.DocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          update: {
            args: Prisma.DocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          deleteMany: {
            args: Prisma.DocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>[]
          }
          upsert: {
            args: Prisma.DocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.DocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagHierarchy: {
        payload: Prisma.$TagHierarchyPayload<ExtArgs>
        fields: Prisma.TagHierarchyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagHierarchyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagHierarchyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          findFirst: {
            args: Prisma.TagHierarchyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagHierarchyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          findMany: {
            args: Prisma.TagHierarchyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>[]
          }
          create: {
            args: Prisma.TagHierarchyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          createMany: {
            args: Prisma.TagHierarchyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagHierarchyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>[]
          }
          delete: {
            args: Prisma.TagHierarchyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          update: {
            args: Prisma.TagHierarchyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          deleteMany: {
            args: Prisma.TagHierarchyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagHierarchyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagHierarchyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>[]
          }
          upsert: {
            args: Prisma.TagHierarchyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagHierarchyPayload>
          }
          aggregate: {
            args: Prisma.TagHierarchyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagHierarchy>
          }
          groupBy: {
            args: Prisma.TagHierarchyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagHierarchyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagHierarchyCountArgs<ExtArgs>
            result: $Utils.Optional<TagHierarchyCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      BlockField: {
        payload: Prisma.$BlockFieldPayload<ExtArgs>
        fields: Prisma.BlockFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          findFirst: {
            args: Prisma.BlockFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          findMany: {
            args: Prisma.BlockFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>[]
          }
          create: {
            args: Prisma.BlockFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          createMany: {
            args: Prisma.BlockFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>[]
          }
          delete: {
            args: Prisma.BlockFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          update: {
            args: Prisma.BlockFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          deleteMany: {
            args: Prisma.BlockFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>[]
          }
          upsert: {
            args: Prisma.BlockFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockFieldPayload>
          }
          aggregate: {
            args: Prisma.BlockFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockField>
          }
          groupBy: {
            args: Prisma.BlockFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockFieldCountArgs<ExtArgs>
            result: $Utils.Optional<BlockFieldCountAggregateOutputType> | number
          }
        }
      }
      PostBlock: {
        payload: Prisma.$PostBlockPayload<ExtArgs>
        fields: Prisma.PostBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          findFirst: {
            args: Prisma.PostBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          findMany: {
            args: Prisma.PostBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>[]
          }
          create: {
            args: Prisma.PostBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          createMany: {
            args: Prisma.PostBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>[]
          }
          delete: {
            args: Prisma.PostBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          update: {
            args: Prisma.PostBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          deleteMany: {
            args: Prisma.PostBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>[]
          }
          upsert: {
            args: Prisma.PostBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostBlockPayload>
          }
          aggregate: {
            args: Prisma.PostBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostBlock>
          }
          groupBy: {
            args: Prisma.PostBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostBlockCountArgs<ExtArgs>
            result: $Utils.Optional<PostBlockCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      UserSocial: {
        payload: Prisma.$UserSocialPayload<ExtArgs>
        fields: Prisma.UserSocialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSocialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSocialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          findFirst: {
            args: Prisma.UserSocialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSocialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          findMany: {
            args: Prisma.UserSocialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>[]
          }
          create: {
            args: Prisma.UserSocialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          createMany: {
            args: Prisma.UserSocialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSocialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>[]
          }
          delete: {
            args: Prisma.UserSocialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          update: {
            args: Prisma.UserSocialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          deleteMany: {
            args: Prisma.UserSocialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSocialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSocialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>[]
          }
          upsert: {
            args: Prisma.UserSocialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSocialPayload>
          }
          aggregate: {
            args: Prisma.UserSocialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSocial>
          }
          groupBy: {
            args: Prisma.UserSocialGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSocialGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSocialCountArgs<ExtArgs>
            result: $Utils.Optional<UserSocialCountAggregateOutputType> | number
          }
        }
      }
      UserRoles: {
        payload: Prisma.$UserRolesPayload<ExtArgs>
        fields: Prisma.UserRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          findFirst: {
            args: Prisma.UserRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          findMany: {
            args: Prisma.UserRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>[]
          }
          create: {
            args: Prisma.UserRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          createMany: {
            args: Prisma.UserRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>[]
          }
          delete: {
            args: Prisma.UserRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          update: {
            args: Prisma.UserRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          deleteMany: {
            args: Prisma.UserRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>[]
          }
          upsert: {
            args: Prisma.UserRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolesPayload>
          }
          aggregate: {
            args: Prisma.UserRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoles>
          }
          groupBy: {
            args: Prisma.UserRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRolesCountArgs<ExtArgs>
            result: $Utils.Optional<UserRolesCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Social: {
        payload: Prisma.$SocialPayload<ExtArgs>
        fields: Prisma.SocialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          findFirst: {
            args: Prisma.SocialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          findMany: {
            args: Prisma.SocialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>[]
          }
          create: {
            args: Prisma.SocialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          createMany: {
            args: Prisma.SocialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>[]
          }
          delete: {
            args: Prisma.SocialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          update: {
            args: Prisma.SocialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          deleteMany: {
            args: Prisma.SocialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>[]
          }
          upsert: {
            args: Prisma.SocialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPayload>
          }
          aggregate: {
            args: Prisma.SocialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocial>
          }
          groupBy: {
            args: Prisma.SocialGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialCountArgs<ExtArgs>
            result: $Utils.Optional<SocialCountAggregateOutputType> | number
          }
        }
      }
      PostVersionHistory: {
        payload: Prisma.$PostVersionHistoryPayload<ExtArgs>
        fields: Prisma.PostVersionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostVersionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostVersionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          findFirst: {
            args: Prisma.PostVersionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostVersionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          findMany: {
            args: Prisma.PostVersionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>[]
          }
          create: {
            args: Prisma.PostVersionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          createMany: {
            args: Prisma.PostVersionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostVersionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>[]
          }
          delete: {
            args: Prisma.PostVersionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          update: {
            args: Prisma.PostVersionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PostVersionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostVersionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostVersionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PostVersionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVersionHistoryPayload>
          }
          aggregate: {
            args: Prisma.PostVersionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostVersionHistory>
          }
          groupBy: {
            args: Prisma.PostVersionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostVersionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostVersionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PostVersionHistoryCountAggregateOutputType> | number
          }
        }
      }
      PathwayTypes: {
        payload: Prisma.$PathwayTypesPayload<ExtArgs>
        fields: Prisma.PathwayTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          findFirst: {
            args: Prisma.PathwayTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          findMany: {
            args: Prisma.PathwayTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>[]
          }
          create: {
            args: Prisma.PathwayTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          createMany: {
            args: Prisma.PathwayTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayTypesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>[]
          }
          delete: {
            args: Prisma.PathwayTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          update: {
            args: Prisma.PathwayTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          deleteMany: {
            args: Prisma.PathwayTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayTypesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>[]
          }
          upsert: {
            args: Prisma.PathwayTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayTypesPayload>
          }
          aggregate: {
            args: Prisma.PathwayTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathwayTypes>
          }
          groupBy: {
            args: Prisma.PathwayTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayTypesCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayTypesCountAggregateOutputType> | number
          }
        }
      }
      PathwayCategories: {
        payload: Prisma.$PathwayCategoriesPayload<ExtArgs>
        fields: Prisma.PathwayCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          findFirst: {
            args: Prisma.PathwayCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          findMany: {
            args: Prisma.PathwayCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>[]
          }
          create: {
            args: Prisma.PathwayCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          createMany: {
            args: Prisma.PathwayCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayCategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>[]
          }
          delete: {
            args: Prisma.PathwayCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          update: {
            args: Prisma.PathwayCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.PathwayCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayCategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>[]
          }
          upsert: {
            args: Prisma.PathwayCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayCategoriesPayload>
          }
          aggregate: {
            args: Prisma.PathwayCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathwayCategories>
          }
          groupBy: {
            args: Prisma.PathwayCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayCategoriesCountAggregateOutputType> | number
          }
        }
      }
      ContentResourceType: {
        payload: Prisma.$ContentResourceTypePayload<ExtArgs>
        fields: Prisma.ContentResourceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentResourceTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentResourceTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          findFirst: {
            args: Prisma.ContentResourceTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentResourceTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          findMany: {
            args: Prisma.ContentResourceTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>[]
          }
          create: {
            args: Prisma.ContentResourceTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          createMany: {
            args: Prisma.ContentResourceTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentResourceTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>[]
          }
          delete: {
            args: Prisma.ContentResourceTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          update: {
            args: Prisma.ContentResourceTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          deleteMany: {
            args: Prisma.ContentResourceTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentResourceTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentResourceTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>[]
          }
          upsert: {
            args: Prisma.ContentResourceTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceTypePayload>
          }
          aggregate: {
            args: Prisma.ContentResourceTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentResourceType>
          }
          groupBy: {
            args: Prisma.ContentResourceTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentResourceTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceTypeCountAggregateOutputType> | number
          }
        }
      }
      ContentResourceArea: {
        payload: Prisma.$ContentResourceAreaPayload<ExtArgs>
        fields: Prisma.ContentResourceAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentResourceAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentResourceAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          findFirst: {
            args: Prisma.ContentResourceAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentResourceAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          findMany: {
            args: Prisma.ContentResourceAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>[]
          }
          create: {
            args: Prisma.ContentResourceAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          createMany: {
            args: Prisma.ContentResourceAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentResourceAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>[]
          }
          delete: {
            args: Prisma.ContentResourceAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          update: {
            args: Prisma.ContentResourceAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          deleteMany: {
            args: Prisma.ContentResourceAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentResourceAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentResourceAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>[]
          }
          upsert: {
            args: Prisma.ContentResourceAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourceAreaPayload>
          }
          aggregate: {
            args: Prisma.ContentResourceAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentResourceArea>
          }
          groupBy: {
            args: Prisma.ContentResourceAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentResourceAreaCountArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceAreaCountAggregateOutputType> | number
          }
        }
      }
      ContentResource: {
        payload: Prisma.$ContentResourcePayload<ExtArgs>
        fields: Prisma.ContentResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          findFirst: {
            args: Prisma.ContentResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          findMany: {
            args: Prisma.ContentResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
          }
          create: {
            args: Prisma.ContentResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          createMany: {
            args: Prisma.ContentResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
          }
          delete: {
            args: Prisma.ContentResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          update: {
            args: Prisma.ContentResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          deleteMany: {
            args: Prisma.ContentResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
          }
          upsert: {
            args: Prisma.ContentResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentResourcePayload>
          }
          aggregate: {
            args: Prisma.ContentResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentResource>
          }
          groupBy: {
            args: Prisma.ContentResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ContentResourceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    settings?: SettingsOmit
    country?: CountryOmit
    countryLanguage?: CountryLanguageOmit
    countryCurrency?: CountryCurrencyOmit
    pathway?: PathwayOmit
    pathwayPipeline?: PathwayPipelineOmit
    pathwayRestrictedNationality?: PathwayRestrictedNationalityOmit
    pathwayDocuments?: PathwayDocumentsOmit
    currency?: CurrencyOmit
    documents?: DocumentsOmit
    language?: LanguageOmit
    post?: PostOmit
    postTag?: PostTagOmit
    tag?: TagOmit
    tagHierarchy?: TagHierarchyOmit
    resource?: ResourceOmit
    block?: BlockOmit
    blockField?: BlockFieldOmit
    postBlock?: PostBlockOmit
    session?: SessionOmit
    user?: UserOmit
    verificationToken?: VerificationTokenOmit
    userSocial?: UserSocialOmit
    userRoles?: UserRolesOmit
    roles?: RolesOmit
    social?: SocialOmit
    postVersionHistory?: PostVersionHistoryOmit
    pathwayTypes?: PathwayTypesOmit
    pathwayCategories?: PathwayCategoriesOmit
    contentResourceType?: ContentResourceTypeOmit
    contentResourceArea?: ContentResourceAreaOmit
    contentResource?: ContentResourceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    countryCurrencies: number
    countryLanguages: number
    restrictedPathways: number
    pathways: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryCurrencies?: boolean | CountryCountOutputTypeCountCountryCurrenciesArgs
    countryLanguages?: boolean | CountryCountOutputTypeCountCountryLanguagesArgs
    restrictedPathways?: boolean | CountryCountOutputTypeCountRestrictedPathwaysArgs
    pathways?: boolean | CountryCountOutputTypeCountPathwaysArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCountryCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCurrencyWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCountryLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryLanguageWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountRestrictedPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayRestrictedNationalityWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }


  /**
   * Count Type PathwayCountOutputType
   */

  export type PathwayCountOutputType = {
    documents: number
    categories: number
    pipelines: number
    restrictedNationalities: number
  }

  export type PathwayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PathwayCountOutputTypeCountDocumentsArgs
    categories?: boolean | PathwayCountOutputTypeCountCategoriesArgs
    pipelines?: boolean | PathwayCountOutputTypeCountPipelinesArgs
    restrictedNationalities?: boolean | PathwayCountOutputTypeCountRestrictedNationalitiesArgs
  }

  // Custom InputTypes
  /**
   * PathwayCountOutputType without action
   */
  export type PathwayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCountOutputType
     */
    select?: PathwayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PathwayCountOutputType without action
   */
  export type PathwayCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayDocumentsWhereInput
  }

  /**
   * PathwayCountOutputType without action
   */
  export type PathwayCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayCategoriesWhereInput
  }

  /**
   * PathwayCountOutputType without action
   */
  export type PathwayCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayPipelineWhereInput
  }

  /**
   * PathwayCountOutputType without action
   */
  export type PathwayCountOutputTypeCountRestrictedNationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayRestrictedNationalityWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    countryCurrencies: number
    pathways: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryCurrencies?: boolean | CurrencyCountOutputTypeCountCountryCurrenciesArgs
    pathways?: boolean | CurrencyCountOutputTypeCountPathwaysArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountCountryCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCurrencyWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }


  /**
   * Count Type DocumentsCountOutputType
   */

  export type DocumentsCountOutputType = {
    pathwayDocuments: number
  }

  export type DocumentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathwayDocuments?: boolean | DocumentsCountOutputTypeCountPathwayDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentsCountOutputType
     */
    select?: DocumentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentsCountOutputType without action
   */
  export type DocumentsCountOutputTypeCountPathwayDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayDocumentsWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    countryLanguages: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryLanguages?: boolean | LanguageCountOutputTypeCountCountryLanguagesArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCountryLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryLanguageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    postBlock: number
    tags: number
    postVersionHistories: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postBlock?: boolean | PostCountOutputTypeCountPostBlockArgs
    tags?: boolean | PostCountOutputTypeCountTagsArgs
    postVersionHistories?: boolean | PostCountOutputTypeCountPostVersionHistoriesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostBlockWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostVersionHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionHistoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
    childTag: number
    parentTag: number
    children: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
    childTag?: boolean | TagCountOutputTypeCountChildTagArgs
    parentTag?: boolean | TagCountOutputTypeCountParentTagArgs
    children?: boolean | TagCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountChildTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagHierarchyWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountParentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagHierarchyWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type BlockCountOutputType
   */

  export type BlockCountOutputType = {
    blockField: number
    postBlock: number
  }

  export type BlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockField?: boolean | BlockCountOutputTypeCountBlockFieldArgs
    postBlock?: boolean | BlockCountOutputTypeCountPostBlockArgs
  }

  // Custom InputTypes
  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockCountOutputType
     */
    select?: BlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeCountBlockFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockFieldWhereInput
  }

  /**
   * BlockCountOutputType without action
   */
  export type BlockCountOutputTypeCountPostBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostBlockWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    postVersionHistory: number
    posts: number
    sessions: number
    roles: number
    socials: number
    Pathway: number
    resources: number
    contentResources: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postVersionHistory?: boolean | UserCountOutputTypeCountPostVersionHistoryArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    socials?: boolean | UserCountOutputTypeCountSocialsArgs
    Pathway?: boolean | UserCountOutputTypeCountPathwayArgs
    resources?: boolean | UserCountOutputTypeCountResourcesArgs
    contentResources?: boolean | UserCountOutputTypeCountContentResourcesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostVersionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRolesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPathwayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    UserRoles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRoles?: boolean | RolesCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRolesWhereInput
  }


  /**
   * Count Type SocialCountOutputType
   */

  export type SocialCountOutputType = {
    users: number
  }

  export type SocialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SocialCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SocialCountOutputType without action
   */
  export type SocialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialCountOutputType
     */
    select?: SocialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialCountOutputType without action
   */
  export type SocialCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialWhereInput
  }


  /**
   * Count Type PathwayTypesCountOutputType
   */

  export type PathwayTypesCountOutputType = {
    pathwayCategories: number
    children: number
  }

  export type PathwayTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathwayCategories?: boolean | PathwayTypesCountOutputTypeCountPathwayCategoriesArgs
    children?: boolean | PathwayTypesCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * PathwayTypesCountOutputType without action
   */
  export type PathwayTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypesCountOutputType
     */
    select?: PathwayTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PathwayTypesCountOutputType without action
   */
  export type PathwayTypesCountOutputTypeCountPathwayCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayCategoriesWhereInput
  }

  /**
   * PathwayTypesCountOutputType without action
   */
  export type PathwayTypesCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayTypesWhereInput
  }


  /**
   * Count Type ContentResourceTypeCountOutputType
   */

  export type ContentResourceTypeCountOutputType = {
    contentResources: number
  }

  export type ContentResourceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentResources?: boolean | ContentResourceTypeCountOutputTypeCountContentResourcesArgs
  }

  // Custom InputTypes
  /**
   * ContentResourceTypeCountOutputType without action
   */
  export type ContentResourceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceTypeCountOutputType
     */
    select?: ContentResourceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentResourceTypeCountOutputType without action
   */
  export type ContentResourceTypeCountOutputTypeCountContentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceWhereInput
  }


  /**
   * Count Type ContentResourceAreaCountOutputType
   */

  export type ContentResourceAreaCountOutputType = {
    contentResources: number
  }

  export type ContentResourceAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentResources?: boolean | ContentResourceAreaCountOutputTypeCountContentResourcesArgs
  }

  // Custom InputTypes
  /**
   * ContentResourceAreaCountOutputType without action
   */
  export type ContentResourceAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceAreaCountOutputType
     */
    select?: ContentResourceAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentResourceAreaCountOutputType without action
   */
  export type ContentResourceAreaCountOutputTypeCountContentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type CountryMaxAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type CountryCountAggregateOutputType = {
    code: number
    name: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    code?: true
    name?: true
  }

  export type CountryMaxAggregateInputType = {
    code?: true
    name?: true
  }

  export type CountryCountAggregateInputType = {
    code?: true
    name?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    code: string
    name: string
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    countryCurrencies?: boolean | Country$countryCurrenciesArgs<ExtArgs>
    countryLanguages?: boolean | Country$countryLanguagesArgs<ExtArgs>
    restrictedPathways?: boolean | Country$restrictedPathwaysArgs<ExtArgs>
    pathways?: boolean | Country$pathwaysArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    code?: boolean
    name?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryCurrencies?: boolean | Country$countryCurrenciesArgs<ExtArgs>
    countryLanguages?: boolean | Country$countryLanguagesArgs<ExtArgs>
    restrictedPathways?: boolean | Country$restrictedPathwaysArgs<ExtArgs>
    pathways?: boolean | Country$pathwaysArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      countryCurrencies: Prisma.$CountryCurrencyPayload<ExtArgs>[]
      countryLanguages: Prisma.$CountryLanguagePayload<ExtArgs>[]
      restrictedPathways: Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>[]
      pathways: Prisma.$PathwayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const countryWithCodeOnly = await prisma.country.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `code`
     * const countryWithCodeOnly = await prisma.country.createManyAndReturn({
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `code`
     * const countryWithCodeOnly = await prisma.country.updateManyAndReturn({
     *   select: { code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    countryCurrencies<T extends Country$countryCurrenciesArgs<ExtArgs> = {}>(args?: Subset<T, Country$countryCurrenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    countryLanguages<T extends Country$countryLanguagesArgs<ExtArgs> = {}>(args?: Subset<T, Country$countryLanguagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    restrictedPathways<T extends Country$restrictedPathwaysArgs<ExtArgs> = {}>(args?: Subset<T, Country$restrictedPathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathways<T extends Country$pathwaysArgs<ExtArgs> = {}>(args?: Subset<T, Country$pathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly code: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.countryCurrencies
   */
  export type Country$countryCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    where?: CountryCurrencyWhereInput
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    cursor?: CountryCurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountryCurrencyScalarFieldEnum | CountryCurrencyScalarFieldEnum[]
  }

  /**
   * Country.countryLanguages
   */
  export type Country$countryLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    where?: CountryLanguageWhereInput
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    cursor?: CountryLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountryLanguageScalarFieldEnum | CountryLanguageScalarFieldEnum[]
  }

  /**
   * Country.restrictedPathways
   */
  export type Country$restrictedPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    where?: PathwayRestrictedNationalityWhereInput
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayRestrictedNationalityScalarFieldEnum | PathwayRestrictedNationalityScalarFieldEnum[]
  }

  /**
   * Country.pathways
   */
  export type Country$pathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model CountryLanguage
   */

  export type AggregateCountryLanguage = {
    _count: CountryLanguageCountAggregateOutputType | null
    _min: CountryLanguageMinAggregateOutputType | null
    _max: CountryLanguageMaxAggregateOutputType | null
  }

  export type CountryLanguageMinAggregateOutputType = {
    countryCode: string | null
    languageCode: string | null
  }

  export type CountryLanguageMaxAggregateOutputType = {
    countryCode: string | null
    languageCode: string | null
  }

  export type CountryLanguageCountAggregateOutputType = {
    countryCode: number
    languageCode: number
    _all: number
  }


  export type CountryLanguageMinAggregateInputType = {
    countryCode?: true
    languageCode?: true
  }

  export type CountryLanguageMaxAggregateInputType = {
    countryCode?: true
    languageCode?: true
  }

  export type CountryLanguageCountAggregateInputType = {
    countryCode?: true
    languageCode?: true
    _all?: true
  }

  export type CountryLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryLanguage to aggregate.
     */
    where?: CountryLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryLanguages to fetch.
     */
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryLanguages
    **/
    _count?: true | CountryLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryLanguageMaxAggregateInputType
  }

  export type GetCountryLanguageAggregateType<T extends CountryLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryLanguage[P]>
      : GetScalarType<T[P], AggregateCountryLanguage[P]>
  }




  export type CountryLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryLanguageWhereInput
    orderBy?: CountryLanguageOrderByWithAggregationInput | CountryLanguageOrderByWithAggregationInput[]
    by: CountryLanguageScalarFieldEnum[] | CountryLanguageScalarFieldEnum
    having?: CountryLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryLanguageCountAggregateInputType | true
    _min?: CountryLanguageMinAggregateInputType
    _max?: CountryLanguageMaxAggregateInputType
  }

  export type CountryLanguageGroupByOutputType = {
    countryCode: string
    languageCode: string
    _count: CountryLanguageCountAggregateOutputType | null
    _min: CountryLanguageMinAggregateOutputType | null
    _max: CountryLanguageMaxAggregateOutputType | null
  }

  type GetCountryLanguageGroupByPayload<T extends CountryLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], CountryLanguageGroupByOutputType[P]>
        }
      >
    >


  export type CountryLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    languageCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryLanguage"]>

  export type CountryLanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    languageCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryLanguage"]>

  export type CountryLanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    languageCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryLanguage"]>

  export type CountryLanguageSelectScalar = {
    countryCode?: boolean
    languageCode?: boolean
  }

  export type CountryLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"countryCode" | "languageCode", ExtArgs["result"]["countryLanguage"]>
  export type CountryLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type CountryLanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }
  export type CountryLanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $CountryLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryLanguage"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      countryCode: string
      languageCode: string
    }, ExtArgs["result"]["countryLanguage"]>
    composites: {}
  }

  type CountryLanguageGetPayload<S extends boolean | null | undefined | CountryLanguageDefaultArgs> = $Result.GetResult<Prisma.$CountryLanguagePayload, S>

  type CountryLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryLanguageCountAggregateInputType | true
    }

  export interface CountryLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryLanguage'], meta: { name: 'CountryLanguage' } }
    /**
     * Find zero or one CountryLanguage that matches the filter.
     * @param {CountryLanguageFindUniqueArgs} args - Arguments to find a CountryLanguage
     * @example
     * // Get one CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryLanguageFindUniqueArgs>(args: SelectSubset<T, CountryLanguageFindUniqueArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountryLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryLanguageFindUniqueOrThrowArgs} args - Arguments to find a CountryLanguage
     * @example
     * // Get one CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageFindFirstArgs} args - Arguments to find a CountryLanguage
     * @example
     * // Get one CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryLanguageFindFirstArgs>(args?: SelectSubset<T, CountryLanguageFindFirstArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageFindFirstOrThrowArgs} args - Arguments to find a CountryLanguage
     * @example
     * // Get one CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountryLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryLanguages
     * const countryLanguages = await prisma.countryLanguage.findMany()
     * 
     * // Get first 10 CountryLanguages
     * const countryLanguages = await prisma.countryLanguage.findMany({ take: 10 })
     * 
     * // Only select the `countryCode`
     * const countryLanguageWithCountryCodeOnly = await prisma.countryLanguage.findMany({ select: { countryCode: true } })
     * 
     */
    findMany<T extends CountryLanguageFindManyArgs>(args?: SelectSubset<T, CountryLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountryLanguage.
     * @param {CountryLanguageCreateArgs} args - Arguments to create a CountryLanguage.
     * @example
     * // Create one CountryLanguage
     * const CountryLanguage = await prisma.countryLanguage.create({
     *   data: {
     *     // ... data to create a CountryLanguage
     *   }
     * })
     * 
     */
    create<T extends CountryLanguageCreateArgs>(args: SelectSubset<T, CountryLanguageCreateArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountryLanguages.
     * @param {CountryLanguageCreateManyArgs} args - Arguments to create many CountryLanguages.
     * @example
     * // Create many CountryLanguages
     * const countryLanguage = await prisma.countryLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryLanguageCreateManyArgs>(args?: SelectSubset<T, CountryLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryLanguages and returns the data saved in the database.
     * @param {CountryLanguageCreateManyAndReturnArgs} args - Arguments to create many CountryLanguages.
     * @example
     * // Create many CountryLanguages
     * const countryLanguage = await prisma.countryLanguage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryLanguages and only return the `countryCode`
     * const countryLanguageWithCountryCodeOnly = await prisma.countryLanguage.createManyAndReturn({
     *   select: { countryCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryLanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryLanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountryLanguage.
     * @param {CountryLanguageDeleteArgs} args - Arguments to delete one CountryLanguage.
     * @example
     * // Delete one CountryLanguage
     * const CountryLanguage = await prisma.countryLanguage.delete({
     *   where: {
     *     // ... filter to delete one CountryLanguage
     *   }
     * })
     * 
     */
    delete<T extends CountryLanguageDeleteArgs>(args: SelectSubset<T, CountryLanguageDeleteArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountryLanguage.
     * @param {CountryLanguageUpdateArgs} args - Arguments to update one CountryLanguage.
     * @example
     * // Update one CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryLanguageUpdateArgs>(args: SelectSubset<T, CountryLanguageUpdateArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountryLanguages.
     * @param {CountryLanguageDeleteManyArgs} args - Arguments to filter CountryLanguages to delete.
     * @example
     * // Delete a few CountryLanguages
     * const { count } = await prisma.countryLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryLanguageDeleteManyArgs>(args?: SelectSubset<T, CountryLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryLanguages
     * const countryLanguage = await prisma.countryLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryLanguageUpdateManyArgs>(args: SelectSubset<T, CountryLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryLanguages and returns the data updated in the database.
     * @param {CountryLanguageUpdateManyAndReturnArgs} args - Arguments to update many CountryLanguages.
     * @example
     * // Update many CountryLanguages
     * const countryLanguage = await prisma.countryLanguage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountryLanguages and only return the `countryCode`
     * const countryLanguageWithCountryCodeOnly = await prisma.countryLanguage.updateManyAndReturn({
     *   select: { countryCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryLanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryLanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountryLanguage.
     * @param {CountryLanguageUpsertArgs} args - Arguments to update or create a CountryLanguage.
     * @example
     * // Update or create a CountryLanguage
     * const countryLanguage = await prisma.countryLanguage.upsert({
     *   create: {
     *     // ... data to create a CountryLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryLanguage we want to update
     *   }
     * })
     */
    upsert<T extends CountryLanguageUpsertArgs>(args: SelectSubset<T, CountryLanguageUpsertArgs<ExtArgs>>): Prisma__CountryLanguageClient<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountryLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageCountArgs} args - Arguments to filter CountryLanguages to count.
     * @example
     * // Count the number of CountryLanguages
     * const count = await prisma.countryLanguage.count({
     *   where: {
     *     // ... the filter for the CountryLanguages we want to count
     *   }
     * })
    **/
    count<T extends CountryLanguageCountArgs>(
      args?: Subset<T, CountryLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryLanguageAggregateArgs>(args: Subset<T, CountryLanguageAggregateArgs>): Prisma.PrismaPromise<GetCountryLanguageAggregateType<T>>

    /**
     * Group by CountryLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryLanguageGroupByArgs['orderBy'] }
        : { orderBy?: CountryLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryLanguage model
   */
  readonly fields: CountryLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryLanguage model
   */
  interface CountryLanguageFieldRefs {
    readonly countryCode: FieldRef<"CountryLanguage", 'String'>
    readonly languageCode: FieldRef<"CountryLanguage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CountryLanguage findUnique
   */
  export type CountryLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter, which CountryLanguage to fetch.
     */
    where: CountryLanguageWhereUniqueInput
  }

  /**
   * CountryLanguage findUniqueOrThrow
   */
  export type CountryLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter, which CountryLanguage to fetch.
     */
    where: CountryLanguageWhereUniqueInput
  }

  /**
   * CountryLanguage findFirst
   */
  export type CountryLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter, which CountryLanguage to fetch.
     */
    where?: CountryLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryLanguages to fetch.
     */
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryLanguages.
     */
    cursor?: CountryLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryLanguages.
     */
    distinct?: CountryLanguageScalarFieldEnum | CountryLanguageScalarFieldEnum[]
  }

  /**
   * CountryLanguage findFirstOrThrow
   */
  export type CountryLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter, which CountryLanguage to fetch.
     */
    where?: CountryLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryLanguages to fetch.
     */
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryLanguages.
     */
    cursor?: CountryLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryLanguages.
     */
    distinct?: CountryLanguageScalarFieldEnum | CountryLanguageScalarFieldEnum[]
  }

  /**
   * CountryLanguage findMany
   */
  export type CountryLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter, which CountryLanguages to fetch.
     */
    where?: CountryLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryLanguages to fetch.
     */
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryLanguages.
     */
    cursor?: CountryLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryLanguages.
     */
    skip?: number
    distinct?: CountryLanguageScalarFieldEnum | CountryLanguageScalarFieldEnum[]
  }

  /**
   * CountryLanguage create
   */
  export type CountryLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a CountryLanguage.
     */
    data: XOR<CountryLanguageCreateInput, CountryLanguageUncheckedCreateInput>
  }

  /**
   * CountryLanguage createMany
   */
  export type CountryLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryLanguages.
     */
    data: CountryLanguageCreateManyInput | CountryLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryLanguage createManyAndReturn
   */
  export type CountryLanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * The data used to create many CountryLanguages.
     */
    data: CountryLanguageCreateManyInput | CountryLanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryLanguage update
   */
  export type CountryLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a CountryLanguage.
     */
    data: XOR<CountryLanguageUpdateInput, CountryLanguageUncheckedUpdateInput>
    /**
     * Choose, which CountryLanguage to update.
     */
    where: CountryLanguageWhereUniqueInput
  }

  /**
   * CountryLanguage updateMany
   */
  export type CountryLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryLanguages.
     */
    data: XOR<CountryLanguageUpdateManyMutationInput, CountryLanguageUncheckedUpdateManyInput>
    /**
     * Filter which CountryLanguages to update
     */
    where?: CountryLanguageWhereInput
    /**
     * Limit how many CountryLanguages to update.
     */
    limit?: number
  }

  /**
   * CountryLanguage updateManyAndReturn
   */
  export type CountryLanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * The data used to update CountryLanguages.
     */
    data: XOR<CountryLanguageUpdateManyMutationInput, CountryLanguageUncheckedUpdateManyInput>
    /**
     * Filter which CountryLanguages to update
     */
    where?: CountryLanguageWhereInput
    /**
     * Limit how many CountryLanguages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryLanguage upsert
   */
  export type CountryLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the CountryLanguage to update in case it exists.
     */
    where: CountryLanguageWhereUniqueInput
    /**
     * In case the CountryLanguage found by the `where` argument doesn't exist, create a new CountryLanguage with this data.
     */
    create: XOR<CountryLanguageCreateInput, CountryLanguageUncheckedCreateInput>
    /**
     * In case the CountryLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryLanguageUpdateInput, CountryLanguageUncheckedUpdateInput>
  }

  /**
   * CountryLanguage delete
   */
  export type CountryLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    /**
     * Filter which CountryLanguage to delete.
     */
    where: CountryLanguageWhereUniqueInput
  }

  /**
   * CountryLanguage deleteMany
   */
  export type CountryLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryLanguages to delete
     */
    where?: CountryLanguageWhereInput
    /**
     * Limit how many CountryLanguages to delete.
     */
    limit?: number
  }

  /**
   * CountryLanguage without action
   */
  export type CountryLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
  }


  /**
   * Model CountryCurrency
   */

  export type AggregateCountryCurrency = {
    _count: CountryCurrencyCountAggregateOutputType | null
    _min: CountryCurrencyMinAggregateOutputType | null
    _max: CountryCurrencyMaxAggregateOutputType | null
  }

  export type CountryCurrencyMinAggregateOutputType = {
    countryCode: string | null
    currencyCode: string | null
  }

  export type CountryCurrencyMaxAggregateOutputType = {
    countryCode: string | null
    currencyCode: string | null
  }

  export type CountryCurrencyCountAggregateOutputType = {
    countryCode: number
    currencyCode: number
    _all: number
  }


  export type CountryCurrencyMinAggregateInputType = {
    countryCode?: true
    currencyCode?: true
  }

  export type CountryCurrencyMaxAggregateInputType = {
    countryCode?: true
    currencyCode?: true
  }

  export type CountryCurrencyCountAggregateInputType = {
    countryCode?: true
    currencyCode?: true
    _all?: true
  }

  export type CountryCurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCurrency to aggregate.
     */
    where?: CountryCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCurrencies to fetch.
     */
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryCurrencies
    **/
    _count?: true | CountryCurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryCurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryCurrencyMaxAggregateInputType
  }

  export type GetCountryCurrencyAggregateType<T extends CountryCurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryCurrency[P]>
      : GetScalarType<T[P], AggregateCountryCurrency[P]>
  }




  export type CountryCurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCurrencyWhereInput
    orderBy?: CountryCurrencyOrderByWithAggregationInput | CountryCurrencyOrderByWithAggregationInput[]
    by: CountryCurrencyScalarFieldEnum[] | CountryCurrencyScalarFieldEnum
    having?: CountryCurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCurrencyCountAggregateInputType | true
    _min?: CountryCurrencyMinAggregateInputType
    _max?: CountryCurrencyMaxAggregateInputType
  }

  export type CountryCurrencyGroupByOutputType = {
    countryCode: string
    currencyCode: string
    _count: CountryCurrencyCountAggregateOutputType | null
    _min: CountryCurrencyMinAggregateOutputType | null
    _max: CountryCurrencyMaxAggregateOutputType | null
  }

  type GetCountryCurrencyGroupByPayload<T extends CountryCurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryCurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryCurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryCurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CountryCurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CountryCurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    currencyCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryCurrency"]>

  export type CountryCurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    currencyCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryCurrency"]>

  export type CountryCurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countryCode?: boolean
    currencyCode?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryCurrency"]>

  export type CountryCurrencySelectScalar = {
    countryCode?: boolean
    currencyCode?: boolean
  }

  export type CountryCurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"countryCode" | "currencyCode", ExtArgs["result"]["countryCurrency"]>
  export type CountryCurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type CountryCurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type CountryCurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $CountryCurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryCurrency"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      countryCode: string
      currencyCode: string
    }, ExtArgs["result"]["countryCurrency"]>
    composites: {}
  }

  type CountryCurrencyGetPayload<S extends boolean | null | undefined | CountryCurrencyDefaultArgs> = $Result.GetResult<Prisma.$CountryCurrencyPayload, S>

  type CountryCurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryCurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCurrencyCountAggregateInputType | true
    }

  export interface CountryCurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryCurrency'], meta: { name: 'CountryCurrency' } }
    /**
     * Find zero or one CountryCurrency that matches the filter.
     * @param {CountryCurrencyFindUniqueArgs} args - Arguments to find a CountryCurrency
     * @example
     * // Get one CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryCurrencyFindUniqueArgs>(args: SelectSubset<T, CountryCurrencyFindUniqueArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountryCurrency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryCurrencyFindUniqueOrThrowArgs} args - Arguments to find a CountryCurrency
     * @example
     * // Get one CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryCurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryCurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCurrency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyFindFirstArgs} args - Arguments to find a CountryCurrency
     * @example
     * // Get one CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryCurrencyFindFirstArgs>(args?: SelectSubset<T, CountryCurrencyFindFirstArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCurrency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyFindFirstOrThrowArgs} args - Arguments to find a CountryCurrency
     * @example
     * // Get one CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryCurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryCurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountryCurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryCurrencies
     * const countryCurrencies = await prisma.countryCurrency.findMany()
     * 
     * // Get first 10 CountryCurrencies
     * const countryCurrencies = await prisma.countryCurrency.findMany({ take: 10 })
     * 
     * // Only select the `countryCode`
     * const countryCurrencyWithCountryCodeOnly = await prisma.countryCurrency.findMany({ select: { countryCode: true } })
     * 
     */
    findMany<T extends CountryCurrencyFindManyArgs>(args?: SelectSubset<T, CountryCurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountryCurrency.
     * @param {CountryCurrencyCreateArgs} args - Arguments to create a CountryCurrency.
     * @example
     * // Create one CountryCurrency
     * const CountryCurrency = await prisma.countryCurrency.create({
     *   data: {
     *     // ... data to create a CountryCurrency
     *   }
     * })
     * 
     */
    create<T extends CountryCurrencyCreateArgs>(args: SelectSubset<T, CountryCurrencyCreateArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountryCurrencies.
     * @param {CountryCurrencyCreateManyArgs} args - Arguments to create many CountryCurrencies.
     * @example
     * // Create many CountryCurrencies
     * const countryCurrency = await prisma.countryCurrency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCurrencyCreateManyArgs>(args?: SelectSubset<T, CountryCurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryCurrencies and returns the data saved in the database.
     * @param {CountryCurrencyCreateManyAndReturnArgs} args - Arguments to create many CountryCurrencies.
     * @example
     * // Create many CountryCurrencies
     * const countryCurrency = await prisma.countryCurrency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryCurrencies and only return the `countryCode`
     * const countryCurrencyWithCountryCodeOnly = await prisma.countryCurrency.createManyAndReturn({
     *   select: { countryCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountryCurrency.
     * @param {CountryCurrencyDeleteArgs} args - Arguments to delete one CountryCurrency.
     * @example
     * // Delete one CountryCurrency
     * const CountryCurrency = await prisma.countryCurrency.delete({
     *   where: {
     *     // ... filter to delete one CountryCurrency
     *   }
     * })
     * 
     */
    delete<T extends CountryCurrencyDeleteArgs>(args: SelectSubset<T, CountryCurrencyDeleteArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountryCurrency.
     * @param {CountryCurrencyUpdateArgs} args - Arguments to update one CountryCurrency.
     * @example
     * // Update one CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryCurrencyUpdateArgs>(args: SelectSubset<T, CountryCurrencyUpdateArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountryCurrencies.
     * @param {CountryCurrencyDeleteManyArgs} args - Arguments to filter CountryCurrencies to delete.
     * @example
     * // Delete a few CountryCurrencies
     * const { count } = await prisma.countryCurrency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryCurrencyDeleteManyArgs>(args?: SelectSubset<T, CountryCurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryCurrencies
     * const countryCurrency = await prisma.countryCurrency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryCurrencyUpdateManyArgs>(args: SelectSubset<T, CountryCurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCurrencies and returns the data updated in the database.
     * @param {CountryCurrencyUpdateManyAndReturnArgs} args - Arguments to update many CountryCurrencies.
     * @example
     * // Update many CountryCurrencies
     * const countryCurrency = await prisma.countryCurrency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountryCurrencies and only return the `countryCode`
     * const countryCurrencyWithCountryCodeOnly = await prisma.countryCurrency.updateManyAndReturn({
     *   select: { countryCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryCurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryCurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountryCurrency.
     * @param {CountryCurrencyUpsertArgs} args - Arguments to update or create a CountryCurrency.
     * @example
     * // Update or create a CountryCurrency
     * const countryCurrency = await prisma.countryCurrency.upsert({
     *   create: {
     *     // ... data to create a CountryCurrency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryCurrency we want to update
     *   }
     * })
     */
    upsert<T extends CountryCurrencyUpsertArgs>(args: SelectSubset<T, CountryCurrencyUpsertArgs<ExtArgs>>): Prisma__CountryCurrencyClient<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountryCurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyCountArgs} args - Arguments to filter CountryCurrencies to count.
     * @example
     * // Count the number of CountryCurrencies
     * const count = await prisma.countryCurrency.count({
     *   where: {
     *     // ... the filter for the CountryCurrencies we want to count
     *   }
     * })
    **/
    count<T extends CountryCurrencyCountArgs>(
      args?: Subset<T, CountryCurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryCurrencyAggregateArgs>(args: Subset<T, CountryCurrencyAggregateArgs>): Prisma.PrismaPromise<GetCountryCurrencyAggregateType<T>>

    /**
     * Group by CountryCurrency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryCurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryCurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CountryCurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryCurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryCurrency model
   */
  readonly fields: CountryCurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryCurrency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryCurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryCurrency model
   */
  interface CountryCurrencyFieldRefs {
    readonly countryCode: FieldRef<"CountryCurrency", 'String'>
    readonly currencyCode: FieldRef<"CountryCurrency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CountryCurrency findUnique
   */
  export type CountryCurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CountryCurrency to fetch.
     */
    where: CountryCurrencyWhereUniqueInput
  }

  /**
   * CountryCurrency findUniqueOrThrow
   */
  export type CountryCurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CountryCurrency to fetch.
     */
    where: CountryCurrencyWhereUniqueInput
  }

  /**
   * CountryCurrency findFirst
   */
  export type CountryCurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CountryCurrency to fetch.
     */
    where?: CountryCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCurrencies to fetch.
     */
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCurrencies.
     */
    cursor?: CountryCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCurrencies.
     */
    distinct?: CountryCurrencyScalarFieldEnum | CountryCurrencyScalarFieldEnum[]
  }

  /**
   * CountryCurrency findFirstOrThrow
   */
  export type CountryCurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CountryCurrency to fetch.
     */
    where?: CountryCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCurrencies to fetch.
     */
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCurrencies.
     */
    cursor?: CountryCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCurrencies.
     */
    distinct?: CountryCurrencyScalarFieldEnum | CountryCurrencyScalarFieldEnum[]
  }

  /**
   * CountryCurrency findMany
   */
  export type CountryCurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter, which CountryCurrencies to fetch.
     */
    where?: CountryCurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCurrencies to fetch.
     */
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryCurrencies.
     */
    cursor?: CountryCurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryCurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCurrencies.
     */
    skip?: number
    distinct?: CountryCurrencyScalarFieldEnum | CountryCurrencyScalarFieldEnum[]
  }

  /**
   * CountryCurrency create
   */
  export type CountryCurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a CountryCurrency.
     */
    data: XOR<CountryCurrencyCreateInput, CountryCurrencyUncheckedCreateInput>
  }

  /**
   * CountryCurrency createMany
   */
  export type CountryCurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryCurrencies.
     */
    data: CountryCurrencyCreateManyInput | CountryCurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCurrency createManyAndReturn
   */
  export type CountryCurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many CountryCurrencies.
     */
    data: CountryCurrencyCreateManyInput | CountryCurrencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryCurrency update
   */
  export type CountryCurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a CountryCurrency.
     */
    data: XOR<CountryCurrencyUpdateInput, CountryCurrencyUncheckedUpdateInput>
    /**
     * Choose, which CountryCurrency to update.
     */
    where: CountryCurrencyWhereUniqueInput
  }

  /**
   * CountryCurrency updateMany
   */
  export type CountryCurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryCurrencies.
     */
    data: XOR<CountryCurrencyUpdateManyMutationInput, CountryCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which CountryCurrencies to update
     */
    where?: CountryCurrencyWhereInput
    /**
     * Limit how many CountryCurrencies to update.
     */
    limit?: number
  }

  /**
   * CountryCurrency updateManyAndReturn
   */
  export type CountryCurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * The data used to update CountryCurrencies.
     */
    data: XOR<CountryCurrencyUpdateManyMutationInput, CountryCurrencyUncheckedUpdateManyInput>
    /**
     * Filter which CountryCurrencies to update
     */
    where?: CountryCurrencyWhereInput
    /**
     * Limit how many CountryCurrencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryCurrency upsert
   */
  export type CountryCurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the CountryCurrency to update in case it exists.
     */
    where: CountryCurrencyWhereUniqueInput
    /**
     * In case the CountryCurrency found by the `where` argument doesn't exist, create a new CountryCurrency with this data.
     */
    create: XOR<CountryCurrencyCreateInput, CountryCurrencyUncheckedCreateInput>
    /**
     * In case the CountryCurrency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryCurrencyUpdateInput, CountryCurrencyUncheckedUpdateInput>
  }

  /**
   * CountryCurrency delete
   */
  export type CountryCurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    /**
     * Filter which CountryCurrency to delete.
     */
    where: CountryCurrencyWhereUniqueInput
  }

  /**
   * CountryCurrency deleteMany
   */
  export type CountryCurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCurrencies to delete
     */
    where?: CountryCurrencyWhereInput
    /**
     * Limit how many CountryCurrencies to delete.
     */
    limit?: number
  }

  /**
   * CountryCurrency without action
   */
  export type CountryCurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
  }


  /**
   * Model Pathway
   */

  export type AggregatePathway = {
    _count: PathwayCountAggregateOutputType | null
    _avg: PathwayAvgAggregateOutputType | null
    _sum: PathwaySumAggregateOutputType | null
    _min: PathwayMinAggregateOutputType | null
    _max: PathwayMaxAggregateOutputType | null
  }

  export type PathwayAvgAggregateOutputType = {
    id: number | null
  }

  export type PathwaySumAggregateOutputType = {
    id: number | null
  }

  export type PathwayMinAggregateOutputType = {
    id: number | null
    countryCode: string | null
    name: string | null
    link: string | null
    description: string | null
    type: $Enums.PathwayType | null
    createdAt: Date | null
    updatedAt: Date | null
    currencyCode: string | null
    createdby: string | null
  }

  export type PathwayMaxAggregateOutputType = {
    id: number | null
    countryCode: string | null
    name: string | null
    link: string | null
    description: string | null
    type: $Enums.PathwayType | null
    createdAt: Date | null
    updatedAt: Date | null
    currencyCode: string | null
    createdby: string | null
  }

  export type PathwayCountAggregateOutputType = {
    id: number
    countryCode: number
    name: number
    link: number
    description: number
    type: number
    createdAt: number
    updatedAt: number
    currencyCode: number
    notes: number
    limitations: number
    requirements: number
    restrictions: number
    duration: number
    processTime: number
    renewal: number
    cost: number
    createdby: number
    _all: number
  }


  export type PathwayAvgAggregateInputType = {
    id?: true
  }

  export type PathwaySumAggregateInputType = {
    id?: true
  }

  export type PathwayMinAggregateInputType = {
    id?: true
    countryCode?: true
    name?: true
    link?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    currencyCode?: true
    createdby?: true
  }

  export type PathwayMaxAggregateInputType = {
    id?: true
    countryCode?: true
    name?: true
    link?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    currencyCode?: true
    createdby?: true
  }

  export type PathwayCountAggregateInputType = {
    id?: true
    countryCode?: true
    name?: true
    link?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    currencyCode?: true
    notes?: true
    limitations?: true
    requirements?: true
    restrictions?: true
    duration?: true
    processTime?: true
    renewal?: true
    cost?: true
    createdby?: true
    _all?: true
  }

  export type PathwayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pathway to aggregate.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pathways
    **/
    _count?: true | PathwayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayMaxAggregateInputType
  }

  export type GetPathwayAggregateType<T extends PathwayAggregateArgs> = {
        [P in keyof T & keyof AggregatePathway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathway[P]>
      : GetScalarType<T[P], AggregatePathway[P]>
  }




  export type PathwayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithAggregationInput | PathwayOrderByWithAggregationInput[]
    by: PathwayScalarFieldEnum[] | PathwayScalarFieldEnum
    having?: PathwayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayCountAggregateInputType | true
    _avg?: PathwayAvgAggregateInputType
    _sum?: PathwaySumAggregateInputType
    _min?: PathwayMinAggregateInputType
    _max?: PathwayMaxAggregateInputType
  }

  export type PathwayGroupByOutputType = {
    id: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt: Date
    updatedAt: Date
    currencyCode: string
    notes: string[]
    limitations: string[]
    requirements: string[]
    restrictions: string[]
    duration: JsonValue | null
    processTime: JsonValue | null
    renewal: JsonValue | null
    cost: JsonValue | null
    createdby: string
    _count: PathwayCountAggregateOutputType | null
    _avg: PathwayAvgAggregateOutputType | null
    _sum: PathwaySumAggregateOutputType | null
    _min: PathwayMinAggregateOutputType | null
    _max: PathwayMaxAggregateOutputType | null
  }

  type GetPathwayGroupByPayload<T extends PathwayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayGroupByOutputType[P]>
        }
      >
    >


  export type PathwaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    name?: boolean
    link?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencyCode?: boolean
    notes?: boolean
    limitations?: boolean
    requirements?: boolean
    restrictions?: boolean
    duration?: boolean
    processTime?: boolean
    renewal?: boolean
    cost?: boolean
    createdby?: boolean
    documents?: boolean | Pathway$documentsArgs<ExtArgs>
    categories?: boolean | Pathway$categoriesArgs<ExtArgs>
    pipelines?: boolean | Pathway$pipelinesArgs<ExtArgs>
    restrictedNationalities?: boolean | Pathway$restrictedNationalitiesArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PathwayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    name?: boolean
    link?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencyCode?: boolean
    notes?: boolean
    limitations?: boolean
    requirements?: boolean
    restrictions?: boolean
    duration?: boolean
    processTime?: boolean
    renewal?: boolean
    cost?: boolean
    createdby?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    name?: boolean
    link?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencyCode?: boolean
    notes?: boolean
    limitations?: boolean
    requirements?: boolean
    restrictions?: boolean
    duration?: boolean
    processTime?: boolean
    renewal?: boolean
    cost?: boolean
    createdby?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectScalar = {
    id?: boolean
    countryCode?: boolean
    name?: boolean
    link?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currencyCode?: boolean
    notes?: boolean
    limitations?: boolean
    requirements?: boolean
    restrictions?: boolean
    duration?: boolean
    processTime?: boolean
    renewal?: boolean
    cost?: boolean
    createdby?: boolean
  }

  export type PathwayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countryCode" | "name" | "link" | "description" | "type" | "createdAt" | "updatedAt" | "currencyCode" | "notes" | "limitations" | "requirements" | "restrictions" | "duration" | "processTime" | "renewal" | "cost" | "createdby", ExtArgs["result"]["pathway"]>
  export type PathwayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | Pathway$documentsArgs<ExtArgs>
    categories?: boolean | Pathway$categoriesArgs<ExtArgs>
    pipelines?: boolean | Pathway$pipelinesArgs<ExtArgs>
    restrictedNationalities?: boolean | Pathway$restrictedNationalitiesArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PathwayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PathwayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PathwayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    CMS_User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PathwayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pathway"
    objects: {
      documents: Prisma.$PathwayDocumentsPayload<ExtArgs>[]
      categories: Prisma.$PathwayCategoriesPayload<ExtArgs>[]
      pipelines: Prisma.$PathwayPipelinePayload<ExtArgs>[]
      restrictedNationalities: Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>[]
      country: Prisma.$CountryPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
      CMS_User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countryCode: string
      name: string
      link: string
      description: string
      type: $Enums.PathwayType
      createdAt: Date
      updatedAt: Date
      currencyCode: string
      notes: string[]
      limitations: string[]
      requirements: string[]
      restrictions: string[]
      duration: Prisma.JsonValue | null
      processTime: Prisma.JsonValue | null
      renewal: Prisma.JsonValue | null
      cost: Prisma.JsonValue | null
      createdby: string
    }, ExtArgs["result"]["pathway"]>
    composites: {}
  }

  type PathwayGetPayload<S extends boolean | null | undefined | PathwayDefaultArgs> = $Result.GetResult<Prisma.$PathwayPayload, S>

  type PathwayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayCountAggregateInputType | true
    }

  export interface PathwayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pathway'], meta: { name: 'Pathway' } }
    /**
     * Find zero or one Pathway that matches the filter.
     * @param {PathwayFindUniqueArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayFindUniqueArgs>(args: SelectSubset<T, PathwayFindUniqueArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pathway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayFindUniqueOrThrowArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pathway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindFirstArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayFindFirstArgs>(args?: SelectSubset<T, PathwayFindFirstArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pathway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindFirstOrThrowArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pathways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pathways
     * const pathways = await prisma.pathway.findMany()
     * 
     * // Get first 10 Pathways
     * const pathways = await prisma.pathway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathwayWithIdOnly = await prisma.pathway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathwayFindManyArgs>(args?: SelectSubset<T, PathwayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pathway.
     * @param {PathwayCreateArgs} args - Arguments to create a Pathway.
     * @example
     * // Create one Pathway
     * const Pathway = await prisma.pathway.create({
     *   data: {
     *     // ... data to create a Pathway
     *   }
     * })
     * 
     */
    create<T extends PathwayCreateArgs>(args: SelectSubset<T, PathwayCreateArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pathways.
     * @param {PathwayCreateManyArgs} args - Arguments to create many Pathways.
     * @example
     * // Create many Pathways
     * const pathway = await prisma.pathway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayCreateManyArgs>(args?: SelectSubset<T, PathwayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pathways and returns the data saved in the database.
     * @param {PathwayCreateManyAndReturnArgs} args - Arguments to create many Pathways.
     * @example
     * // Create many Pathways
     * const pathway = await prisma.pathway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pathways and only return the `id`
     * const pathwayWithIdOnly = await prisma.pathway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pathway.
     * @param {PathwayDeleteArgs} args - Arguments to delete one Pathway.
     * @example
     * // Delete one Pathway
     * const Pathway = await prisma.pathway.delete({
     *   where: {
     *     // ... filter to delete one Pathway
     *   }
     * })
     * 
     */
    delete<T extends PathwayDeleteArgs>(args: SelectSubset<T, PathwayDeleteArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pathway.
     * @param {PathwayUpdateArgs} args - Arguments to update one Pathway.
     * @example
     * // Update one Pathway
     * const pathway = await prisma.pathway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayUpdateArgs>(args: SelectSubset<T, PathwayUpdateArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pathways.
     * @param {PathwayDeleteManyArgs} args - Arguments to filter Pathways to delete.
     * @example
     * // Delete a few Pathways
     * const { count } = await prisma.pathway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayDeleteManyArgs>(args?: SelectSubset<T, PathwayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pathways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pathways
     * const pathway = await prisma.pathway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayUpdateManyArgs>(args: SelectSubset<T, PathwayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pathways and returns the data updated in the database.
     * @param {PathwayUpdateManyAndReturnArgs} args - Arguments to update many Pathways.
     * @example
     * // Update many Pathways
     * const pathway = await prisma.pathway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pathways and only return the `id`
     * const pathwayWithIdOnly = await prisma.pathway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pathway.
     * @param {PathwayUpsertArgs} args - Arguments to update or create a Pathway.
     * @example
     * // Update or create a Pathway
     * const pathway = await prisma.pathway.upsert({
     *   create: {
     *     // ... data to create a Pathway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pathway we want to update
     *   }
     * })
     */
    upsert<T extends PathwayUpsertArgs>(args: SelectSubset<T, PathwayUpsertArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pathways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCountArgs} args - Arguments to filter Pathways to count.
     * @example
     * // Count the number of Pathways
     * const count = await prisma.pathway.count({
     *   where: {
     *     // ... the filter for the Pathways we want to count
     *   }
     * })
    **/
    count<T extends PathwayCountArgs>(
      args?: Subset<T, PathwayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pathway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayAggregateArgs>(args: Subset<T, PathwayAggregateArgs>): Prisma.PrismaPromise<GetPathwayAggregateType<T>>

    /**
     * Group by Pathway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayGroupByArgs['orderBy'] }
        : { orderBy?: PathwayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pathway model
   */
  readonly fields: PathwayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pathway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends Pathway$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Pathway$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Pathway$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Pathway$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends Pathway$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Pathway$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    restrictedNationalities<T extends Pathway$restrictedNationalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Pathway$restrictedNationalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CMS_User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pathway model
   */
  interface PathwayFieldRefs {
    readonly id: FieldRef<"Pathway", 'Int'>
    readonly countryCode: FieldRef<"Pathway", 'String'>
    readonly name: FieldRef<"Pathway", 'String'>
    readonly link: FieldRef<"Pathway", 'String'>
    readonly description: FieldRef<"Pathway", 'String'>
    readonly type: FieldRef<"Pathway", 'PathwayType'>
    readonly createdAt: FieldRef<"Pathway", 'DateTime'>
    readonly updatedAt: FieldRef<"Pathway", 'DateTime'>
    readonly currencyCode: FieldRef<"Pathway", 'String'>
    readonly notes: FieldRef<"Pathway", 'String[]'>
    readonly limitations: FieldRef<"Pathway", 'String[]'>
    readonly requirements: FieldRef<"Pathway", 'String[]'>
    readonly restrictions: FieldRef<"Pathway", 'String[]'>
    readonly duration: FieldRef<"Pathway", 'Json'>
    readonly processTime: FieldRef<"Pathway", 'Json'>
    readonly renewal: FieldRef<"Pathway", 'Json'>
    readonly cost: FieldRef<"Pathway", 'Json'>
    readonly createdby: FieldRef<"Pathway", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pathway findUnique
   */
  export type PathwayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway findUniqueOrThrow
   */
  export type PathwayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway findFirst
   */
  export type PathwayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pathways.
     */
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway findFirstOrThrow
   */
  export type PathwayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pathways.
     */
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway findMany
   */
  export type PathwayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathways to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway create
   */
  export type PathwayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The data needed to create a Pathway.
     */
    data: XOR<PathwayCreateInput, PathwayUncheckedCreateInput>
  }

  /**
   * Pathway createMany
   */
  export type PathwayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pathways.
     */
    data: PathwayCreateManyInput | PathwayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pathway createManyAndReturn
   */
  export type PathwayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * The data used to create many Pathways.
     */
    data: PathwayCreateManyInput | PathwayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pathway update
   */
  export type PathwayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The data needed to update a Pathway.
     */
    data: XOR<PathwayUpdateInput, PathwayUncheckedUpdateInput>
    /**
     * Choose, which Pathway to update.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway updateMany
   */
  export type PathwayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pathways.
     */
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyInput>
    /**
     * Filter which Pathways to update
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to update.
     */
    limit?: number
  }

  /**
   * Pathway updateManyAndReturn
   */
  export type PathwayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * The data used to update Pathways.
     */
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyInput>
    /**
     * Filter which Pathways to update
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pathway upsert
   */
  export type PathwayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The filter to search for the Pathway to update in case it exists.
     */
    where: PathwayWhereUniqueInput
    /**
     * In case the Pathway found by the `where` argument doesn't exist, create a new Pathway with this data.
     */
    create: XOR<PathwayCreateInput, PathwayUncheckedCreateInput>
    /**
     * In case the Pathway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayUpdateInput, PathwayUncheckedUpdateInput>
  }

  /**
   * Pathway delete
   */
  export type PathwayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter which Pathway to delete.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway deleteMany
   */
  export type PathwayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pathways to delete
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to delete.
     */
    limit?: number
  }

  /**
   * Pathway.documents
   */
  export type Pathway$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    where?: PathwayDocumentsWhereInput
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    cursor?: PathwayDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayDocumentsScalarFieldEnum | PathwayDocumentsScalarFieldEnum[]
  }

  /**
   * Pathway.categories
   */
  export type Pathway$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    where?: PathwayCategoriesWhereInput
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    cursor?: PathwayCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayCategoriesScalarFieldEnum | PathwayCategoriesScalarFieldEnum[]
  }

  /**
   * Pathway.pipelines
   */
  export type Pathway$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    where?: PathwayPipelineWhereInput
    orderBy?: PathwayPipelineOrderByWithRelationInput | PathwayPipelineOrderByWithRelationInput[]
    cursor?: PathwayPipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayPipelineScalarFieldEnum | PathwayPipelineScalarFieldEnum[]
  }

  /**
   * Pathway.restrictedNationalities
   */
  export type Pathway$restrictedNationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    where?: PathwayRestrictedNationalityWhereInput
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayRestrictedNationalityScalarFieldEnum | PathwayRestrictedNationalityScalarFieldEnum[]
  }

  /**
   * Pathway without action
   */
  export type PathwayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
  }


  /**
   * Model PathwayPipeline
   */

  export type AggregatePathwayPipeline = {
    _count: PathwayPipelineCountAggregateOutputType | null
    _avg: PathwayPipelineAvgAggregateOutputType | null
    _sum: PathwayPipelineSumAggregateOutputType | null
    _min: PathwayPipelineMinAggregateOutputType | null
    _max: PathwayPipelineMaxAggregateOutputType | null
  }

  export type PathwayPipelineAvgAggregateOutputType = {
    id: number | null
    pathwayId: number | null
  }

  export type PathwayPipelineSumAggregateOutputType = {
    id: number | null
    pathwayId: number | null
  }

  export type PathwayPipelineMinAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    pipeline: $Enums.PathwayPipelines | null
    note: string | null
  }

  export type PathwayPipelineMaxAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    pipeline: $Enums.PathwayPipelines | null
    note: string | null
  }

  export type PathwayPipelineCountAggregateOutputType = {
    id: number
    pathwayId: number
    pipeline: number
    note: number
    _all: number
  }


  export type PathwayPipelineAvgAggregateInputType = {
    id?: true
    pathwayId?: true
  }

  export type PathwayPipelineSumAggregateInputType = {
    id?: true
    pathwayId?: true
  }

  export type PathwayPipelineMinAggregateInputType = {
    id?: true
    pathwayId?: true
    pipeline?: true
    note?: true
  }

  export type PathwayPipelineMaxAggregateInputType = {
    id?: true
    pathwayId?: true
    pipeline?: true
    note?: true
  }

  export type PathwayPipelineCountAggregateInputType = {
    id?: true
    pathwayId?: true
    pipeline?: true
    note?: true
    _all?: true
  }

  export type PathwayPipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayPipeline to aggregate.
     */
    where?: PathwayPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayPipelines to fetch.
     */
    orderBy?: PathwayPipelineOrderByWithRelationInput | PathwayPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PathwayPipelines
    **/
    _count?: true | PathwayPipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayPipelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwayPipelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayPipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayPipelineMaxAggregateInputType
  }

  export type GetPathwayPipelineAggregateType<T extends PathwayPipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePathwayPipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathwayPipeline[P]>
      : GetScalarType<T[P], AggregatePathwayPipeline[P]>
  }




  export type PathwayPipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayPipelineWhereInput
    orderBy?: PathwayPipelineOrderByWithAggregationInput | PathwayPipelineOrderByWithAggregationInput[]
    by: PathwayPipelineScalarFieldEnum[] | PathwayPipelineScalarFieldEnum
    having?: PathwayPipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayPipelineCountAggregateInputType | true
    _avg?: PathwayPipelineAvgAggregateInputType
    _sum?: PathwayPipelineSumAggregateInputType
    _min?: PathwayPipelineMinAggregateInputType
    _max?: PathwayPipelineMaxAggregateInputType
  }

  export type PathwayPipelineGroupByOutputType = {
    id: number
    pathwayId: number
    pipeline: $Enums.PathwayPipelines
    note: string | null
    _count: PathwayPipelineCountAggregateOutputType | null
    _avg: PathwayPipelineAvgAggregateOutputType | null
    _sum: PathwayPipelineSumAggregateOutputType | null
    _min: PathwayPipelineMinAggregateOutputType | null
    _max: PathwayPipelineMaxAggregateOutputType | null
  }

  type GetPathwayPipelineGroupByPayload<T extends PathwayPipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayPipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayPipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayPipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayPipelineGroupByOutputType[P]>
        }
      >
    >


  export type PathwayPipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    pipeline?: boolean
    note?: boolean
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayPipeline"]>

  export type PathwayPipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    pipeline?: boolean
    note?: boolean
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayPipeline"]>

  export type PathwayPipelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    pipeline?: boolean
    note?: boolean
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayPipeline"]>

  export type PathwayPipelineSelectScalar = {
    id?: boolean
    pathwayId?: boolean
    pipeline?: boolean
    note?: boolean
  }

  export type PathwayPipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pathwayId" | "pipeline" | "note", ExtArgs["result"]["pathwayPipeline"]>
  export type PathwayPipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayPipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayPipelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }

  export type $PathwayPipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PathwayPipeline"
    objects: {
      pathway: Prisma.$PathwayPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pathwayId: number
      pipeline: $Enums.PathwayPipelines
      note: string | null
    }, ExtArgs["result"]["pathwayPipeline"]>
    composites: {}
  }

  type PathwayPipelineGetPayload<S extends boolean | null | undefined | PathwayPipelineDefaultArgs> = $Result.GetResult<Prisma.$PathwayPipelinePayload, S>

  type PathwayPipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayPipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayPipelineCountAggregateInputType | true
    }

  export interface PathwayPipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PathwayPipeline'], meta: { name: 'PathwayPipeline' } }
    /**
     * Find zero or one PathwayPipeline that matches the filter.
     * @param {PathwayPipelineFindUniqueArgs} args - Arguments to find a PathwayPipeline
     * @example
     * // Get one PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayPipelineFindUniqueArgs>(args: SelectSubset<T, PathwayPipelineFindUniqueArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PathwayPipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayPipelineFindUniqueOrThrowArgs} args - Arguments to find a PathwayPipeline
     * @example
     * // Get one PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayPipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayPipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayPipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineFindFirstArgs} args - Arguments to find a PathwayPipeline
     * @example
     * // Get one PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayPipelineFindFirstArgs>(args?: SelectSubset<T, PathwayPipelineFindFirstArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayPipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineFindFirstOrThrowArgs} args - Arguments to find a PathwayPipeline
     * @example
     * // Get one PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayPipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayPipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PathwayPipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PathwayPipelines
     * const pathwayPipelines = await prisma.pathwayPipeline.findMany()
     * 
     * // Get first 10 PathwayPipelines
     * const pathwayPipelines = await prisma.pathwayPipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathwayPipelineWithIdOnly = await prisma.pathwayPipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathwayPipelineFindManyArgs>(args?: SelectSubset<T, PathwayPipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PathwayPipeline.
     * @param {PathwayPipelineCreateArgs} args - Arguments to create a PathwayPipeline.
     * @example
     * // Create one PathwayPipeline
     * const PathwayPipeline = await prisma.pathwayPipeline.create({
     *   data: {
     *     // ... data to create a PathwayPipeline
     *   }
     * })
     * 
     */
    create<T extends PathwayPipelineCreateArgs>(args: SelectSubset<T, PathwayPipelineCreateArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PathwayPipelines.
     * @param {PathwayPipelineCreateManyArgs} args - Arguments to create many PathwayPipelines.
     * @example
     * // Create many PathwayPipelines
     * const pathwayPipeline = await prisma.pathwayPipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayPipelineCreateManyArgs>(args?: SelectSubset<T, PathwayPipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PathwayPipelines and returns the data saved in the database.
     * @param {PathwayPipelineCreateManyAndReturnArgs} args - Arguments to create many PathwayPipelines.
     * @example
     * // Create many PathwayPipelines
     * const pathwayPipeline = await prisma.pathwayPipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PathwayPipelines and only return the `id`
     * const pathwayPipelineWithIdOnly = await prisma.pathwayPipeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayPipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayPipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PathwayPipeline.
     * @param {PathwayPipelineDeleteArgs} args - Arguments to delete one PathwayPipeline.
     * @example
     * // Delete one PathwayPipeline
     * const PathwayPipeline = await prisma.pathwayPipeline.delete({
     *   where: {
     *     // ... filter to delete one PathwayPipeline
     *   }
     * })
     * 
     */
    delete<T extends PathwayPipelineDeleteArgs>(args: SelectSubset<T, PathwayPipelineDeleteArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PathwayPipeline.
     * @param {PathwayPipelineUpdateArgs} args - Arguments to update one PathwayPipeline.
     * @example
     * // Update one PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayPipelineUpdateArgs>(args: SelectSubset<T, PathwayPipelineUpdateArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PathwayPipelines.
     * @param {PathwayPipelineDeleteManyArgs} args - Arguments to filter PathwayPipelines to delete.
     * @example
     * // Delete a few PathwayPipelines
     * const { count } = await prisma.pathwayPipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayPipelineDeleteManyArgs>(args?: SelectSubset<T, PathwayPipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayPipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PathwayPipelines
     * const pathwayPipeline = await prisma.pathwayPipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayPipelineUpdateManyArgs>(args: SelectSubset<T, PathwayPipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayPipelines and returns the data updated in the database.
     * @param {PathwayPipelineUpdateManyAndReturnArgs} args - Arguments to update many PathwayPipelines.
     * @example
     * // Update many PathwayPipelines
     * const pathwayPipeline = await prisma.pathwayPipeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PathwayPipelines and only return the `id`
     * const pathwayPipelineWithIdOnly = await prisma.pathwayPipeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayPipelineUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayPipelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PathwayPipeline.
     * @param {PathwayPipelineUpsertArgs} args - Arguments to update or create a PathwayPipeline.
     * @example
     * // Update or create a PathwayPipeline
     * const pathwayPipeline = await prisma.pathwayPipeline.upsert({
     *   create: {
     *     // ... data to create a PathwayPipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PathwayPipeline we want to update
     *   }
     * })
     */
    upsert<T extends PathwayPipelineUpsertArgs>(args: SelectSubset<T, PathwayPipelineUpsertArgs<ExtArgs>>): Prisma__PathwayPipelineClient<$Result.GetResult<Prisma.$PathwayPipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PathwayPipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineCountArgs} args - Arguments to filter PathwayPipelines to count.
     * @example
     * // Count the number of PathwayPipelines
     * const count = await prisma.pathwayPipeline.count({
     *   where: {
     *     // ... the filter for the PathwayPipelines we want to count
     *   }
     * })
    **/
    count<T extends PathwayPipelineCountArgs>(
      args?: Subset<T, PathwayPipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayPipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PathwayPipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayPipelineAggregateArgs>(args: Subset<T, PathwayPipelineAggregateArgs>): Prisma.PrismaPromise<GetPathwayPipelineAggregateType<T>>

    /**
     * Group by PathwayPipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayPipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayPipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayPipelineGroupByArgs['orderBy'] }
        : { orderBy?: PathwayPipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayPipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PathwayPipeline model
   */
  readonly fields: PathwayPipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PathwayPipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayPipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pathway<T extends PathwayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathwayDefaultArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PathwayPipeline model
   */
  interface PathwayPipelineFieldRefs {
    readonly id: FieldRef<"PathwayPipeline", 'Int'>
    readonly pathwayId: FieldRef<"PathwayPipeline", 'Int'>
    readonly pipeline: FieldRef<"PathwayPipeline", 'PathwayPipelines'>
    readonly note: FieldRef<"PathwayPipeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PathwayPipeline findUnique
   */
  export type PathwayPipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter, which PathwayPipeline to fetch.
     */
    where: PathwayPipelineWhereUniqueInput
  }

  /**
   * PathwayPipeline findUniqueOrThrow
   */
  export type PathwayPipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter, which PathwayPipeline to fetch.
     */
    where: PathwayPipelineWhereUniqueInput
  }

  /**
   * PathwayPipeline findFirst
   */
  export type PathwayPipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter, which PathwayPipeline to fetch.
     */
    where?: PathwayPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayPipelines to fetch.
     */
    orderBy?: PathwayPipelineOrderByWithRelationInput | PathwayPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayPipelines.
     */
    cursor?: PathwayPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayPipelines.
     */
    distinct?: PathwayPipelineScalarFieldEnum | PathwayPipelineScalarFieldEnum[]
  }

  /**
   * PathwayPipeline findFirstOrThrow
   */
  export type PathwayPipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter, which PathwayPipeline to fetch.
     */
    where?: PathwayPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayPipelines to fetch.
     */
    orderBy?: PathwayPipelineOrderByWithRelationInput | PathwayPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayPipelines.
     */
    cursor?: PathwayPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayPipelines.
     */
    distinct?: PathwayPipelineScalarFieldEnum | PathwayPipelineScalarFieldEnum[]
  }

  /**
   * PathwayPipeline findMany
   */
  export type PathwayPipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter, which PathwayPipelines to fetch.
     */
    where?: PathwayPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayPipelines to fetch.
     */
    orderBy?: PathwayPipelineOrderByWithRelationInput | PathwayPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PathwayPipelines.
     */
    cursor?: PathwayPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayPipelines.
     */
    skip?: number
    distinct?: PathwayPipelineScalarFieldEnum | PathwayPipelineScalarFieldEnum[]
  }

  /**
   * PathwayPipeline create
   */
  export type PathwayPipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a PathwayPipeline.
     */
    data: XOR<PathwayPipelineCreateInput, PathwayPipelineUncheckedCreateInput>
  }

  /**
   * PathwayPipeline createMany
   */
  export type PathwayPipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PathwayPipelines.
     */
    data: PathwayPipelineCreateManyInput | PathwayPipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PathwayPipeline createManyAndReturn
   */
  export type PathwayPipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * The data used to create many PathwayPipelines.
     */
    data: PathwayPipelineCreateManyInput | PathwayPipelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayPipeline update
   */
  export type PathwayPipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a PathwayPipeline.
     */
    data: XOR<PathwayPipelineUpdateInput, PathwayPipelineUncheckedUpdateInput>
    /**
     * Choose, which PathwayPipeline to update.
     */
    where: PathwayPipelineWhereUniqueInput
  }

  /**
   * PathwayPipeline updateMany
   */
  export type PathwayPipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PathwayPipelines.
     */
    data: XOR<PathwayPipelineUpdateManyMutationInput, PathwayPipelineUncheckedUpdateManyInput>
    /**
     * Filter which PathwayPipelines to update
     */
    where?: PathwayPipelineWhereInput
    /**
     * Limit how many PathwayPipelines to update.
     */
    limit?: number
  }

  /**
   * PathwayPipeline updateManyAndReturn
   */
  export type PathwayPipelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * The data used to update PathwayPipelines.
     */
    data: XOR<PathwayPipelineUpdateManyMutationInput, PathwayPipelineUncheckedUpdateManyInput>
    /**
     * Filter which PathwayPipelines to update
     */
    where?: PathwayPipelineWhereInput
    /**
     * Limit how many PathwayPipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayPipeline upsert
   */
  export type PathwayPipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the PathwayPipeline to update in case it exists.
     */
    where: PathwayPipelineWhereUniqueInput
    /**
     * In case the PathwayPipeline found by the `where` argument doesn't exist, create a new PathwayPipeline with this data.
     */
    create: XOR<PathwayPipelineCreateInput, PathwayPipelineUncheckedCreateInput>
    /**
     * In case the PathwayPipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayPipelineUpdateInput, PathwayPipelineUncheckedUpdateInput>
  }

  /**
   * PathwayPipeline delete
   */
  export type PathwayPipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
    /**
     * Filter which PathwayPipeline to delete.
     */
    where: PathwayPipelineWhereUniqueInput
  }

  /**
   * PathwayPipeline deleteMany
   */
  export type PathwayPipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayPipelines to delete
     */
    where?: PathwayPipelineWhereInput
    /**
     * Limit how many PathwayPipelines to delete.
     */
    limit?: number
  }

  /**
   * PathwayPipeline without action
   */
  export type PathwayPipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayPipeline
     */
    select?: PathwayPipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayPipeline
     */
    omit?: PathwayPipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayPipelineInclude<ExtArgs> | null
  }


  /**
   * Model PathwayRestrictedNationality
   */

  export type AggregatePathwayRestrictedNationality = {
    _count: PathwayRestrictedNationalityCountAggregateOutputType | null
    _avg: PathwayRestrictedNationalityAvgAggregateOutputType | null
    _sum: PathwayRestrictedNationalitySumAggregateOutputType | null
    _min: PathwayRestrictedNationalityMinAggregateOutputType | null
    _max: PathwayRestrictedNationalityMaxAggregateOutputType | null
  }

  export type PathwayRestrictedNationalityAvgAggregateOutputType = {
    pathwayId: number | null
  }

  export type PathwayRestrictedNationalitySumAggregateOutputType = {
    pathwayId: number | null
  }

  export type PathwayRestrictedNationalityMinAggregateOutputType = {
    pathwayId: number | null
    countryCode: string | null
    note: string | null
  }

  export type PathwayRestrictedNationalityMaxAggregateOutputType = {
    pathwayId: number | null
    countryCode: string | null
    note: string | null
  }

  export type PathwayRestrictedNationalityCountAggregateOutputType = {
    pathwayId: number
    countryCode: number
    note: number
    _all: number
  }


  export type PathwayRestrictedNationalityAvgAggregateInputType = {
    pathwayId?: true
  }

  export type PathwayRestrictedNationalitySumAggregateInputType = {
    pathwayId?: true
  }

  export type PathwayRestrictedNationalityMinAggregateInputType = {
    pathwayId?: true
    countryCode?: true
    note?: true
  }

  export type PathwayRestrictedNationalityMaxAggregateInputType = {
    pathwayId?: true
    countryCode?: true
    note?: true
  }

  export type PathwayRestrictedNationalityCountAggregateInputType = {
    pathwayId?: true
    countryCode?: true
    note?: true
    _all?: true
  }

  export type PathwayRestrictedNationalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayRestrictedNationality to aggregate.
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayRestrictedNationalities to fetch.
     */
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayRestrictedNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayRestrictedNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PathwayRestrictedNationalities
    **/
    _count?: true | PathwayRestrictedNationalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayRestrictedNationalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwayRestrictedNationalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayRestrictedNationalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayRestrictedNationalityMaxAggregateInputType
  }

  export type GetPathwayRestrictedNationalityAggregateType<T extends PathwayRestrictedNationalityAggregateArgs> = {
        [P in keyof T & keyof AggregatePathwayRestrictedNationality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathwayRestrictedNationality[P]>
      : GetScalarType<T[P], AggregatePathwayRestrictedNationality[P]>
  }




  export type PathwayRestrictedNationalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayRestrictedNationalityWhereInput
    orderBy?: PathwayRestrictedNationalityOrderByWithAggregationInput | PathwayRestrictedNationalityOrderByWithAggregationInput[]
    by: PathwayRestrictedNationalityScalarFieldEnum[] | PathwayRestrictedNationalityScalarFieldEnum
    having?: PathwayRestrictedNationalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayRestrictedNationalityCountAggregateInputType | true
    _avg?: PathwayRestrictedNationalityAvgAggregateInputType
    _sum?: PathwayRestrictedNationalitySumAggregateInputType
    _min?: PathwayRestrictedNationalityMinAggregateInputType
    _max?: PathwayRestrictedNationalityMaxAggregateInputType
  }

  export type PathwayRestrictedNationalityGroupByOutputType = {
    pathwayId: number
    countryCode: string
    note: string | null
    _count: PathwayRestrictedNationalityCountAggregateOutputType | null
    _avg: PathwayRestrictedNationalityAvgAggregateOutputType | null
    _sum: PathwayRestrictedNationalitySumAggregateOutputType | null
    _min: PathwayRestrictedNationalityMinAggregateOutputType | null
    _max: PathwayRestrictedNationalityMaxAggregateOutputType | null
  }

  type GetPathwayRestrictedNationalityGroupByPayload<T extends PathwayRestrictedNationalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayRestrictedNationalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayRestrictedNationalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayRestrictedNationalityGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayRestrictedNationalityGroupByOutputType[P]>
        }
      >
    >


  export type PathwayRestrictedNationalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    countryCode?: boolean
    note?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayRestrictedNationality"]>

  export type PathwayRestrictedNationalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    countryCode?: boolean
    note?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayRestrictedNationality"]>

  export type PathwayRestrictedNationalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    countryCode?: boolean
    note?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayRestrictedNationality"]>

  export type PathwayRestrictedNationalitySelectScalar = {
    pathwayId?: boolean
    countryCode?: boolean
    note?: boolean
  }

  export type PathwayRestrictedNationalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pathwayId" | "countryCode" | "note", ExtArgs["result"]["pathwayRestrictedNationality"]>
  export type PathwayRestrictedNationalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayRestrictedNationalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayRestrictedNationalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }

  export type $PathwayRestrictedNationalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PathwayRestrictedNationality"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      pathway: Prisma.$PathwayPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pathwayId: number
      countryCode: string
      note: string | null
    }, ExtArgs["result"]["pathwayRestrictedNationality"]>
    composites: {}
  }

  type PathwayRestrictedNationalityGetPayload<S extends boolean | null | undefined | PathwayRestrictedNationalityDefaultArgs> = $Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload, S>

  type PathwayRestrictedNationalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayRestrictedNationalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayRestrictedNationalityCountAggregateInputType | true
    }

  export interface PathwayRestrictedNationalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PathwayRestrictedNationality'], meta: { name: 'PathwayRestrictedNationality' } }
    /**
     * Find zero or one PathwayRestrictedNationality that matches the filter.
     * @param {PathwayRestrictedNationalityFindUniqueArgs} args - Arguments to find a PathwayRestrictedNationality
     * @example
     * // Get one PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayRestrictedNationalityFindUniqueArgs>(args: SelectSubset<T, PathwayRestrictedNationalityFindUniqueArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PathwayRestrictedNationality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayRestrictedNationalityFindUniqueOrThrowArgs} args - Arguments to find a PathwayRestrictedNationality
     * @example
     * // Get one PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayRestrictedNationalityFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayRestrictedNationalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayRestrictedNationality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityFindFirstArgs} args - Arguments to find a PathwayRestrictedNationality
     * @example
     * // Get one PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayRestrictedNationalityFindFirstArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityFindFirstArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayRestrictedNationality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityFindFirstOrThrowArgs} args - Arguments to find a PathwayRestrictedNationality
     * @example
     * // Get one PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayRestrictedNationalityFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PathwayRestrictedNationalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PathwayRestrictedNationalities
     * const pathwayRestrictedNationalities = await prisma.pathwayRestrictedNationality.findMany()
     * 
     * // Get first 10 PathwayRestrictedNationalities
     * const pathwayRestrictedNationalities = await prisma.pathwayRestrictedNationality.findMany({ take: 10 })
     * 
     * // Only select the `pathwayId`
     * const pathwayRestrictedNationalityWithPathwayIdOnly = await prisma.pathwayRestrictedNationality.findMany({ select: { pathwayId: true } })
     * 
     */
    findMany<T extends PathwayRestrictedNationalityFindManyArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PathwayRestrictedNationality.
     * @param {PathwayRestrictedNationalityCreateArgs} args - Arguments to create a PathwayRestrictedNationality.
     * @example
     * // Create one PathwayRestrictedNationality
     * const PathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.create({
     *   data: {
     *     // ... data to create a PathwayRestrictedNationality
     *   }
     * })
     * 
     */
    create<T extends PathwayRestrictedNationalityCreateArgs>(args: SelectSubset<T, PathwayRestrictedNationalityCreateArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PathwayRestrictedNationalities.
     * @param {PathwayRestrictedNationalityCreateManyArgs} args - Arguments to create many PathwayRestrictedNationalities.
     * @example
     * // Create many PathwayRestrictedNationalities
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayRestrictedNationalityCreateManyArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PathwayRestrictedNationalities and returns the data saved in the database.
     * @param {PathwayRestrictedNationalityCreateManyAndReturnArgs} args - Arguments to create many PathwayRestrictedNationalities.
     * @example
     * // Create many PathwayRestrictedNationalities
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PathwayRestrictedNationalities and only return the `pathwayId`
     * const pathwayRestrictedNationalityWithPathwayIdOnly = await prisma.pathwayRestrictedNationality.createManyAndReturn({
     *   select: { pathwayId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayRestrictedNationalityCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PathwayRestrictedNationality.
     * @param {PathwayRestrictedNationalityDeleteArgs} args - Arguments to delete one PathwayRestrictedNationality.
     * @example
     * // Delete one PathwayRestrictedNationality
     * const PathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.delete({
     *   where: {
     *     // ... filter to delete one PathwayRestrictedNationality
     *   }
     * })
     * 
     */
    delete<T extends PathwayRestrictedNationalityDeleteArgs>(args: SelectSubset<T, PathwayRestrictedNationalityDeleteArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PathwayRestrictedNationality.
     * @param {PathwayRestrictedNationalityUpdateArgs} args - Arguments to update one PathwayRestrictedNationality.
     * @example
     * // Update one PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayRestrictedNationalityUpdateArgs>(args: SelectSubset<T, PathwayRestrictedNationalityUpdateArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PathwayRestrictedNationalities.
     * @param {PathwayRestrictedNationalityDeleteManyArgs} args - Arguments to filter PathwayRestrictedNationalities to delete.
     * @example
     * // Delete a few PathwayRestrictedNationalities
     * const { count } = await prisma.pathwayRestrictedNationality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayRestrictedNationalityDeleteManyArgs>(args?: SelectSubset<T, PathwayRestrictedNationalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayRestrictedNationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PathwayRestrictedNationalities
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayRestrictedNationalityUpdateManyArgs>(args: SelectSubset<T, PathwayRestrictedNationalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayRestrictedNationalities and returns the data updated in the database.
     * @param {PathwayRestrictedNationalityUpdateManyAndReturnArgs} args - Arguments to update many PathwayRestrictedNationalities.
     * @example
     * // Update many PathwayRestrictedNationalities
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PathwayRestrictedNationalities and only return the `pathwayId`
     * const pathwayRestrictedNationalityWithPathwayIdOnly = await prisma.pathwayRestrictedNationality.updateManyAndReturn({
     *   select: { pathwayId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayRestrictedNationalityUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayRestrictedNationalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PathwayRestrictedNationality.
     * @param {PathwayRestrictedNationalityUpsertArgs} args - Arguments to update or create a PathwayRestrictedNationality.
     * @example
     * // Update or create a PathwayRestrictedNationality
     * const pathwayRestrictedNationality = await prisma.pathwayRestrictedNationality.upsert({
     *   create: {
     *     // ... data to create a PathwayRestrictedNationality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PathwayRestrictedNationality we want to update
     *   }
     * })
     */
    upsert<T extends PathwayRestrictedNationalityUpsertArgs>(args: SelectSubset<T, PathwayRestrictedNationalityUpsertArgs<ExtArgs>>): Prisma__PathwayRestrictedNationalityClient<$Result.GetResult<Prisma.$PathwayRestrictedNationalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PathwayRestrictedNationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityCountArgs} args - Arguments to filter PathwayRestrictedNationalities to count.
     * @example
     * // Count the number of PathwayRestrictedNationalities
     * const count = await prisma.pathwayRestrictedNationality.count({
     *   where: {
     *     // ... the filter for the PathwayRestrictedNationalities we want to count
     *   }
     * })
    **/
    count<T extends PathwayRestrictedNationalityCountArgs>(
      args?: Subset<T, PathwayRestrictedNationalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayRestrictedNationalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PathwayRestrictedNationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayRestrictedNationalityAggregateArgs>(args: Subset<T, PathwayRestrictedNationalityAggregateArgs>): Prisma.PrismaPromise<GetPathwayRestrictedNationalityAggregateType<T>>

    /**
     * Group by PathwayRestrictedNationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayRestrictedNationalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayRestrictedNationalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayRestrictedNationalityGroupByArgs['orderBy'] }
        : { orderBy?: PathwayRestrictedNationalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayRestrictedNationalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayRestrictedNationalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PathwayRestrictedNationality model
   */
  readonly fields: PathwayRestrictedNationalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PathwayRestrictedNationality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayRestrictedNationalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pathway<T extends PathwayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathwayDefaultArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PathwayRestrictedNationality model
   */
  interface PathwayRestrictedNationalityFieldRefs {
    readonly pathwayId: FieldRef<"PathwayRestrictedNationality", 'Int'>
    readonly countryCode: FieldRef<"PathwayRestrictedNationality", 'String'>
    readonly note: FieldRef<"PathwayRestrictedNationality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PathwayRestrictedNationality findUnique
   */
  export type PathwayRestrictedNationalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter, which PathwayRestrictedNationality to fetch.
     */
    where: PathwayRestrictedNationalityWhereUniqueInput
  }

  /**
   * PathwayRestrictedNationality findUniqueOrThrow
   */
  export type PathwayRestrictedNationalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter, which PathwayRestrictedNationality to fetch.
     */
    where: PathwayRestrictedNationalityWhereUniqueInput
  }

  /**
   * PathwayRestrictedNationality findFirst
   */
  export type PathwayRestrictedNationalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter, which PathwayRestrictedNationality to fetch.
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayRestrictedNationalities to fetch.
     */
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayRestrictedNationalities.
     */
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayRestrictedNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayRestrictedNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayRestrictedNationalities.
     */
    distinct?: PathwayRestrictedNationalityScalarFieldEnum | PathwayRestrictedNationalityScalarFieldEnum[]
  }

  /**
   * PathwayRestrictedNationality findFirstOrThrow
   */
  export type PathwayRestrictedNationalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter, which PathwayRestrictedNationality to fetch.
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayRestrictedNationalities to fetch.
     */
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayRestrictedNationalities.
     */
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayRestrictedNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayRestrictedNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayRestrictedNationalities.
     */
    distinct?: PathwayRestrictedNationalityScalarFieldEnum | PathwayRestrictedNationalityScalarFieldEnum[]
  }

  /**
   * PathwayRestrictedNationality findMany
   */
  export type PathwayRestrictedNationalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter, which PathwayRestrictedNationalities to fetch.
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayRestrictedNationalities to fetch.
     */
    orderBy?: PathwayRestrictedNationalityOrderByWithRelationInput | PathwayRestrictedNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PathwayRestrictedNationalities.
     */
    cursor?: PathwayRestrictedNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayRestrictedNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayRestrictedNationalities.
     */
    skip?: number
    distinct?: PathwayRestrictedNationalityScalarFieldEnum | PathwayRestrictedNationalityScalarFieldEnum[]
  }

  /**
   * PathwayRestrictedNationality create
   */
  export type PathwayRestrictedNationalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * The data needed to create a PathwayRestrictedNationality.
     */
    data: XOR<PathwayRestrictedNationalityCreateInput, PathwayRestrictedNationalityUncheckedCreateInput>
  }

  /**
   * PathwayRestrictedNationality createMany
   */
  export type PathwayRestrictedNationalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PathwayRestrictedNationalities.
     */
    data: PathwayRestrictedNationalityCreateManyInput | PathwayRestrictedNationalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PathwayRestrictedNationality createManyAndReturn
   */
  export type PathwayRestrictedNationalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * The data used to create many PathwayRestrictedNationalities.
     */
    data: PathwayRestrictedNationalityCreateManyInput | PathwayRestrictedNationalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayRestrictedNationality update
   */
  export type PathwayRestrictedNationalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * The data needed to update a PathwayRestrictedNationality.
     */
    data: XOR<PathwayRestrictedNationalityUpdateInput, PathwayRestrictedNationalityUncheckedUpdateInput>
    /**
     * Choose, which PathwayRestrictedNationality to update.
     */
    where: PathwayRestrictedNationalityWhereUniqueInput
  }

  /**
   * PathwayRestrictedNationality updateMany
   */
  export type PathwayRestrictedNationalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PathwayRestrictedNationalities.
     */
    data: XOR<PathwayRestrictedNationalityUpdateManyMutationInput, PathwayRestrictedNationalityUncheckedUpdateManyInput>
    /**
     * Filter which PathwayRestrictedNationalities to update
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * Limit how many PathwayRestrictedNationalities to update.
     */
    limit?: number
  }

  /**
   * PathwayRestrictedNationality updateManyAndReturn
   */
  export type PathwayRestrictedNationalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * The data used to update PathwayRestrictedNationalities.
     */
    data: XOR<PathwayRestrictedNationalityUpdateManyMutationInput, PathwayRestrictedNationalityUncheckedUpdateManyInput>
    /**
     * Filter which PathwayRestrictedNationalities to update
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * Limit how many PathwayRestrictedNationalities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayRestrictedNationality upsert
   */
  export type PathwayRestrictedNationalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * The filter to search for the PathwayRestrictedNationality to update in case it exists.
     */
    where: PathwayRestrictedNationalityWhereUniqueInput
    /**
     * In case the PathwayRestrictedNationality found by the `where` argument doesn't exist, create a new PathwayRestrictedNationality with this data.
     */
    create: XOR<PathwayRestrictedNationalityCreateInput, PathwayRestrictedNationalityUncheckedCreateInput>
    /**
     * In case the PathwayRestrictedNationality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayRestrictedNationalityUpdateInput, PathwayRestrictedNationalityUncheckedUpdateInput>
  }

  /**
   * PathwayRestrictedNationality delete
   */
  export type PathwayRestrictedNationalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
    /**
     * Filter which PathwayRestrictedNationality to delete.
     */
    where: PathwayRestrictedNationalityWhereUniqueInput
  }

  /**
   * PathwayRestrictedNationality deleteMany
   */
  export type PathwayRestrictedNationalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayRestrictedNationalities to delete
     */
    where?: PathwayRestrictedNationalityWhereInput
    /**
     * Limit how many PathwayRestrictedNationalities to delete.
     */
    limit?: number
  }

  /**
   * PathwayRestrictedNationality without action
   */
  export type PathwayRestrictedNationalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayRestrictedNationality
     */
    select?: PathwayRestrictedNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayRestrictedNationality
     */
    omit?: PathwayRestrictedNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayRestrictedNationalityInclude<ExtArgs> | null
  }


  /**
   * Model PathwayDocuments
   */

  export type AggregatePathwayDocuments = {
    _count: PathwayDocumentsCountAggregateOutputType | null
    _avg: PathwayDocumentsAvgAggregateOutputType | null
    _sum: PathwayDocumentsSumAggregateOutputType | null
    _min: PathwayDocumentsMinAggregateOutputType | null
    _max: PathwayDocumentsMaxAggregateOutputType | null
  }

  export type PathwayDocumentsAvgAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    documentId: number | null
    cost: Decimal | null
  }

  export type PathwayDocumentsSumAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    documentId: number | null
    cost: Decimal | null
  }

  export type PathwayDocumentsMinAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    documentId: number | null
    description: string | null
    cost: Decimal | null
    isRequired: boolean | null
    link: string | null
    title: string | null
  }

  export type PathwayDocumentsMaxAggregateOutputType = {
    id: number | null
    pathwayId: number | null
    documentId: number | null
    description: string | null
    cost: Decimal | null
    isRequired: boolean | null
    link: string | null
    title: string | null
  }

  export type PathwayDocumentsCountAggregateOutputType = {
    id: number
    pathwayId: number
    documentId: number
    description: number
    cost: number
    isRequired: number
    link: number
    title: number
    _all: number
  }


  export type PathwayDocumentsAvgAggregateInputType = {
    id?: true
    pathwayId?: true
    documentId?: true
    cost?: true
  }

  export type PathwayDocumentsSumAggregateInputType = {
    id?: true
    pathwayId?: true
    documentId?: true
    cost?: true
  }

  export type PathwayDocumentsMinAggregateInputType = {
    id?: true
    pathwayId?: true
    documentId?: true
    description?: true
    cost?: true
    isRequired?: true
    link?: true
    title?: true
  }

  export type PathwayDocumentsMaxAggregateInputType = {
    id?: true
    pathwayId?: true
    documentId?: true
    description?: true
    cost?: true
    isRequired?: true
    link?: true
    title?: true
  }

  export type PathwayDocumentsCountAggregateInputType = {
    id?: true
    pathwayId?: true
    documentId?: true
    description?: true
    cost?: true
    isRequired?: true
    link?: true
    title?: true
    _all?: true
  }

  export type PathwayDocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayDocuments to aggregate.
     */
    where?: PathwayDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayDocuments to fetch.
     */
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PathwayDocuments
    **/
    _count?: true | PathwayDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayDocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwayDocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayDocumentsMaxAggregateInputType
  }

  export type GetPathwayDocumentsAggregateType<T extends PathwayDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePathwayDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathwayDocuments[P]>
      : GetScalarType<T[P], AggregatePathwayDocuments[P]>
  }




  export type PathwayDocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayDocumentsWhereInput
    orderBy?: PathwayDocumentsOrderByWithAggregationInput | PathwayDocumentsOrderByWithAggregationInput[]
    by: PathwayDocumentsScalarFieldEnum[] | PathwayDocumentsScalarFieldEnum
    having?: PathwayDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayDocumentsCountAggregateInputType | true
    _avg?: PathwayDocumentsAvgAggregateInputType
    _sum?: PathwayDocumentsSumAggregateInputType
    _min?: PathwayDocumentsMinAggregateInputType
    _max?: PathwayDocumentsMaxAggregateInputType
  }

  export type PathwayDocumentsGroupByOutputType = {
    id: number
    pathwayId: number
    documentId: number
    description: string | null
    cost: Decimal
    isRequired: boolean
    link: string | null
    title: string | null
    _count: PathwayDocumentsCountAggregateOutputType | null
    _avg: PathwayDocumentsAvgAggregateOutputType | null
    _sum: PathwayDocumentsSumAggregateOutputType | null
    _min: PathwayDocumentsMinAggregateOutputType | null
    _max: PathwayDocumentsMaxAggregateOutputType | null
  }

  type GetPathwayDocumentsGroupByPayload<T extends PathwayDocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type PathwayDocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    documentId?: boolean
    description?: boolean
    cost?: boolean
    isRequired?: boolean
    link?: boolean
    title?: boolean
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayDocuments"]>

  export type PathwayDocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    documentId?: boolean
    description?: boolean
    cost?: boolean
    isRequired?: boolean
    link?: boolean
    title?: boolean
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayDocuments"]>

  export type PathwayDocumentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathwayId?: boolean
    documentId?: boolean
    description?: boolean
    cost?: boolean
    isRequired?: boolean
    link?: boolean
    title?: boolean
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayDocuments"]>

  export type PathwayDocumentsSelectScalar = {
    id?: boolean
    pathwayId?: boolean
    documentId?: boolean
    description?: boolean
    cost?: boolean
    isRequired?: boolean
    link?: boolean
    title?: boolean
  }

  export type PathwayDocumentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pathwayId" | "documentId" | "description" | "cost" | "isRequired" | "link" | "title", ExtArgs["result"]["pathwayDocuments"]>
  export type PathwayDocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayDocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }
  export type PathwayDocumentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentsDefaultArgs<ExtArgs>
    pathway?: boolean | PathwayDefaultArgs<ExtArgs>
  }

  export type $PathwayDocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PathwayDocuments"
    objects: {
      document: Prisma.$DocumentsPayload<ExtArgs>
      pathway: Prisma.$PathwayPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pathwayId: number
      documentId: number
      description: string | null
      cost: Prisma.Decimal
      isRequired: boolean
      link: string | null
      title: string | null
    }, ExtArgs["result"]["pathwayDocuments"]>
    composites: {}
  }

  type PathwayDocumentsGetPayload<S extends boolean | null | undefined | PathwayDocumentsDefaultArgs> = $Result.GetResult<Prisma.$PathwayDocumentsPayload, S>

  type PathwayDocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayDocumentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayDocumentsCountAggregateInputType | true
    }

  export interface PathwayDocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PathwayDocuments'], meta: { name: 'PathwayDocuments' } }
    /**
     * Find zero or one PathwayDocuments that matches the filter.
     * @param {PathwayDocumentsFindUniqueArgs} args - Arguments to find a PathwayDocuments
     * @example
     * // Get one PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayDocumentsFindUniqueArgs>(args: SelectSubset<T, PathwayDocumentsFindUniqueArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PathwayDocuments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayDocumentsFindUniqueOrThrowArgs} args - Arguments to find a PathwayDocuments
     * @example
     * // Get one PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayDocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayDocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsFindFirstArgs} args - Arguments to find a PathwayDocuments
     * @example
     * // Get one PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayDocumentsFindFirstArgs>(args?: SelectSubset<T, PathwayDocumentsFindFirstArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayDocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsFindFirstOrThrowArgs} args - Arguments to find a PathwayDocuments
     * @example
     * // Get one PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayDocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayDocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PathwayDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findMany()
     * 
     * // Get first 10 PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathwayDocumentsWithIdOnly = await prisma.pathwayDocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathwayDocumentsFindManyArgs>(args?: SelectSubset<T, PathwayDocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PathwayDocuments.
     * @param {PathwayDocumentsCreateArgs} args - Arguments to create a PathwayDocuments.
     * @example
     * // Create one PathwayDocuments
     * const PathwayDocuments = await prisma.pathwayDocuments.create({
     *   data: {
     *     // ... data to create a PathwayDocuments
     *   }
     * })
     * 
     */
    create<T extends PathwayDocumentsCreateArgs>(args: SelectSubset<T, PathwayDocumentsCreateArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PathwayDocuments.
     * @param {PathwayDocumentsCreateManyArgs} args - Arguments to create many PathwayDocuments.
     * @example
     * // Create many PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayDocumentsCreateManyArgs>(args?: SelectSubset<T, PathwayDocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PathwayDocuments and returns the data saved in the database.
     * @param {PathwayDocumentsCreateManyAndReturnArgs} args - Arguments to create many PathwayDocuments.
     * @example
     * // Create many PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PathwayDocuments and only return the `id`
     * const pathwayDocumentsWithIdOnly = await prisma.pathwayDocuments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayDocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayDocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PathwayDocuments.
     * @param {PathwayDocumentsDeleteArgs} args - Arguments to delete one PathwayDocuments.
     * @example
     * // Delete one PathwayDocuments
     * const PathwayDocuments = await prisma.pathwayDocuments.delete({
     *   where: {
     *     // ... filter to delete one PathwayDocuments
     *   }
     * })
     * 
     */
    delete<T extends PathwayDocumentsDeleteArgs>(args: SelectSubset<T, PathwayDocumentsDeleteArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PathwayDocuments.
     * @param {PathwayDocumentsUpdateArgs} args - Arguments to update one PathwayDocuments.
     * @example
     * // Update one PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayDocumentsUpdateArgs>(args: SelectSubset<T, PathwayDocumentsUpdateArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PathwayDocuments.
     * @param {PathwayDocumentsDeleteManyArgs} args - Arguments to filter PathwayDocuments to delete.
     * @example
     * // Delete a few PathwayDocuments
     * const { count } = await prisma.pathwayDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayDocumentsDeleteManyArgs>(args?: SelectSubset<T, PathwayDocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayDocumentsUpdateManyArgs>(args: SelectSubset<T, PathwayDocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayDocuments and returns the data updated in the database.
     * @param {PathwayDocumentsUpdateManyAndReturnArgs} args - Arguments to update many PathwayDocuments.
     * @example
     * // Update many PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PathwayDocuments and only return the `id`
     * const pathwayDocumentsWithIdOnly = await prisma.pathwayDocuments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayDocumentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayDocumentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PathwayDocuments.
     * @param {PathwayDocumentsUpsertArgs} args - Arguments to update or create a PathwayDocuments.
     * @example
     * // Update or create a PathwayDocuments
     * const pathwayDocuments = await prisma.pathwayDocuments.upsert({
     *   create: {
     *     // ... data to create a PathwayDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PathwayDocuments we want to update
     *   }
     * })
     */
    upsert<T extends PathwayDocumentsUpsertArgs>(args: SelectSubset<T, PathwayDocumentsUpsertArgs<ExtArgs>>): Prisma__PathwayDocumentsClient<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PathwayDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsCountArgs} args - Arguments to filter PathwayDocuments to count.
     * @example
     * // Count the number of PathwayDocuments
     * const count = await prisma.pathwayDocuments.count({
     *   where: {
     *     // ... the filter for the PathwayDocuments we want to count
     *   }
     * })
    **/
    count<T extends PathwayDocumentsCountArgs>(
      args?: Subset<T, PathwayDocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PathwayDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayDocumentsAggregateArgs>(args: Subset<T, PathwayDocumentsAggregateArgs>): Prisma.PrismaPromise<GetPathwayDocumentsAggregateType<T>>

    /**
     * Group by PathwayDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: PathwayDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PathwayDocuments model
   */
  readonly fields: PathwayDocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PathwayDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayDocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentsDefaultArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pathway<T extends PathwayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathwayDefaultArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PathwayDocuments model
   */
  interface PathwayDocumentsFieldRefs {
    readonly id: FieldRef<"PathwayDocuments", 'Int'>
    readonly pathwayId: FieldRef<"PathwayDocuments", 'Int'>
    readonly documentId: FieldRef<"PathwayDocuments", 'Int'>
    readonly description: FieldRef<"PathwayDocuments", 'String'>
    readonly cost: FieldRef<"PathwayDocuments", 'Decimal'>
    readonly isRequired: FieldRef<"PathwayDocuments", 'Boolean'>
    readonly link: FieldRef<"PathwayDocuments", 'String'>
    readonly title: FieldRef<"PathwayDocuments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PathwayDocuments findUnique
   */
  export type PathwayDocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which PathwayDocuments to fetch.
     */
    where: PathwayDocumentsWhereUniqueInput
  }

  /**
   * PathwayDocuments findUniqueOrThrow
   */
  export type PathwayDocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which PathwayDocuments to fetch.
     */
    where: PathwayDocumentsWhereUniqueInput
  }

  /**
   * PathwayDocuments findFirst
   */
  export type PathwayDocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which PathwayDocuments to fetch.
     */
    where?: PathwayDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayDocuments to fetch.
     */
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayDocuments.
     */
    cursor?: PathwayDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayDocuments.
     */
    distinct?: PathwayDocumentsScalarFieldEnum | PathwayDocumentsScalarFieldEnum[]
  }

  /**
   * PathwayDocuments findFirstOrThrow
   */
  export type PathwayDocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which PathwayDocuments to fetch.
     */
    where?: PathwayDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayDocuments to fetch.
     */
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayDocuments.
     */
    cursor?: PathwayDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayDocuments.
     */
    distinct?: PathwayDocumentsScalarFieldEnum | PathwayDocumentsScalarFieldEnum[]
  }

  /**
   * PathwayDocuments findMany
   */
  export type PathwayDocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which PathwayDocuments to fetch.
     */
    where?: PathwayDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayDocuments to fetch.
     */
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PathwayDocuments.
     */
    cursor?: PathwayDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayDocuments.
     */
    skip?: number
    distinct?: PathwayDocumentsScalarFieldEnum | PathwayDocumentsScalarFieldEnum[]
  }

  /**
   * PathwayDocuments create
   */
  export type PathwayDocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a PathwayDocuments.
     */
    data: XOR<PathwayDocumentsCreateInput, PathwayDocumentsUncheckedCreateInput>
  }

  /**
   * PathwayDocuments createMany
   */
  export type PathwayDocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PathwayDocuments.
     */
    data: PathwayDocumentsCreateManyInput | PathwayDocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PathwayDocuments createManyAndReturn
   */
  export type PathwayDocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * The data used to create many PathwayDocuments.
     */
    data: PathwayDocumentsCreateManyInput | PathwayDocumentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayDocuments update
   */
  export type PathwayDocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a PathwayDocuments.
     */
    data: XOR<PathwayDocumentsUpdateInput, PathwayDocumentsUncheckedUpdateInput>
    /**
     * Choose, which PathwayDocuments to update.
     */
    where: PathwayDocumentsWhereUniqueInput
  }

  /**
   * PathwayDocuments updateMany
   */
  export type PathwayDocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PathwayDocuments.
     */
    data: XOR<PathwayDocumentsUpdateManyMutationInput, PathwayDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which PathwayDocuments to update
     */
    where?: PathwayDocumentsWhereInput
    /**
     * Limit how many PathwayDocuments to update.
     */
    limit?: number
  }

  /**
   * PathwayDocuments updateManyAndReturn
   */
  export type PathwayDocumentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * The data used to update PathwayDocuments.
     */
    data: XOR<PathwayDocumentsUpdateManyMutationInput, PathwayDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which PathwayDocuments to update
     */
    where?: PathwayDocumentsWhereInput
    /**
     * Limit how many PathwayDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayDocuments upsert
   */
  export type PathwayDocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the PathwayDocuments to update in case it exists.
     */
    where: PathwayDocumentsWhereUniqueInput
    /**
     * In case the PathwayDocuments found by the `where` argument doesn't exist, create a new PathwayDocuments with this data.
     */
    create: XOR<PathwayDocumentsCreateInput, PathwayDocumentsUncheckedCreateInput>
    /**
     * In case the PathwayDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayDocumentsUpdateInput, PathwayDocumentsUncheckedUpdateInput>
  }

  /**
   * PathwayDocuments delete
   */
  export type PathwayDocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    /**
     * Filter which PathwayDocuments to delete.
     */
    where: PathwayDocumentsWhereUniqueInput
  }

  /**
   * PathwayDocuments deleteMany
   */
  export type PathwayDocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayDocuments to delete
     */
    where?: PathwayDocumentsWhereInput
    /**
     * Limit how many PathwayDocuments to delete.
     */
    limit?: number
  }

  /**
   * PathwayDocuments without action
   */
  export type PathwayDocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyMinAggregateOutputType = {
    code: string | null
    name: string | null
    symbol: string | null
  }

  export type CurrencyMaxAggregateOutputType = {
    code: string | null
    name: string | null
    symbol: string | null
  }

  export type CurrencyCountAggregateOutputType = {
    code: number
    name: number
    symbol: number
    _all: number
  }


  export type CurrencyMinAggregateInputType = {
    code?: true
    name?: true
    symbol?: true
  }

  export type CurrencyMaxAggregateInputType = {
    code?: true
    name?: true
    symbol?: true
  }

  export type CurrencyCountAggregateInputType = {
    code?: true
    name?: true
    symbol?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    code: string
    name: string
    symbol: string
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    symbol?: boolean
    countryCurrencies?: boolean | Currency$countryCurrenciesArgs<ExtArgs>
    pathways?: boolean | Currency$pathwaysArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    symbol?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    symbol?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    code?: boolean
    name?: boolean
    symbol?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "symbol", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryCurrencies?: boolean | Currency$countryCurrenciesArgs<ExtArgs>
    pathways?: boolean | Currency$pathwaysArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      countryCurrencies: Prisma.$CountryCurrencyPayload<ExtArgs>[]
      pathways: Prisma.$PathwayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      symbol: string
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const currencyWithCodeOnly = await prisma.currency.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `code`
     * const currencyWithCodeOnly = await prisma.currency.createManyAndReturn({
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `code`
     * const currencyWithCodeOnly = await prisma.currency.updateManyAndReturn({
     *   select: { code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    countryCurrencies<T extends Currency$countryCurrenciesArgs<ExtArgs> = {}>(args?: Subset<T, Currency$countryCurrenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathways<T extends Currency$pathwaysArgs<ExtArgs> = {}>(args?: Subset<T, Currency$pathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly code: FieldRef<"Currency", 'String'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.countryCurrencies
   */
  export type Currency$countryCurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCurrency
     */
    select?: CountryCurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCurrency
     */
    omit?: CountryCurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryCurrencyInclude<ExtArgs> | null
    where?: CountryCurrencyWhereInput
    orderBy?: CountryCurrencyOrderByWithRelationInput | CountryCurrencyOrderByWithRelationInput[]
    cursor?: CountryCurrencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountryCurrencyScalarFieldEnum | CountryCurrencyScalarFieldEnum[]
  }

  /**
   * Currency.pathways
   */
  export type Currency$pathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model Documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    id: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    id: number | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    id?: true
  }

  export type DocumentsSumAggregateInputType = {
    id?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to aggregate.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type DocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentsWhereInput
    orderBy?: DocumentsOrderByWithAggregationInput | DocumentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: DocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    type: $Enums.DocumentType[]
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends DocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type DocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pathwayDocuments?: boolean | Documents$pathwayDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type DocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
  }, ExtArgs["result"]["documents"]>

  export type DocumentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
  }, ExtArgs["result"]["documents"]>

  export type DocumentsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
  }

  export type DocumentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type", ExtArgs["result"]["documents"]>
  export type DocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathwayDocuments?: boolean | Documents$pathwayDocumentsArgs<ExtArgs>
    _count?: boolean | DocumentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documents"
    objects: {
      pathwayDocuments: Prisma.$PathwayDocumentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      type: $Enums.DocumentType[]
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type DocumentsGetPayload<S extends boolean | null | undefined | DocumentsDefaultArgs> = $Result.GetResult<Prisma.$DocumentsPayload, S>

  type DocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface DocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documents'], meta: { name: 'Documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {DocumentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentsFindUniqueArgs>(args: SelectSubset<T, DocumentsFindUniqueArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentsFindFirstArgs>(args?: SelectSubset<T, DocumentsFindFirstArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentsFindManyArgs>(args?: SelectSubset<T, DocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documents.
     * @param {DocumentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends DocumentsCreateArgs>(args: SelectSubset<T, DocumentsCreateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentsCreateManyArgs>(args?: SelectSubset<T, DocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentsCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documents.
     * @param {DocumentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends DocumentsDeleteArgs>(args: SelectSubset<T, DocumentsDeleteArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documents.
     * @param {DocumentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentsUpdateArgs>(args: SelectSubset<T, DocumentsUpdateArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentsDeleteManyArgs>(args?: SelectSubset<T, DocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentsUpdateManyArgs>(args: SelectSubset<T, DocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentsUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentsUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documents.
     * @param {DocumentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends DocumentsUpsertArgs>(args: SelectSubset<T, DocumentsUpsertArgs<ExtArgs>>): Prisma__DocumentsClient<$Result.GetResult<Prisma.$DocumentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentsCountArgs>(
      args?: Subset<T, DocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentsGroupByArgs['orderBy'] }
        : { orderBy?: DocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documents model
   */
  readonly fields: DocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pathwayDocuments<T extends Documents$pathwayDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Documents$pathwayDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documents model
   */
  interface DocumentsFieldRefs {
    readonly id: FieldRef<"Documents", 'Int'>
    readonly name: FieldRef<"Documents", 'String'>
    readonly description: FieldRef<"Documents", 'String'>
    readonly type: FieldRef<"Documents", 'DocumentType[]'>
  }
    

  // Custom InputTypes
  /**
   * Documents findUnique
   */
  export type DocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findUniqueOrThrow
   */
  export type DocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents findFirst
   */
  export type DocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findFirstOrThrow
   */
  export type DocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents findMany
   */
  export type DocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentsOrderByWithRelationInput | DocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * Documents create
   */
  export type DocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Documents.
     */
    data: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
  }

  /**
   * Documents createMany
   */
  export type DocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentsCreateManyInput | DocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documents createManyAndReturn
   */
  export type DocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentsCreateManyInput | DocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documents update
   */
  export type DocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Documents.
     */
    data: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
    /**
     * Choose, which Documents to update.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents updateMany
   */
  export type DocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentsWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Documents updateManyAndReturn
   */
  export type DocumentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentsUpdateManyMutationInput, DocumentsUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentsWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Documents upsert
   */
  export type DocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Documents to update in case it exists.
     */
    where: DocumentsWhereUniqueInput
    /**
     * In case the Documents found by the `where` argument doesn't exist, create a new Documents with this data.
     */
    create: XOR<DocumentsCreateInput, DocumentsUncheckedCreateInput>
    /**
     * In case the Documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentsUpdateInput, DocumentsUncheckedUpdateInput>
  }

  /**
   * Documents delete
   */
  export type DocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
    /**
     * Filter which Documents to delete.
     */
    where: DocumentsWhereUniqueInput
  }

  /**
   * Documents deleteMany
   */
  export type DocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentsWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Documents.pathwayDocuments
   */
  export type Documents$pathwayDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayDocuments
     */
    select?: PathwayDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayDocuments
     */
    omit?: PathwayDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayDocumentsInclude<ExtArgs> | null
    where?: PathwayDocumentsWhereInput
    orderBy?: PathwayDocumentsOrderByWithRelationInput | PathwayDocumentsOrderByWithRelationInput[]
    cursor?: PathwayDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayDocumentsScalarFieldEnum | PathwayDocumentsScalarFieldEnum[]
  }

  /**
   * Documents without action
   */
  export type DocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documents
     */
    omit?: DocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentsInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    code: string | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    code: number
    name: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    code?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    code?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    code?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    code: string
    name: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    countryLanguages?: boolean | Language$countryLanguagesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    code?: boolean
    name?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countryLanguages?: boolean | Language$countryLanguagesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      countryLanguages: Prisma.$CountryLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const languageWithCodeOnly = await prisma.language.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `code`
     * const languageWithCodeOnly = await prisma.language.createManyAndReturn({
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `code`
     * const languageWithCodeOnly = await prisma.language.updateManyAndReturn({
     *   select: { code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    countryLanguages<T extends Language$countryLanguagesArgs<ExtArgs> = {}>(args?: Subset<T, Language$countryLanguagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.countryLanguages
   */
  export type Language$countryLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryLanguage
     */
    select?: CountryLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryLanguage
     */
    omit?: CountryLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryLanguageInclude<ExtArgs> | null
    where?: CountryLanguageWhereInput
    orderBy?: CountryLanguageOrderByWithRelationInput | CountryLanguageOrderByWithRelationInput[]
    cursor?: CountryLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountryLanguageScalarFieldEnum | CountryLanguageScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    contentHTML: string | null
    contentText: string | null
    subtitle: string | null
    slug: string | null
    image: boolean | null
    metaDescription: string | null
    status: $Enums.ContentStatus | null
    contentDelta: string | null
    imageExt: string | null
    imageKey: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    contentHTML: string | null
    contentText: string | null
    subtitle: string | null
    slug: string | null
    image: boolean | null
    metaDescription: string | null
    status: $Enums.ContentStatus | null
    contentDelta: string | null
    imageExt: string | null
    imageKey: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    authorId: number
    contentHTML: number
    contentText: number
    subtitle: number
    slug: number
    image: number
    metaDescription: number
    metaKeywords: number
    status: number
    contentDelta: number
    imageExt: number
    imageKey: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    contentHTML?: true
    contentText?: true
    subtitle?: true
    slug?: true
    image?: true
    metaDescription?: true
    status?: true
    contentDelta?: true
    imageExt?: true
    imageKey?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    contentHTML?: true
    contentText?: true
    subtitle?: true
    slug?: true
    image?: true
    metaDescription?: true
    status?: true
    contentDelta?: true
    imageExt?: true
    imageKey?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    contentHTML?: true
    contentText?: true
    subtitle?: true
    slug?: true
    image?: true
    metaDescription?: true
    metaKeywords?: true
    status?: true
    contentDelta?: true
    imageExt?: true
    imageKey?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    authorId: string
    contentHTML: string
    contentText: string
    subtitle: string | null
    slug: string
    image: boolean
    metaDescription: string | null
    metaKeywords: string[]
    status: $Enums.ContentStatus
    contentDelta: string
    imageExt: string | null
    imageKey: string | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    contentHTML?: boolean
    contentText?: boolean
    subtitle?: boolean
    slug?: boolean
    image?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    status?: boolean
    contentDelta?: boolean
    imageExt?: boolean
    imageKey?: boolean
    postBlock?: boolean | Post$postBlockArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    postVersionHistories?: boolean | Post$postVersionHistoriesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    contentHTML?: boolean
    contentText?: boolean
    subtitle?: boolean
    slug?: boolean
    image?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    status?: boolean
    contentDelta?: boolean
    imageExt?: boolean
    imageKey?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    contentHTML?: boolean
    contentText?: boolean
    subtitle?: boolean
    slug?: boolean
    image?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    status?: boolean
    contentDelta?: boolean
    imageExt?: boolean
    imageKey?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    contentHTML?: boolean
    contentText?: boolean
    subtitle?: boolean
    slug?: boolean
    image?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    status?: boolean
    contentDelta?: boolean
    imageExt?: boolean
    imageKey?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "authorId" | "contentHTML" | "contentText" | "subtitle" | "slug" | "image" | "metaDescription" | "metaKeywords" | "status" | "contentDelta" | "imageExt" | "imageKey", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postBlock?: boolean | Post$postBlockArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    postVersionHistories?: boolean | Post$postVersionHistoriesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      postBlock: Prisma.$PostBlockPayload<ExtArgs>[]
      tags: Prisma.$PostTagPayload<ExtArgs>[]
      postVersionHistories: Prisma.$PostVersionHistoryPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      authorId: string
      contentHTML: string
      contentText: string
      subtitle: string | null
      slug: string
      image: boolean
      metaDescription: string | null
      metaKeywords: string[]
      status: $Enums.ContentStatus
      contentDelta: string
      imageExt: string | null
      imageKey: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    postBlock<T extends Post$postBlockArgs<ExtArgs> = {}>(args?: Subset<T, Post$postBlockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Post$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postVersionHistories<T extends Post$postVersionHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Post$postVersionHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly name: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly contentHTML: FieldRef<"Post", 'String'>
    readonly contentText: FieldRef<"Post", 'String'>
    readonly subtitle: FieldRef<"Post", 'String'>
    readonly slug: FieldRef<"Post", 'String'>
    readonly image: FieldRef<"Post", 'Boolean'>
    readonly metaDescription: FieldRef<"Post", 'String'>
    readonly metaKeywords: FieldRef<"Post", 'String[]'>
    readonly status: FieldRef<"Post", 'ContentStatus'>
    readonly contentDelta: FieldRef<"Post", 'String'>
    readonly imageExt: FieldRef<"Post", 'String'>
    readonly imageKey: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.postBlock
   */
  export type Post$postBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    where?: PostBlockWhereInput
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    cursor?: PostBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostBlockScalarFieldEnum | PostBlockScalarFieldEnum[]
  }

  /**
   * Post.tags
   */
  export type Post$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Post.postVersionHistories
   */
  export type Post$postVersionHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    where?: PostVersionHistoryWhereInput
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    cursor?: PostVersionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVersionHistoryScalarFieldEnum | PostVersionHistoryScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _avg: PostTagAvgAggregateOutputType | null
    _sum: PostTagSumAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagAvgAggregateOutputType = {
    postId: number | null
    tagId: number | null
  }

  export type PostTagSumAggregateOutputType = {
    postId: number | null
    tagId: number | null
  }

  export type PostTagMinAggregateOutputType = {
    postId: number | null
    tagId: number | null
  }

  export type PostTagMaxAggregateOutputType = {
    postId: number | null
    tagId: number | null
  }

  export type PostTagCountAggregateOutputType = {
    postId: number
    tagId: number
    _all: number
  }


  export type PostTagAvgAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagSumAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagMinAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _avg?: PostTagAvgAggregateInputType
    _sum?: PostTagSumAggregateInputType
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    postId: number
    tagId: number
    _count: PostTagCountAggregateOutputType | null
    _avg: PostTagAvgAggregateOutputType | null
    _sum: PostTagSumAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
  }

  export type PostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "tagId", ExtArgs["result"]["postTag"]>
  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: number
      tagId: number
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */
  interface PostTagFieldRefs {
    readonly postId: FieldRef<"PostTag", 'Int'>
    readonly tagId: FieldRef<"PostTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag updateManyAndReturn
   */
  export type PostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    color: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    color: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    color: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    color: string
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    childTag?: boolean | Tag$childTagArgs<ExtArgs>
    parentTag?: boolean | Tag$parentTagArgs<ExtArgs>
    parent?: boolean | Tag$parentArgs<ExtArgs>
    children?: boolean | Tag$childrenArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    parent?: boolean | Tag$parentArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    parent?: boolean | Tag$parentArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "color", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    childTag?: boolean | Tag$childTagArgs<ExtArgs>
    parentTag?: boolean | Tag$parentTagArgs<ExtArgs>
    parent?: boolean | Tag$parentArgs<ExtArgs>
    children?: boolean | Tag$childrenArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Tag$parentArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Tag$parentArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostTagPayload<ExtArgs>[]
      childTag: Prisma.$TagHierarchyPayload<ExtArgs>[]
      parentTag: Prisma.$TagHierarchyPayload<ExtArgs>[]
      parent: Prisma.$TagPayload<ExtArgs> | null
      children: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      color: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    childTag<T extends Tag$childTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$childTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentTag<T extends Tag$parentTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$parentTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Tag$parentArgs<ExtArgs> = {}>(args?: Subset<T, Tag$parentArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Tag$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Tag$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly parentId: FieldRef<"Tag", 'Int'>
    readonly color: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Tag.childTag
   */
  export type Tag$childTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    where?: TagHierarchyWhereInput
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    cursor?: TagHierarchyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagHierarchyScalarFieldEnum | TagHierarchyScalarFieldEnum[]
  }

  /**
   * Tag.parentTag
   */
  export type Tag$parentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    where?: TagHierarchyWhereInput
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    cursor?: TagHierarchyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagHierarchyScalarFieldEnum | TagHierarchyScalarFieldEnum[]
  }

  /**
   * Tag.parent
   */
  export type Tag$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
  }

  /**
   * Tag.children
   */
  export type Tag$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagHierarchy
   */

  export type AggregateTagHierarchy = {
    _count: TagHierarchyCountAggregateOutputType | null
    _avg: TagHierarchyAvgAggregateOutputType | null
    _sum: TagHierarchySumAggregateOutputType | null
    _min: TagHierarchyMinAggregateOutputType | null
    _max: TagHierarchyMaxAggregateOutputType | null
  }

  export type TagHierarchyAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    childId: number | null
  }

  export type TagHierarchySumAggregateOutputType = {
    id: number | null
    parentId: number | null
    childId: number | null
  }

  export type TagHierarchyMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    childId: number | null
  }

  export type TagHierarchyMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    childId: number | null
  }

  export type TagHierarchyCountAggregateOutputType = {
    id: number
    parentId: number
    childId: number
    _all: number
  }


  export type TagHierarchyAvgAggregateInputType = {
    id?: true
    parentId?: true
    childId?: true
  }

  export type TagHierarchySumAggregateInputType = {
    id?: true
    parentId?: true
    childId?: true
  }

  export type TagHierarchyMinAggregateInputType = {
    id?: true
    parentId?: true
    childId?: true
  }

  export type TagHierarchyMaxAggregateInputType = {
    id?: true
    parentId?: true
    childId?: true
  }

  export type TagHierarchyCountAggregateInputType = {
    id?: true
    parentId?: true
    childId?: true
    _all?: true
  }

  export type TagHierarchyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagHierarchy to aggregate.
     */
    where?: TagHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagHierarchies to fetch.
     */
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagHierarchies
    **/
    _count?: true | TagHierarchyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagHierarchyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagHierarchySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagHierarchyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagHierarchyMaxAggregateInputType
  }

  export type GetTagHierarchyAggregateType<T extends TagHierarchyAggregateArgs> = {
        [P in keyof T & keyof AggregateTagHierarchy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagHierarchy[P]>
      : GetScalarType<T[P], AggregateTagHierarchy[P]>
  }




  export type TagHierarchyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagHierarchyWhereInput
    orderBy?: TagHierarchyOrderByWithAggregationInput | TagHierarchyOrderByWithAggregationInput[]
    by: TagHierarchyScalarFieldEnum[] | TagHierarchyScalarFieldEnum
    having?: TagHierarchyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagHierarchyCountAggregateInputType | true
    _avg?: TagHierarchyAvgAggregateInputType
    _sum?: TagHierarchySumAggregateInputType
    _min?: TagHierarchyMinAggregateInputType
    _max?: TagHierarchyMaxAggregateInputType
  }

  export type TagHierarchyGroupByOutputType = {
    id: number
    parentId: number
    childId: number
    _count: TagHierarchyCountAggregateOutputType | null
    _avg: TagHierarchyAvgAggregateOutputType | null
    _sum: TagHierarchySumAggregateOutputType | null
    _min: TagHierarchyMinAggregateOutputType | null
    _max: TagHierarchyMaxAggregateOutputType | null
  }

  type GetTagHierarchyGroupByPayload<T extends TagHierarchyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagHierarchyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagHierarchyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagHierarchyGroupByOutputType[P]>
            : GetScalarType<T[P], TagHierarchyGroupByOutputType[P]>
        }
      >
    >


  export type TagHierarchySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    childId?: boolean
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagHierarchy"]>

  export type TagHierarchySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    childId?: boolean
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagHierarchy"]>

  export type TagHierarchySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    childId?: boolean
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagHierarchy"]>

  export type TagHierarchySelectScalar = {
    id?: boolean
    parentId?: boolean
    childId?: boolean
  }

  export type TagHierarchyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parentId" | "childId", ExtArgs["result"]["tagHierarchy"]>
  export type TagHierarchyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagHierarchyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagHierarchyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | TagDefaultArgs<ExtArgs>
    child?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TagHierarchyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagHierarchy"
    objects: {
      parent: Prisma.$TagPayload<ExtArgs>
      child: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parentId: number
      childId: number
    }, ExtArgs["result"]["tagHierarchy"]>
    composites: {}
  }

  type TagHierarchyGetPayload<S extends boolean | null | undefined | TagHierarchyDefaultArgs> = $Result.GetResult<Prisma.$TagHierarchyPayload, S>

  type TagHierarchyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagHierarchyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagHierarchyCountAggregateInputType | true
    }

  export interface TagHierarchyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagHierarchy'], meta: { name: 'TagHierarchy' } }
    /**
     * Find zero or one TagHierarchy that matches the filter.
     * @param {TagHierarchyFindUniqueArgs} args - Arguments to find a TagHierarchy
     * @example
     * // Get one TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagHierarchyFindUniqueArgs>(args: SelectSubset<T, TagHierarchyFindUniqueArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagHierarchy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagHierarchyFindUniqueOrThrowArgs} args - Arguments to find a TagHierarchy
     * @example
     * // Get one TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagHierarchyFindUniqueOrThrowArgs>(args: SelectSubset<T, TagHierarchyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagHierarchy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyFindFirstArgs} args - Arguments to find a TagHierarchy
     * @example
     * // Get one TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagHierarchyFindFirstArgs>(args?: SelectSubset<T, TagHierarchyFindFirstArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagHierarchy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyFindFirstOrThrowArgs} args - Arguments to find a TagHierarchy
     * @example
     * // Get one TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagHierarchyFindFirstOrThrowArgs>(args?: SelectSubset<T, TagHierarchyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagHierarchies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagHierarchies
     * const tagHierarchies = await prisma.tagHierarchy.findMany()
     * 
     * // Get first 10 TagHierarchies
     * const tagHierarchies = await prisma.tagHierarchy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagHierarchyWithIdOnly = await prisma.tagHierarchy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagHierarchyFindManyArgs>(args?: SelectSubset<T, TagHierarchyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagHierarchy.
     * @param {TagHierarchyCreateArgs} args - Arguments to create a TagHierarchy.
     * @example
     * // Create one TagHierarchy
     * const TagHierarchy = await prisma.tagHierarchy.create({
     *   data: {
     *     // ... data to create a TagHierarchy
     *   }
     * })
     * 
     */
    create<T extends TagHierarchyCreateArgs>(args: SelectSubset<T, TagHierarchyCreateArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagHierarchies.
     * @param {TagHierarchyCreateManyArgs} args - Arguments to create many TagHierarchies.
     * @example
     * // Create many TagHierarchies
     * const tagHierarchy = await prisma.tagHierarchy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagHierarchyCreateManyArgs>(args?: SelectSubset<T, TagHierarchyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagHierarchies and returns the data saved in the database.
     * @param {TagHierarchyCreateManyAndReturnArgs} args - Arguments to create many TagHierarchies.
     * @example
     * // Create many TagHierarchies
     * const tagHierarchy = await prisma.tagHierarchy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagHierarchies and only return the `id`
     * const tagHierarchyWithIdOnly = await prisma.tagHierarchy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagHierarchyCreateManyAndReturnArgs>(args?: SelectSubset<T, TagHierarchyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagHierarchy.
     * @param {TagHierarchyDeleteArgs} args - Arguments to delete one TagHierarchy.
     * @example
     * // Delete one TagHierarchy
     * const TagHierarchy = await prisma.tagHierarchy.delete({
     *   where: {
     *     // ... filter to delete one TagHierarchy
     *   }
     * })
     * 
     */
    delete<T extends TagHierarchyDeleteArgs>(args: SelectSubset<T, TagHierarchyDeleteArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagHierarchy.
     * @param {TagHierarchyUpdateArgs} args - Arguments to update one TagHierarchy.
     * @example
     * // Update one TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagHierarchyUpdateArgs>(args: SelectSubset<T, TagHierarchyUpdateArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagHierarchies.
     * @param {TagHierarchyDeleteManyArgs} args - Arguments to filter TagHierarchies to delete.
     * @example
     * // Delete a few TagHierarchies
     * const { count } = await prisma.tagHierarchy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagHierarchyDeleteManyArgs>(args?: SelectSubset<T, TagHierarchyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagHierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagHierarchies
     * const tagHierarchy = await prisma.tagHierarchy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagHierarchyUpdateManyArgs>(args: SelectSubset<T, TagHierarchyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagHierarchies and returns the data updated in the database.
     * @param {TagHierarchyUpdateManyAndReturnArgs} args - Arguments to update many TagHierarchies.
     * @example
     * // Update many TagHierarchies
     * const tagHierarchy = await prisma.tagHierarchy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagHierarchies and only return the `id`
     * const tagHierarchyWithIdOnly = await prisma.tagHierarchy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagHierarchyUpdateManyAndReturnArgs>(args: SelectSubset<T, TagHierarchyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagHierarchy.
     * @param {TagHierarchyUpsertArgs} args - Arguments to update or create a TagHierarchy.
     * @example
     * // Update or create a TagHierarchy
     * const tagHierarchy = await prisma.tagHierarchy.upsert({
     *   create: {
     *     // ... data to create a TagHierarchy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagHierarchy we want to update
     *   }
     * })
     */
    upsert<T extends TagHierarchyUpsertArgs>(args: SelectSubset<T, TagHierarchyUpsertArgs<ExtArgs>>): Prisma__TagHierarchyClient<$Result.GetResult<Prisma.$TagHierarchyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagHierarchies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyCountArgs} args - Arguments to filter TagHierarchies to count.
     * @example
     * // Count the number of TagHierarchies
     * const count = await prisma.tagHierarchy.count({
     *   where: {
     *     // ... the filter for the TagHierarchies we want to count
     *   }
     * })
    **/
    count<T extends TagHierarchyCountArgs>(
      args?: Subset<T, TagHierarchyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagHierarchyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagHierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagHierarchyAggregateArgs>(args: Subset<T, TagHierarchyAggregateArgs>): Prisma.PrismaPromise<GetTagHierarchyAggregateType<T>>

    /**
     * Group by TagHierarchy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagHierarchyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagHierarchyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagHierarchyGroupByArgs['orderBy'] }
        : { orderBy?: TagHierarchyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagHierarchyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagHierarchyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagHierarchy model
   */
  readonly fields: TagHierarchyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagHierarchy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagHierarchyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    child<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagHierarchy model
   */
  interface TagHierarchyFieldRefs {
    readonly id: FieldRef<"TagHierarchy", 'Int'>
    readonly parentId: FieldRef<"TagHierarchy", 'Int'>
    readonly childId: FieldRef<"TagHierarchy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TagHierarchy findUnique
   */
  export type TagHierarchyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which TagHierarchy to fetch.
     */
    where: TagHierarchyWhereUniqueInput
  }

  /**
   * TagHierarchy findUniqueOrThrow
   */
  export type TagHierarchyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which TagHierarchy to fetch.
     */
    where: TagHierarchyWhereUniqueInput
  }

  /**
   * TagHierarchy findFirst
   */
  export type TagHierarchyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which TagHierarchy to fetch.
     */
    where?: TagHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagHierarchies to fetch.
     */
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagHierarchies.
     */
    cursor?: TagHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagHierarchies.
     */
    distinct?: TagHierarchyScalarFieldEnum | TagHierarchyScalarFieldEnum[]
  }

  /**
   * TagHierarchy findFirstOrThrow
   */
  export type TagHierarchyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which TagHierarchy to fetch.
     */
    where?: TagHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagHierarchies to fetch.
     */
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagHierarchies.
     */
    cursor?: TagHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagHierarchies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagHierarchies.
     */
    distinct?: TagHierarchyScalarFieldEnum | TagHierarchyScalarFieldEnum[]
  }

  /**
   * TagHierarchy findMany
   */
  export type TagHierarchyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter, which TagHierarchies to fetch.
     */
    where?: TagHierarchyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagHierarchies to fetch.
     */
    orderBy?: TagHierarchyOrderByWithRelationInput | TagHierarchyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagHierarchies.
     */
    cursor?: TagHierarchyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagHierarchies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagHierarchies.
     */
    skip?: number
    distinct?: TagHierarchyScalarFieldEnum | TagHierarchyScalarFieldEnum[]
  }

  /**
   * TagHierarchy create
   */
  export type TagHierarchyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * The data needed to create a TagHierarchy.
     */
    data: XOR<TagHierarchyCreateInput, TagHierarchyUncheckedCreateInput>
  }

  /**
   * TagHierarchy createMany
   */
  export type TagHierarchyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagHierarchies.
     */
    data: TagHierarchyCreateManyInput | TagHierarchyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagHierarchy createManyAndReturn
   */
  export type TagHierarchyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * The data used to create many TagHierarchies.
     */
    data: TagHierarchyCreateManyInput | TagHierarchyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagHierarchy update
   */
  export type TagHierarchyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * The data needed to update a TagHierarchy.
     */
    data: XOR<TagHierarchyUpdateInput, TagHierarchyUncheckedUpdateInput>
    /**
     * Choose, which TagHierarchy to update.
     */
    where: TagHierarchyWhereUniqueInput
  }

  /**
   * TagHierarchy updateMany
   */
  export type TagHierarchyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagHierarchies.
     */
    data: XOR<TagHierarchyUpdateManyMutationInput, TagHierarchyUncheckedUpdateManyInput>
    /**
     * Filter which TagHierarchies to update
     */
    where?: TagHierarchyWhereInput
    /**
     * Limit how many TagHierarchies to update.
     */
    limit?: number
  }

  /**
   * TagHierarchy updateManyAndReturn
   */
  export type TagHierarchyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * The data used to update TagHierarchies.
     */
    data: XOR<TagHierarchyUpdateManyMutationInput, TagHierarchyUncheckedUpdateManyInput>
    /**
     * Filter which TagHierarchies to update
     */
    where?: TagHierarchyWhereInput
    /**
     * Limit how many TagHierarchies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagHierarchy upsert
   */
  export type TagHierarchyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * The filter to search for the TagHierarchy to update in case it exists.
     */
    where: TagHierarchyWhereUniqueInput
    /**
     * In case the TagHierarchy found by the `where` argument doesn't exist, create a new TagHierarchy with this data.
     */
    create: XOR<TagHierarchyCreateInput, TagHierarchyUncheckedCreateInput>
    /**
     * In case the TagHierarchy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagHierarchyUpdateInput, TagHierarchyUncheckedUpdateInput>
  }

  /**
   * TagHierarchy delete
   */
  export type TagHierarchyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
    /**
     * Filter which TagHierarchy to delete.
     */
    where: TagHierarchyWhereUniqueInput
  }

  /**
   * TagHierarchy deleteMany
   */
  export type TagHierarchyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagHierarchies to delete
     */
    where?: TagHierarchyWhereInput
    /**
     * Limit how many TagHierarchies to delete.
     */
    limit?: number
  }

  /**
   * TagHierarchy without action
   */
  export type TagHierarchyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagHierarchy
     */
    select?: TagHierarchySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagHierarchy
     */
    omit?: TagHierarchyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagHierarchyInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    content: string | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
    content: string | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    authorId: number
    content: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    content?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    content?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    content?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    name: string
    type: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    authorId: string
    content: string
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    content?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    content?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    content?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    content?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "createdAt" | "updatedAt" | "authorId" | "content", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      authorId: string
      content: string
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
    readonly authorId: FieldRef<"Resource", 'String'>
    readonly content: FieldRef<"Resource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockAvgAggregateOutputType = {
    id: number | null
  }

  export type BlockSumAggregateOutputType = {
    id: number | null
  }

  export type BlockMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    component: string | null
    type: string | null
  }

  export type BlockMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    component: string | null
    type: string | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    component: number
    type: number
    _all: number
  }


  export type BlockAvgAggregateInputType = {
    id?: true
  }

  export type BlockSumAggregateInputType = {
    id?: true
  }

  export type BlockMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    component?: true
    type?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    component?: true
    type?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    component?: true
    type?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _avg?: BlockAvgAggregateInputType
    _sum?: BlockSumAggregateInputType
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: number
    slug: string
    name: string
    component: string
    type: string
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    component?: boolean
    type?: boolean
    blockField?: boolean | Block$blockFieldArgs<ExtArgs>
    postBlock?: boolean | Block$postBlockArgs<ExtArgs>
    _count?: boolean | BlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    component?: boolean
    type?: boolean
  }, ExtArgs["result"]["block"]>

  export type BlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    component?: boolean
    type?: boolean
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    component?: boolean
    type?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "component" | "type", ExtArgs["result"]["block"]>
  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockField?: boolean | Block$blockFieldArgs<ExtArgs>
    postBlock?: boolean | Block$postBlockArgs<ExtArgs>
    _count?: boolean | BlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blockField: Prisma.$BlockFieldPayload<ExtArgs>[]
      postBlock: Prisma.$PostBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      component: string
      type: string
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockField<T extends Block$blockFieldArgs<ExtArgs> = {}>(args?: Subset<T, Block$blockFieldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postBlock<T extends Block$postBlockArgs<ExtArgs> = {}>(args?: Subset<T, Block$postBlockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'Int'>
    readonly slug: FieldRef<"Block", 'String'>
    readonly name: FieldRef<"Block", 'String'>
    readonly component: FieldRef<"Block", 'String'>
    readonly type: FieldRef<"Block", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block updateManyAndReturn
   */
  export type BlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block.blockField
   */
  export type Block$blockFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    where?: BlockFieldWhereInput
    orderBy?: BlockFieldOrderByWithRelationInput | BlockFieldOrderByWithRelationInput[]
    cursor?: BlockFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockFieldScalarFieldEnum | BlockFieldScalarFieldEnum[]
  }

  /**
   * Block.postBlock
   */
  export type Block$postBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    where?: PostBlockWhereInput
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    cursor?: PostBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostBlockScalarFieldEnum | PostBlockScalarFieldEnum[]
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model BlockField
   */

  export type AggregateBlockField = {
    _count: BlockFieldCountAggregateOutputType | null
    _avg: BlockFieldAvgAggregateOutputType | null
    _sum: BlockFieldSumAggregateOutputType | null
    _min: BlockFieldMinAggregateOutputType | null
    _max: BlockFieldMaxAggregateOutputType | null
  }

  export type BlockFieldAvgAggregateOutputType = {
    id: number | null
    blockId: number | null
  }

  export type BlockFieldSumAggregateOutputType = {
    id: number | null
    blockId: number | null
  }

  export type BlockFieldMinAggregateOutputType = {
    id: number | null
    blockId: number | null
    name: string | null
    type: string | null
    options: string | null
    slug: string | null
    defaultValue: string | null
  }

  export type BlockFieldMaxAggregateOutputType = {
    id: number | null
    blockId: number | null
    name: string | null
    type: string | null
    options: string | null
    slug: string | null
    defaultValue: string | null
  }

  export type BlockFieldCountAggregateOutputType = {
    id: number
    blockId: number
    name: number
    type: number
    options: number
    slug: number
    defaultValue: number
    _all: number
  }


  export type BlockFieldAvgAggregateInputType = {
    id?: true
    blockId?: true
  }

  export type BlockFieldSumAggregateInputType = {
    id?: true
    blockId?: true
  }

  export type BlockFieldMinAggregateInputType = {
    id?: true
    blockId?: true
    name?: true
    type?: true
    options?: true
    slug?: true
    defaultValue?: true
  }

  export type BlockFieldMaxAggregateInputType = {
    id?: true
    blockId?: true
    name?: true
    type?: true
    options?: true
    slug?: true
    defaultValue?: true
  }

  export type BlockFieldCountAggregateInputType = {
    id?: true
    blockId?: true
    name?: true
    type?: true
    options?: true
    slug?: true
    defaultValue?: true
    _all?: true
  }

  export type BlockFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockField to aggregate.
     */
    where?: BlockFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockFields to fetch.
     */
    orderBy?: BlockFieldOrderByWithRelationInput | BlockFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockFields
    **/
    _count?: true | BlockFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockFieldMaxAggregateInputType
  }

  export type GetBlockFieldAggregateType<T extends BlockFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockField[P]>
      : GetScalarType<T[P], AggregateBlockField[P]>
  }




  export type BlockFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockFieldWhereInput
    orderBy?: BlockFieldOrderByWithAggregationInput | BlockFieldOrderByWithAggregationInput[]
    by: BlockFieldScalarFieldEnum[] | BlockFieldScalarFieldEnum
    having?: BlockFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockFieldCountAggregateInputType | true
    _avg?: BlockFieldAvgAggregateInputType
    _sum?: BlockFieldSumAggregateInputType
    _min?: BlockFieldMinAggregateInputType
    _max?: BlockFieldMaxAggregateInputType
  }

  export type BlockFieldGroupByOutputType = {
    id: number
    blockId: number
    name: string
    type: string
    options: string | null
    slug: string
    defaultValue: string | null
    _count: BlockFieldCountAggregateOutputType | null
    _avg: BlockFieldAvgAggregateOutputType | null
    _sum: BlockFieldSumAggregateOutputType | null
    _min: BlockFieldMinAggregateOutputType | null
    _max: BlockFieldMaxAggregateOutputType | null
  }

  type GetBlockFieldGroupByPayload<T extends BlockFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockFieldGroupByOutputType[P]>
            : GetScalarType<T[P], BlockFieldGroupByOutputType[P]>
        }
      >
    >


  export type BlockFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    slug?: boolean
    defaultValue?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockField"]>

  export type BlockFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    slug?: boolean
    defaultValue?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockField"]>

  export type BlockFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    slug?: boolean
    defaultValue?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockField"]>

  export type BlockFieldSelectScalar = {
    id?: boolean
    blockId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    slug?: boolean
    defaultValue?: boolean
  }

  export type BlockFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blockId" | "name" | "type" | "options" | "slug" | "defaultValue", ExtArgs["result"]["blockField"]>
  export type BlockFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }
  export type BlockFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }
  export type BlockFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
  }

  export type $BlockFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockField"
    objects: {
      block: Prisma.$BlockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      blockId: number
      name: string
      type: string
      options: string | null
      slug: string
      defaultValue: string | null
    }, ExtArgs["result"]["blockField"]>
    composites: {}
  }

  type BlockFieldGetPayload<S extends boolean | null | undefined | BlockFieldDefaultArgs> = $Result.GetResult<Prisma.$BlockFieldPayload, S>

  type BlockFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockFieldCountAggregateInputType | true
    }

  export interface BlockFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockField'], meta: { name: 'BlockField' } }
    /**
     * Find zero or one BlockField that matches the filter.
     * @param {BlockFieldFindUniqueArgs} args - Arguments to find a BlockField
     * @example
     * // Get one BlockField
     * const blockField = await prisma.blockField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFieldFindUniqueArgs>(args: SelectSubset<T, BlockFieldFindUniqueArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFieldFindUniqueOrThrowArgs} args - Arguments to find a BlockField
     * @example
     * // Get one BlockField
     * const blockField = await prisma.blockField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldFindFirstArgs} args - Arguments to find a BlockField
     * @example
     * // Get one BlockField
     * const blockField = await prisma.blockField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFieldFindFirstArgs>(args?: SelectSubset<T, BlockFieldFindFirstArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldFindFirstOrThrowArgs} args - Arguments to find a BlockField
     * @example
     * // Get one BlockField
     * const blockField = await prisma.blockField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockFields
     * const blockFields = await prisma.blockField.findMany()
     * 
     * // Get first 10 BlockFields
     * const blockFields = await prisma.blockField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockFieldWithIdOnly = await prisma.blockField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFieldFindManyArgs>(args?: SelectSubset<T, BlockFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockField.
     * @param {BlockFieldCreateArgs} args - Arguments to create a BlockField.
     * @example
     * // Create one BlockField
     * const BlockField = await prisma.blockField.create({
     *   data: {
     *     // ... data to create a BlockField
     *   }
     * })
     * 
     */
    create<T extends BlockFieldCreateArgs>(args: SelectSubset<T, BlockFieldCreateArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockFields.
     * @param {BlockFieldCreateManyArgs} args - Arguments to create many BlockFields.
     * @example
     * // Create many BlockFields
     * const blockField = await prisma.blockField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockFieldCreateManyArgs>(args?: SelectSubset<T, BlockFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockFields and returns the data saved in the database.
     * @param {BlockFieldCreateManyAndReturnArgs} args - Arguments to create many BlockFields.
     * @example
     * // Create many BlockFields
     * const blockField = await prisma.blockField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockFields and only return the `id`
     * const blockFieldWithIdOnly = await prisma.blockField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockField.
     * @param {BlockFieldDeleteArgs} args - Arguments to delete one BlockField.
     * @example
     * // Delete one BlockField
     * const BlockField = await prisma.blockField.delete({
     *   where: {
     *     // ... filter to delete one BlockField
     *   }
     * })
     * 
     */
    delete<T extends BlockFieldDeleteArgs>(args: SelectSubset<T, BlockFieldDeleteArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockField.
     * @param {BlockFieldUpdateArgs} args - Arguments to update one BlockField.
     * @example
     * // Update one BlockField
     * const blockField = await prisma.blockField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockFieldUpdateArgs>(args: SelectSubset<T, BlockFieldUpdateArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockFields.
     * @param {BlockFieldDeleteManyArgs} args - Arguments to filter BlockFields to delete.
     * @example
     * // Delete a few BlockFields
     * const { count } = await prisma.blockField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockFieldDeleteManyArgs>(args?: SelectSubset<T, BlockFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockFields
     * const blockField = await prisma.blockField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockFieldUpdateManyArgs>(args: SelectSubset<T, BlockFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockFields and returns the data updated in the database.
     * @param {BlockFieldUpdateManyAndReturnArgs} args - Arguments to update many BlockFields.
     * @example
     * // Update many BlockFields
     * const blockField = await prisma.blockField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockFields and only return the `id`
     * const blockFieldWithIdOnly = await prisma.blockField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockField.
     * @param {BlockFieldUpsertArgs} args - Arguments to update or create a BlockField.
     * @example
     * // Update or create a BlockField
     * const blockField = await prisma.blockField.upsert({
     *   create: {
     *     // ... data to create a BlockField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockField we want to update
     *   }
     * })
     */
    upsert<T extends BlockFieldUpsertArgs>(args: SelectSubset<T, BlockFieldUpsertArgs<ExtArgs>>): Prisma__BlockFieldClient<$Result.GetResult<Prisma.$BlockFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldCountArgs} args - Arguments to filter BlockFields to count.
     * @example
     * // Count the number of BlockFields
     * const count = await prisma.blockField.count({
     *   where: {
     *     // ... the filter for the BlockFields we want to count
     *   }
     * })
    **/
    count<T extends BlockFieldCountArgs>(
      args?: Subset<T, BlockFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockFieldAggregateArgs>(args: Subset<T, BlockFieldAggregateArgs>): Prisma.PrismaPromise<GetBlockFieldAggregateType<T>>

    /**
     * Group by BlockField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockFieldGroupByArgs['orderBy'] }
        : { orderBy?: BlockFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockField model
   */
  readonly fields: BlockFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends BlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockDefaultArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockField model
   */
  interface BlockFieldFieldRefs {
    readonly id: FieldRef<"BlockField", 'Int'>
    readonly blockId: FieldRef<"BlockField", 'Int'>
    readonly name: FieldRef<"BlockField", 'String'>
    readonly type: FieldRef<"BlockField", 'String'>
    readonly options: FieldRef<"BlockField", 'String'>
    readonly slug: FieldRef<"BlockField", 'String'>
    readonly defaultValue: FieldRef<"BlockField", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BlockField findUnique
   */
  export type BlockFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter, which BlockField to fetch.
     */
    where: BlockFieldWhereUniqueInput
  }

  /**
   * BlockField findUniqueOrThrow
   */
  export type BlockFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter, which BlockField to fetch.
     */
    where: BlockFieldWhereUniqueInput
  }

  /**
   * BlockField findFirst
   */
  export type BlockFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter, which BlockField to fetch.
     */
    where?: BlockFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockFields to fetch.
     */
    orderBy?: BlockFieldOrderByWithRelationInput | BlockFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockFields.
     */
    cursor?: BlockFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockFields.
     */
    distinct?: BlockFieldScalarFieldEnum | BlockFieldScalarFieldEnum[]
  }

  /**
   * BlockField findFirstOrThrow
   */
  export type BlockFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter, which BlockField to fetch.
     */
    where?: BlockFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockFields to fetch.
     */
    orderBy?: BlockFieldOrderByWithRelationInput | BlockFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockFields.
     */
    cursor?: BlockFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockFields.
     */
    distinct?: BlockFieldScalarFieldEnum | BlockFieldScalarFieldEnum[]
  }

  /**
   * BlockField findMany
   */
  export type BlockFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter, which BlockFields to fetch.
     */
    where?: BlockFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockFields to fetch.
     */
    orderBy?: BlockFieldOrderByWithRelationInput | BlockFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockFields.
     */
    cursor?: BlockFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockFields.
     */
    skip?: number
    distinct?: BlockFieldScalarFieldEnum | BlockFieldScalarFieldEnum[]
  }

  /**
   * BlockField create
   */
  export type BlockFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockField.
     */
    data: XOR<BlockFieldCreateInput, BlockFieldUncheckedCreateInput>
  }

  /**
   * BlockField createMany
   */
  export type BlockFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockFields.
     */
    data: BlockFieldCreateManyInput | BlockFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockField createManyAndReturn
   */
  export type BlockFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * The data used to create many BlockFields.
     */
    data: BlockFieldCreateManyInput | BlockFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockField update
   */
  export type BlockFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockField.
     */
    data: XOR<BlockFieldUpdateInput, BlockFieldUncheckedUpdateInput>
    /**
     * Choose, which BlockField to update.
     */
    where: BlockFieldWhereUniqueInput
  }

  /**
   * BlockField updateMany
   */
  export type BlockFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockFields.
     */
    data: XOR<BlockFieldUpdateManyMutationInput, BlockFieldUncheckedUpdateManyInput>
    /**
     * Filter which BlockFields to update
     */
    where?: BlockFieldWhereInput
    /**
     * Limit how many BlockFields to update.
     */
    limit?: number
  }

  /**
   * BlockField updateManyAndReturn
   */
  export type BlockFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * The data used to update BlockFields.
     */
    data: XOR<BlockFieldUpdateManyMutationInput, BlockFieldUncheckedUpdateManyInput>
    /**
     * Filter which BlockFields to update
     */
    where?: BlockFieldWhereInput
    /**
     * Limit how many BlockFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockField upsert
   */
  export type BlockFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockField to update in case it exists.
     */
    where: BlockFieldWhereUniqueInput
    /**
     * In case the BlockField found by the `where` argument doesn't exist, create a new BlockField with this data.
     */
    create: XOR<BlockFieldCreateInput, BlockFieldUncheckedCreateInput>
    /**
     * In case the BlockField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockFieldUpdateInput, BlockFieldUncheckedUpdateInput>
  }

  /**
   * BlockField delete
   */
  export type BlockFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
    /**
     * Filter which BlockField to delete.
     */
    where: BlockFieldWhereUniqueInput
  }

  /**
   * BlockField deleteMany
   */
  export type BlockFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockFields to delete
     */
    where?: BlockFieldWhereInput
    /**
     * Limit how many BlockFields to delete.
     */
    limit?: number
  }

  /**
   * BlockField without action
   */
  export type BlockFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockField
     */
    select?: BlockFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockField
     */
    omit?: BlockFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockFieldInclude<ExtArgs> | null
  }


  /**
   * Model PostBlock
   */

  export type AggregatePostBlock = {
    _count: PostBlockCountAggregateOutputType | null
    _avg: PostBlockAvgAggregateOutputType | null
    _sum: PostBlockSumAggregateOutputType | null
    _min: PostBlockMinAggregateOutputType | null
    _max: PostBlockMaxAggregateOutputType | null
  }

  export type PostBlockAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    blockId: number | null
    position: number | null
  }

  export type PostBlockSumAggregateOutputType = {
    id: number | null
    postId: number | null
    blockId: number | null
    position: number | null
  }

  export type PostBlockMinAggregateOutputType = {
    id: number | null
    postId: number | null
    blockId: number | null
    type: string | null
    content: string | null
    position: number | null
  }

  export type PostBlockMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    blockId: number | null
    type: string | null
    content: string | null
    position: number | null
  }

  export type PostBlockCountAggregateOutputType = {
    id: number
    postId: number
    blockId: number
    type: number
    content: number
    position: number
    _all: number
  }


  export type PostBlockAvgAggregateInputType = {
    id?: true
    postId?: true
    blockId?: true
    position?: true
  }

  export type PostBlockSumAggregateInputType = {
    id?: true
    postId?: true
    blockId?: true
    position?: true
  }

  export type PostBlockMinAggregateInputType = {
    id?: true
    postId?: true
    blockId?: true
    type?: true
    content?: true
    position?: true
  }

  export type PostBlockMaxAggregateInputType = {
    id?: true
    postId?: true
    blockId?: true
    type?: true
    content?: true
    position?: true
  }

  export type PostBlockCountAggregateInputType = {
    id?: true
    postId?: true
    blockId?: true
    type?: true
    content?: true
    position?: true
    _all?: true
  }

  export type PostBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostBlock to aggregate.
     */
    where?: PostBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostBlocks to fetch.
     */
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostBlocks
    **/
    _count?: true | PostBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostBlockMaxAggregateInputType
  }

  export type GetPostBlockAggregateType<T extends PostBlockAggregateArgs> = {
        [P in keyof T & keyof AggregatePostBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostBlock[P]>
      : GetScalarType<T[P], AggregatePostBlock[P]>
  }




  export type PostBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostBlockWhereInput
    orderBy?: PostBlockOrderByWithAggregationInput | PostBlockOrderByWithAggregationInput[]
    by: PostBlockScalarFieldEnum[] | PostBlockScalarFieldEnum
    having?: PostBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostBlockCountAggregateInputType | true
    _avg?: PostBlockAvgAggregateInputType
    _sum?: PostBlockSumAggregateInputType
    _min?: PostBlockMinAggregateInputType
    _max?: PostBlockMaxAggregateInputType
  }

  export type PostBlockGroupByOutputType = {
    id: number
    postId: number
    blockId: number
    type: string
    content: string
    position: number
    _count: PostBlockCountAggregateOutputType | null
    _avg: PostBlockAvgAggregateOutputType | null
    _sum: PostBlockSumAggregateOutputType | null
    _min: PostBlockMinAggregateOutputType | null
    _max: PostBlockMaxAggregateOutputType | null
  }

  type GetPostBlockGroupByPayload<T extends PostBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostBlockGroupByOutputType[P]>
            : GetScalarType<T[P], PostBlockGroupByOutputType[P]>
        }
      >
    >


  export type PostBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    blockId?: boolean
    type?: boolean
    content?: boolean
    position?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postBlock"]>

  export type PostBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    blockId?: boolean
    type?: boolean
    content?: boolean
    position?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postBlock"]>

  export type PostBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    blockId?: boolean
    type?: boolean
    content?: boolean
    position?: boolean
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postBlock"]>

  export type PostBlockSelectScalar = {
    id?: boolean
    postId?: boolean
    blockId?: boolean
    type?: boolean
    content?: boolean
    position?: boolean
  }

  export type PostBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "blockId" | "type" | "content" | "position", ExtArgs["result"]["postBlock"]>
  export type PostBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | BlockDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostBlock"
    objects: {
      block: Prisma.$BlockPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      blockId: number
      type: string
      content: string
      position: number
    }, ExtArgs["result"]["postBlock"]>
    composites: {}
  }

  type PostBlockGetPayload<S extends boolean | null | undefined | PostBlockDefaultArgs> = $Result.GetResult<Prisma.$PostBlockPayload, S>

  type PostBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostBlockCountAggregateInputType | true
    }

  export interface PostBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostBlock'], meta: { name: 'PostBlock' } }
    /**
     * Find zero or one PostBlock that matches the filter.
     * @param {PostBlockFindUniqueArgs} args - Arguments to find a PostBlock
     * @example
     * // Get one PostBlock
     * const postBlock = await prisma.postBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostBlockFindUniqueArgs>(args: SelectSubset<T, PostBlockFindUniqueArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostBlockFindUniqueOrThrowArgs} args - Arguments to find a PostBlock
     * @example
     * // Get one PostBlock
     * const postBlock = await prisma.postBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, PostBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockFindFirstArgs} args - Arguments to find a PostBlock
     * @example
     * // Get one PostBlock
     * const postBlock = await prisma.postBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostBlockFindFirstArgs>(args?: SelectSubset<T, PostBlockFindFirstArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockFindFirstOrThrowArgs} args - Arguments to find a PostBlock
     * @example
     * // Get one PostBlock
     * const postBlock = await prisma.postBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, PostBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostBlocks
     * const postBlocks = await prisma.postBlock.findMany()
     * 
     * // Get first 10 PostBlocks
     * const postBlocks = await prisma.postBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postBlockWithIdOnly = await prisma.postBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostBlockFindManyArgs>(args?: SelectSubset<T, PostBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostBlock.
     * @param {PostBlockCreateArgs} args - Arguments to create a PostBlock.
     * @example
     * // Create one PostBlock
     * const PostBlock = await prisma.postBlock.create({
     *   data: {
     *     // ... data to create a PostBlock
     *   }
     * })
     * 
     */
    create<T extends PostBlockCreateArgs>(args: SelectSubset<T, PostBlockCreateArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostBlocks.
     * @param {PostBlockCreateManyArgs} args - Arguments to create many PostBlocks.
     * @example
     * // Create many PostBlocks
     * const postBlock = await prisma.postBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostBlockCreateManyArgs>(args?: SelectSubset<T, PostBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostBlocks and returns the data saved in the database.
     * @param {PostBlockCreateManyAndReturnArgs} args - Arguments to create many PostBlocks.
     * @example
     * // Create many PostBlocks
     * const postBlock = await prisma.postBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostBlocks and only return the `id`
     * const postBlockWithIdOnly = await prisma.postBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, PostBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostBlock.
     * @param {PostBlockDeleteArgs} args - Arguments to delete one PostBlock.
     * @example
     * // Delete one PostBlock
     * const PostBlock = await prisma.postBlock.delete({
     *   where: {
     *     // ... filter to delete one PostBlock
     *   }
     * })
     * 
     */
    delete<T extends PostBlockDeleteArgs>(args: SelectSubset<T, PostBlockDeleteArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostBlock.
     * @param {PostBlockUpdateArgs} args - Arguments to update one PostBlock.
     * @example
     * // Update one PostBlock
     * const postBlock = await prisma.postBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostBlockUpdateArgs>(args: SelectSubset<T, PostBlockUpdateArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostBlocks.
     * @param {PostBlockDeleteManyArgs} args - Arguments to filter PostBlocks to delete.
     * @example
     * // Delete a few PostBlocks
     * const { count } = await prisma.postBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostBlockDeleteManyArgs>(args?: SelectSubset<T, PostBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostBlocks
     * const postBlock = await prisma.postBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostBlockUpdateManyArgs>(args: SelectSubset<T, PostBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostBlocks and returns the data updated in the database.
     * @param {PostBlockUpdateManyAndReturnArgs} args - Arguments to update many PostBlocks.
     * @example
     * // Update many PostBlocks
     * const postBlock = await prisma.postBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostBlocks and only return the `id`
     * const postBlockWithIdOnly = await prisma.postBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, PostBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostBlock.
     * @param {PostBlockUpsertArgs} args - Arguments to update or create a PostBlock.
     * @example
     * // Update or create a PostBlock
     * const postBlock = await prisma.postBlock.upsert({
     *   create: {
     *     // ... data to create a PostBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostBlock we want to update
     *   }
     * })
     */
    upsert<T extends PostBlockUpsertArgs>(args: SelectSubset<T, PostBlockUpsertArgs<ExtArgs>>): Prisma__PostBlockClient<$Result.GetResult<Prisma.$PostBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockCountArgs} args - Arguments to filter PostBlocks to count.
     * @example
     * // Count the number of PostBlocks
     * const count = await prisma.postBlock.count({
     *   where: {
     *     // ... the filter for the PostBlocks we want to count
     *   }
     * })
    **/
    count<T extends PostBlockCountArgs>(
      args?: Subset<T, PostBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostBlockAggregateArgs>(args: Subset<T, PostBlockAggregateArgs>): Prisma.PrismaPromise<GetPostBlockAggregateType<T>>

    /**
     * Group by PostBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostBlockGroupByArgs['orderBy'] }
        : { orderBy?: PostBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostBlock model
   */
  readonly fields: PostBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends BlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlockDefaultArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostBlock model
   */
  interface PostBlockFieldRefs {
    readonly id: FieldRef<"PostBlock", 'Int'>
    readonly postId: FieldRef<"PostBlock", 'Int'>
    readonly blockId: FieldRef<"PostBlock", 'Int'>
    readonly type: FieldRef<"PostBlock", 'String'>
    readonly content: FieldRef<"PostBlock", 'String'>
    readonly position: FieldRef<"PostBlock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostBlock findUnique
   */
  export type PostBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter, which PostBlock to fetch.
     */
    where: PostBlockWhereUniqueInput
  }

  /**
   * PostBlock findUniqueOrThrow
   */
  export type PostBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter, which PostBlock to fetch.
     */
    where: PostBlockWhereUniqueInput
  }

  /**
   * PostBlock findFirst
   */
  export type PostBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter, which PostBlock to fetch.
     */
    where?: PostBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostBlocks to fetch.
     */
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostBlocks.
     */
    cursor?: PostBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostBlocks.
     */
    distinct?: PostBlockScalarFieldEnum | PostBlockScalarFieldEnum[]
  }

  /**
   * PostBlock findFirstOrThrow
   */
  export type PostBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter, which PostBlock to fetch.
     */
    where?: PostBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostBlocks to fetch.
     */
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostBlocks.
     */
    cursor?: PostBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostBlocks.
     */
    distinct?: PostBlockScalarFieldEnum | PostBlockScalarFieldEnum[]
  }

  /**
   * PostBlock findMany
   */
  export type PostBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter, which PostBlocks to fetch.
     */
    where?: PostBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostBlocks to fetch.
     */
    orderBy?: PostBlockOrderByWithRelationInput | PostBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostBlocks.
     */
    cursor?: PostBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostBlocks.
     */
    skip?: number
    distinct?: PostBlockScalarFieldEnum | PostBlockScalarFieldEnum[]
  }

  /**
   * PostBlock create
   */
  export type PostBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a PostBlock.
     */
    data: XOR<PostBlockCreateInput, PostBlockUncheckedCreateInput>
  }

  /**
   * PostBlock createMany
   */
  export type PostBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostBlocks.
     */
    data: PostBlockCreateManyInput | PostBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostBlock createManyAndReturn
   */
  export type PostBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * The data used to create many PostBlocks.
     */
    data: PostBlockCreateManyInput | PostBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostBlock update
   */
  export type PostBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a PostBlock.
     */
    data: XOR<PostBlockUpdateInput, PostBlockUncheckedUpdateInput>
    /**
     * Choose, which PostBlock to update.
     */
    where: PostBlockWhereUniqueInput
  }

  /**
   * PostBlock updateMany
   */
  export type PostBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostBlocks.
     */
    data: XOR<PostBlockUpdateManyMutationInput, PostBlockUncheckedUpdateManyInput>
    /**
     * Filter which PostBlocks to update
     */
    where?: PostBlockWhereInput
    /**
     * Limit how many PostBlocks to update.
     */
    limit?: number
  }

  /**
   * PostBlock updateManyAndReturn
   */
  export type PostBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * The data used to update PostBlocks.
     */
    data: XOR<PostBlockUpdateManyMutationInput, PostBlockUncheckedUpdateManyInput>
    /**
     * Filter which PostBlocks to update
     */
    where?: PostBlockWhereInput
    /**
     * Limit how many PostBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostBlock upsert
   */
  export type PostBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the PostBlock to update in case it exists.
     */
    where: PostBlockWhereUniqueInput
    /**
     * In case the PostBlock found by the `where` argument doesn't exist, create a new PostBlock with this data.
     */
    create: XOR<PostBlockCreateInput, PostBlockUncheckedCreateInput>
    /**
     * In case the PostBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostBlockUpdateInput, PostBlockUncheckedUpdateInput>
  }

  /**
   * PostBlock delete
   */
  export type PostBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
    /**
     * Filter which PostBlock to delete.
     */
    where: PostBlockWhereUniqueInput
  }

  /**
   * PostBlock deleteMany
   */
  export type PostBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostBlocks to delete
     */
    where?: PostBlockWhereInput
    /**
     * Limit how many PostBlocks to delete.
     */
    limit?: number
  }

  /**
   * PostBlock without action
   */
  export type PostBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostBlock
     */
    select?: PostBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostBlock
     */
    omit?: PostBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostBlockInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    secret: string | null
    firstName: string | null
    lastName: string | null
    discordHandle: string | null
    key: string | null
    created: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    secret: string | null
    firstName: string | null
    lastName: string | null
    discordHandle: string | null
    key: string | null
    created: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    secret: number
    firstName: number
    lastName: number
    discordHandle: number
    key: number
    created: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    secret?: true
    firstName?: true
    lastName?: true
    discordHandle?: true
    key?: true
    created?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    secret?: true
    firstName?: true
    lastName?: true
    discordHandle?: true
    key?: true
    created?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    secret?: true
    firstName?: true
    lastName?: true
    discordHandle?: true
    key?: true
    created?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string | null
    emailVerified: Date | null
    image: string | null
    secret: string | null
    firstName: string | null
    lastName: string | null
    discordHandle: string | null
    key: string | null
    created: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    secret?: boolean
    firstName?: boolean
    lastName?: boolean
    discordHandle?: boolean
    key?: boolean
    created?: boolean
    postVersionHistory?: boolean | User$postVersionHistoryArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    socials?: boolean | User$socialsArgs<ExtArgs>
    Pathway?: boolean | User$PathwayArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    contentResources?: boolean | User$contentResourcesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    secret?: boolean
    firstName?: boolean
    lastName?: boolean
    discordHandle?: boolean
    key?: boolean
    created?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    secret?: boolean
    firstName?: boolean
    lastName?: boolean
    discordHandle?: boolean
    key?: boolean
    created?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    secret?: boolean
    firstName?: boolean
    lastName?: boolean
    discordHandle?: boolean
    key?: boolean
    created?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "secret" | "firstName" | "lastName" | "discordHandle" | "key" | "created", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postVersionHistory?: boolean | User$postVersionHistoryArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    socials?: boolean | User$socialsArgs<ExtArgs>
    Pathway?: boolean | User$PathwayArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    contentResources?: boolean | User$contentResourcesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      postVersionHistory: Prisma.$PostVersionHistoryPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      roles: Prisma.$UserRolesPayload<ExtArgs>[]
      socials: Prisma.$UserSocialPayload<ExtArgs>[]
      Pathway: Prisma.$PathwayPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
      contentResources: Prisma.$ContentResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      emailVerified: Date | null
      image: string | null
      secret: string | null
      firstName: string | null
      lastName: string | null
      discordHandle: string | null
      key: string | null
      created: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    postVersionHistory<T extends User$postVersionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$postVersionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socials<T extends User$socialsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Pathway<T extends User$PathwayArgs<ExtArgs> = {}>(args?: Subset<T, User$PathwayArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends User$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contentResources<T extends User$contentResourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$contentResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly secret: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly discordHandle: FieldRef<"User", 'String'>
    readonly key: FieldRef<"User", 'String'>
    readonly created: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.postVersionHistory
   */
  export type User$postVersionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    where?: PostVersionHistoryWhereInput
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    cursor?: PostVersionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVersionHistoryScalarFieldEnum | PostVersionHistoryScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    where?: UserRolesWhereInput
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    cursor?: UserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
  }

  /**
   * User.socials
   */
  export type User$socialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    where?: UserSocialWhereInput
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    cursor?: UserSocialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSocialScalarFieldEnum | UserSocialScalarFieldEnum[]
  }

  /**
   * User.Pathway
   */
  export type User$PathwayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * User.resources
   */
  export type User$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.contentResources
   */
  export type User$contentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    where?: ContentResourceWhereInput
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    cursor?: ContentResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model UserSocial
   */

  export type AggregateUserSocial = {
    _count: UserSocialCountAggregateOutputType | null
    _min: UserSocialMinAggregateOutputType | null
    _max: UserSocialMaxAggregateOutputType | null
  }

  export type UserSocialMinAggregateOutputType = {
    userId: string | null
    handle: string | null
    socialCode: string | null
  }

  export type UserSocialMaxAggregateOutputType = {
    userId: string | null
    handle: string | null
    socialCode: string | null
  }

  export type UserSocialCountAggregateOutputType = {
    userId: number
    handle: number
    socialCode: number
    _all: number
  }


  export type UserSocialMinAggregateInputType = {
    userId?: true
    handle?: true
    socialCode?: true
  }

  export type UserSocialMaxAggregateInputType = {
    userId?: true
    handle?: true
    socialCode?: true
  }

  export type UserSocialCountAggregateInputType = {
    userId?: true
    handle?: true
    socialCode?: true
    _all?: true
  }

  export type UserSocialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocial to aggregate.
     */
    where?: UserSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSocials
    **/
    _count?: true | UserSocialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSocialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSocialMaxAggregateInputType
  }

  export type GetUserSocialAggregateType<T extends UserSocialAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSocial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSocial[P]>
      : GetScalarType<T[P], AggregateUserSocial[P]>
  }




  export type UserSocialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSocialWhereInput
    orderBy?: UserSocialOrderByWithAggregationInput | UserSocialOrderByWithAggregationInput[]
    by: UserSocialScalarFieldEnum[] | UserSocialScalarFieldEnum
    having?: UserSocialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSocialCountAggregateInputType | true
    _min?: UserSocialMinAggregateInputType
    _max?: UserSocialMaxAggregateInputType
  }

  export type UserSocialGroupByOutputType = {
    userId: string
    handle: string
    socialCode: string
    _count: UserSocialCountAggregateOutputType | null
    _min: UserSocialMinAggregateOutputType | null
    _max: UserSocialMaxAggregateOutputType | null
  }

  type GetUserSocialGroupByPayload<T extends UserSocialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSocialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSocialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSocialGroupByOutputType[P]>
            : GetScalarType<T[P], UserSocialGroupByOutputType[P]>
        }
      >
    >


  export type UserSocialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    handle?: boolean
    socialCode?: boolean
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocial"]>

  export type UserSocialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    handle?: boolean
    socialCode?: boolean
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocial"]>

  export type UserSocialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    handle?: boolean
    socialCode?: boolean
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSocial"]>

  export type UserSocialSelectScalar = {
    userId?: boolean
    handle?: boolean
    socialCode?: boolean
  }

  export type UserSocialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "handle" | "socialCode", ExtArgs["result"]["userSocial"]>
  export type UserSocialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSocialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSocialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social?: boolean | SocialDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSocialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSocial"
    objects: {
      social: Prisma.$SocialPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      handle: string
      socialCode: string
    }, ExtArgs["result"]["userSocial"]>
    composites: {}
  }

  type UserSocialGetPayload<S extends boolean | null | undefined | UserSocialDefaultArgs> = $Result.GetResult<Prisma.$UserSocialPayload, S>

  type UserSocialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSocialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSocialCountAggregateInputType | true
    }

  export interface UserSocialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSocial'], meta: { name: 'UserSocial' } }
    /**
     * Find zero or one UserSocial that matches the filter.
     * @param {UserSocialFindUniqueArgs} args - Arguments to find a UserSocial
     * @example
     * // Get one UserSocial
     * const userSocial = await prisma.userSocial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSocialFindUniqueArgs>(args: SelectSubset<T, UserSocialFindUniqueArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSocial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSocialFindUniqueOrThrowArgs} args - Arguments to find a UserSocial
     * @example
     * // Get one UserSocial
     * const userSocial = await prisma.userSocial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSocialFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSocialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialFindFirstArgs} args - Arguments to find a UserSocial
     * @example
     * // Get one UserSocial
     * const userSocial = await prisma.userSocial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSocialFindFirstArgs>(args?: SelectSubset<T, UserSocialFindFirstArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSocial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialFindFirstOrThrowArgs} args - Arguments to find a UserSocial
     * @example
     * // Get one UserSocial
     * const userSocial = await prisma.userSocial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSocialFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSocialFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSocials
     * const userSocials = await prisma.userSocial.findMany()
     * 
     * // Get first 10 UserSocials
     * const userSocials = await prisma.userSocial.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSocialWithUserIdOnly = await prisma.userSocial.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSocialFindManyArgs>(args?: SelectSubset<T, UserSocialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSocial.
     * @param {UserSocialCreateArgs} args - Arguments to create a UserSocial.
     * @example
     * // Create one UserSocial
     * const UserSocial = await prisma.userSocial.create({
     *   data: {
     *     // ... data to create a UserSocial
     *   }
     * })
     * 
     */
    create<T extends UserSocialCreateArgs>(args: SelectSubset<T, UserSocialCreateArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSocials.
     * @param {UserSocialCreateManyArgs} args - Arguments to create many UserSocials.
     * @example
     * // Create many UserSocials
     * const userSocial = await prisma.userSocial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSocialCreateManyArgs>(args?: SelectSubset<T, UserSocialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSocials and returns the data saved in the database.
     * @param {UserSocialCreateManyAndReturnArgs} args - Arguments to create many UserSocials.
     * @example
     * // Create many UserSocials
     * const userSocial = await prisma.userSocial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSocials and only return the `userId`
     * const userSocialWithUserIdOnly = await prisma.userSocial.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSocialCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSocialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSocial.
     * @param {UserSocialDeleteArgs} args - Arguments to delete one UserSocial.
     * @example
     * // Delete one UserSocial
     * const UserSocial = await prisma.userSocial.delete({
     *   where: {
     *     // ... filter to delete one UserSocial
     *   }
     * })
     * 
     */
    delete<T extends UserSocialDeleteArgs>(args: SelectSubset<T, UserSocialDeleteArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSocial.
     * @param {UserSocialUpdateArgs} args - Arguments to update one UserSocial.
     * @example
     * // Update one UserSocial
     * const userSocial = await prisma.userSocial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSocialUpdateArgs>(args: SelectSubset<T, UserSocialUpdateArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSocials.
     * @param {UserSocialDeleteManyArgs} args - Arguments to filter UserSocials to delete.
     * @example
     * // Delete a few UserSocials
     * const { count } = await prisma.userSocial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSocialDeleteManyArgs>(args?: SelectSubset<T, UserSocialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSocials
     * const userSocial = await prisma.userSocial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSocialUpdateManyArgs>(args: SelectSubset<T, UserSocialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocials and returns the data updated in the database.
     * @param {UserSocialUpdateManyAndReturnArgs} args - Arguments to update many UserSocials.
     * @example
     * // Update many UserSocials
     * const userSocial = await prisma.userSocial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSocials and only return the `userId`
     * const userSocialWithUserIdOnly = await prisma.userSocial.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSocialUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSocialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSocial.
     * @param {UserSocialUpsertArgs} args - Arguments to update or create a UserSocial.
     * @example
     * // Update or create a UserSocial
     * const userSocial = await prisma.userSocial.upsert({
     *   create: {
     *     // ... data to create a UserSocial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSocial we want to update
     *   }
     * })
     */
    upsert<T extends UserSocialUpsertArgs>(args: SelectSubset<T, UserSocialUpsertArgs<ExtArgs>>): Prisma__UserSocialClient<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialCountArgs} args - Arguments to filter UserSocials to count.
     * @example
     * // Count the number of UserSocials
     * const count = await prisma.userSocial.count({
     *   where: {
     *     // ... the filter for the UserSocials we want to count
     *   }
     * })
    **/
    count<T extends UserSocialCountArgs>(
      args?: Subset<T, UserSocialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSocialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSocialAggregateArgs>(args: Subset<T, UserSocialAggregateArgs>): Prisma.PrismaPromise<GetUserSocialAggregateType<T>>

    /**
     * Group by UserSocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSocialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSocialGroupByArgs['orderBy'] }
        : { orderBy?: UserSocialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSocialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSocialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSocial model
   */
  readonly fields: UserSocialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSocial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSocialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    social<T extends SocialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialDefaultArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSocial model
   */
  interface UserSocialFieldRefs {
    readonly userId: FieldRef<"UserSocial", 'String'>
    readonly handle: FieldRef<"UserSocial", 'String'>
    readonly socialCode: FieldRef<"UserSocial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSocial findUnique
   */
  export type UserSocialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter, which UserSocial to fetch.
     */
    where: UserSocialWhereUniqueInput
  }

  /**
   * UserSocial findUniqueOrThrow
   */
  export type UserSocialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter, which UserSocial to fetch.
     */
    where: UserSocialWhereUniqueInput
  }

  /**
   * UserSocial findFirst
   */
  export type UserSocialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter, which UserSocial to fetch.
     */
    where?: UserSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocials.
     */
    cursor?: UserSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocials.
     */
    distinct?: UserSocialScalarFieldEnum | UserSocialScalarFieldEnum[]
  }

  /**
   * UserSocial findFirstOrThrow
   */
  export type UserSocialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter, which UserSocial to fetch.
     */
    where?: UserSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocials.
     */
    cursor?: UserSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocials.
     */
    distinct?: UserSocialScalarFieldEnum | UserSocialScalarFieldEnum[]
  }

  /**
   * UserSocial findMany
   */
  export type UserSocialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter, which UserSocials to fetch.
     */
    where?: UserSocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocials to fetch.
     */
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSocials.
     */
    cursor?: UserSocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocials.
     */
    skip?: number
    distinct?: UserSocialScalarFieldEnum | UserSocialScalarFieldEnum[]
  }

  /**
   * UserSocial create
   */
  export type UserSocialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSocial.
     */
    data: XOR<UserSocialCreateInput, UserSocialUncheckedCreateInput>
  }

  /**
   * UserSocial createMany
   */
  export type UserSocialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSocials.
     */
    data: UserSocialCreateManyInput | UserSocialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSocial createManyAndReturn
   */
  export type UserSocialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * The data used to create many UserSocials.
     */
    data: UserSocialCreateManyInput | UserSocialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocial update
   */
  export type UserSocialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSocial.
     */
    data: XOR<UserSocialUpdateInput, UserSocialUncheckedUpdateInput>
    /**
     * Choose, which UserSocial to update.
     */
    where: UserSocialWhereUniqueInput
  }

  /**
   * UserSocial updateMany
   */
  export type UserSocialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSocials.
     */
    data: XOR<UserSocialUpdateManyMutationInput, UserSocialUncheckedUpdateManyInput>
    /**
     * Filter which UserSocials to update
     */
    where?: UserSocialWhereInput
    /**
     * Limit how many UserSocials to update.
     */
    limit?: number
  }

  /**
   * UserSocial updateManyAndReturn
   */
  export type UserSocialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * The data used to update UserSocials.
     */
    data: XOR<UserSocialUpdateManyMutationInput, UserSocialUncheckedUpdateManyInput>
    /**
     * Filter which UserSocials to update
     */
    where?: UserSocialWhereInput
    /**
     * Limit how many UserSocials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSocial upsert
   */
  export type UserSocialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSocial to update in case it exists.
     */
    where: UserSocialWhereUniqueInput
    /**
     * In case the UserSocial found by the `where` argument doesn't exist, create a new UserSocial with this data.
     */
    create: XOR<UserSocialCreateInput, UserSocialUncheckedCreateInput>
    /**
     * In case the UserSocial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSocialUpdateInput, UserSocialUncheckedUpdateInput>
  }

  /**
   * UserSocial delete
   */
  export type UserSocialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    /**
     * Filter which UserSocial to delete.
     */
    where: UserSocialWhereUniqueInput
  }

  /**
   * UserSocial deleteMany
   */
  export type UserSocialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSocials to delete
     */
    where?: UserSocialWhereInput
    /**
     * Limit how many UserSocials to delete.
     */
    limit?: number
  }

  /**
   * UserSocial without action
   */
  export type UserSocialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
  }


  /**
   * Model UserRoles
   */

  export type AggregateUserRoles = {
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  export type UserRolesAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserRolesSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserRolesMinAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type UserRolesMaxAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type UserRolesCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRolesAvgAggregateInputType = {
    roleId?: true
  }

  export type UserRolesSumAggregateInputType = {
    roleId?: true
  }

  export type UserRolesMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRolesMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRolesCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to aggregate.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRolesMaxAggregateInputType
  }

  export type GetUserRolesAggregateType<T extends UserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoles[P]>
      : GetScalarType<T[P], AggregateUserRoles[P]>
  }




  export type UserRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRolesWhereInput
    orderBy?: UserRolesOrderByWithAggregationInput | UserRolesOrderByWithAggregationInput[]
    by: UserRolesScalarFieldEnum[] | UserRolesScalarFieldEnum
    having?: UserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRolesCountAggregateInputType | true
    _avg?: UserRolesAvgAggregateInputType
    _sum?: UserRolesSumAggregateInputType
    _min?: UserRolesMinAggregateInputType
    _max?: UserRolesMaxAggregateInputType
  }

  export type UserRolesGroupByOutputType = {
    userId: string
    roleId: number
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  type GetUserRolesGroupByPayload<T extends UserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoles"]>

  export type UserRolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoles"]>

  export type UserRolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoles"]>

  export type UserRolesSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRoles"]>
  export type UserRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolesDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoles"
    objects: {
      role: Prisma.$RolesPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: number
    }, ExtArgs["result"]["userRoles"]>
    composites: {}
  }

  type UserRolesGetPayload<S extends boolean | null | undefined | UserRolesDefaultArgs> = $Result.GetResult<Prisma.$UserRolesPayload, S>

  type UserRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRolesCountAggregateInputType | true
    }

  export interface UserRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoles'], meta: { name: 'UserRoles' } }
    /**
     * Find zero or one UserRoles that matches the filter.
     * @param {UserRolesFindUniqueArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRolesFindUniqueArgs>(args: SelectSubset<T, UserRolesFindUniqueArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRolesFindUniqueOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRolesFindFirstArgs>(args?: SelectSubset<T, UserRolesFindFirstArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRoles.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRoles.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRolesWithUserIdOnly = await prisma.userRoles.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRolesFindManyArgs>(args?: SelectSubset<T, UserRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRoles.
     * @param {UserRolesCreateArgs} args - Arguments to create a UserRoles.
     * @example
     * // Create one UserRoles
     * const UserRoles = await prisma.userRoles.create({
     *   data: {
     *     // ... data to create a UserRoles
     *   }
     * })
     * 
     */
    create<T extends UserRolesCreateArgs>(args: SelectSubset<T, UserRolesCreateArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRolesCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRoles = await prisma.userRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRolesCreateManyArgs>(args?: SelectSubset<T, UserRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRolesCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRoles = await prisma.userRoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRolesWithUserIdOnly = await prisma.userRoles.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRolesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRoles.
     * @param {UserRolesDeleteArgs} args - Arguments to delete one UserRoles.
     * @example
     * // Delete one UserRoles
     * const UserRoles = await prisma.userRoles.delete({
     *   where: {
     *     // ... filter to delete one UserRoles
     *   }
     * })
     * 
     */
    delete<T extends UserRolesDeleteArgs>(args: SelectSubset<T, UserRolesDeleteArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRoles.
     * @param {UserRolesUpdateArgs} args - Arguments to update one UserRoles.
     * @example
     * // Update one UserRoles
     * const userRoles = await prisma.userRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRolesUpdateArgs>(args: SelectSubset<T, UserRolesUpdateArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRolesDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRolesDeleteManyArgs>(args?: SelectSubset<T, UserRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRoles = await prisma.userRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRolesUpdateManyArgs>(args: SelectSubset<T, UserRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRolesUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRoles = await prisma.userRoles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRolesWithUserIdOnly = await prisma.userRoles.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRolesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRoles.
     * @param {UserRolesUpsertArgs} args - Arguments to update or create a UserRoles.
     * @example
     * // Update or create a UserRoles
     * const userRoles = await prisma.userRoles.upsert({
     *   create: {
     *     // ... data to create a UserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoles we want to update
     *   }
     * })
     */
    upsert<T extends UserRolesUpsertArgs>(args: SelectSubset<T, UserRolesUpsertArgs<ExtArgs>>): Prisma__UserRolesClient<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRoles.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRolesCountArgs>(
      args?: Subset<T, UserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRolesAggregateArgs>(args: Subset<T, UserRolesAggregateArgs>): Prisma.PrismaPromise<GetUserRolesAggregateType<T>>

    /**
     * Group by UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoles model
   */
  readonly fields: UserRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolesDefaultArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoles model
   */
  interface UserRolesFieldRefs {
    readonly userId: FieldRef<"UserRoles", 'String'>
    readonly roleId: FieldRef<"UserRoles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRoles findUnique
   */
  export type UserRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
  }

  /**
   * UserRoles findUniqueOrThrow
   */
  export type UserRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
  }

  /**
   * UserRoles findFirst
   */
  export type UserRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
  }

  /**
   * UserRoles findFirstOrThrow
   */
  export type UserRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
  }

  /**
   * UserRoles findMany
   */
  export type UserRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
  }

  /**
   * UserRoles create
   */
  export type UserRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoles.
     */
    data: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
  }

  /**
   * UserRoles createMany
   */
  export type UserRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRolesCreateManyInput | UserRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoles createManyAndReturn
   */
  export type UserRolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRolesCreateManyInput | UserRolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoles update
   */
  export type UserRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoles.
     */
    data: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
    /**
     * Choose, which UserRoles to update.
     */
    where: UserRolesWhereUniqueInput
  }

  /**
   * UserRoles updateMany
   */
  export type UserRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRolesWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRoles updateManyAndReturn
   */
  export type UserRolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRolesWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoles upsert
   */
  export type UserRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoles to update in case it exists.
     */
    where: UserRolesWhereUniqueInput
    /**
     * In case the UserRoles found by the `where` argument doesn't exist, create a new UserRoles with this data.
     */
    create: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
    /**
     * In case the UserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
  }

  /**
   * UserRoles delete
   */
  export type UserRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    /**
     * Filter which UserRoles to delete.
     */
    where: UserRolesWhereUniqueInput
  }

  /**
   * UserRoles deleteMany
   */
  export type UserRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRolesWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRoles without action
   */
  export type UserRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    UserRoles?: boolean | Roles$UserRolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRoles?: boolean | Roles$UserRolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      UserRoles: Prisma.$UserRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserRoles<T extends Roles$UserRolesArgs<ExtArgs> = {}>(args?: Subset<T, Roles$UserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly name: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles.UserRoles
   */
  export type Roles$UserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoles
     */
    omit?: UserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRolesInclude<ExtArgs> | null
    where?: UserRolesWhereInput
    orderBy?: UserRolesOrderByWithRelationInput | UserRolesOrderByWithRelationInput[]
    cursor?: UserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRolesScalarFieldEnum | UserRolesScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Social
   */

  export type AggregateSocial = {
    _count: SocialCountAggregateOutputType | null
    _min: SocialMinAggregateOutputType | null
    _max: SocialMaxAggregateOutputType | null
  }

  export type SocialMinAggregateOutputType = {
    name: string | null
    url: string | null
    icon: string | null
    codeName: string | null
    profileLinkFormat: string | null
    profileEntryFormat: string | null
    darkModeColor: string | null
    lightModeColor: string | null
  }

  export type SocialMaxAggregateOutputType = {
    name: string | null
    url: string | null
    icon: string | null
    codeName: string | null
    profileLinkFormat: string | null
    profileEntryFormat: string | null
    darkModeColor: string | null
    lightModeColor: string | null
  }

  export type SocialCountAggregateOutputType = {
    name: number
    url: number
    icon: number
    codeName: number
    profileLinkFormat: number
    profileEntryFormat: number
    darkModeColor: number
    lightModeColor: number
    _all: number
  }


  export type SocialMinAggregateInputType = {
    name?: true
    url?: true
    icon?: true
    codeName?: true
    profileLinkFormat?: true
    profileEntryFormat?: true
    darkModeColor?: true
    lightModeColor?: true
  }

  export type SocialMaxAggregateInputType = {
    name?: true
    url?: true
    icon?: true
    codeName?: true
    profileLinkFormat?: true
    profileEntryFormat?: true
    darkModeColor?: true
    lightModeColor?: true
  }

  export type SocialCountAggregateInputType = {
    name?: true
    url?: true
    icon?: true
    codeName?: true
    profileLinkFormat?: true
    profileEntryFormat?: true
    darkModeColor?: true
    lightModeColor?: true
    _all?: true
  }

  export type SocialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Social to aggregate.
     */
    where?: SocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialOrderByWithRelationInput | SocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Socials
    **/
    _count?: true | SocialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMaxAggregateInputType
  }

  export type GetSocialAggregateType<T extends SocialAggregateArgs> = {
        [P in keyof T & keyof AggregateSocial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocial[P]>
      : GetScalarType<T[P], AggregateSocial[P]>
  }




  export type SocialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialWhereInput
    orderBy?: SocialOrderByWithAggregationInput | SocialOrderByWithAggregationInput[]
    by: SocialScalarFieldEnum[] | SocialScalarFieldEnum
    having?: SocialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialCountAggregateInputType | true
    _min?: SocialMinAggregateInputType
    _max?: SocialMaxAggregateInputType
  }

  export type SocialGroupByOutputType = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
    _count: SocialCountAggregateOutputType | null
    _min: SocialMinAggregateOutputType | null
    _max: SocialMaxAggregateOutputType | null
  }

  type GetSocialGroupByPayload<T extends SocialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialGroupByOutputType[P]>
            : GetScalarType<T[P], SocialGroupByOutputType[P]>
        }
      >
    >


  export type SocialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    url?: boolean
    icon?: boolean
    codeName?: boolean
    profileLinkFormat?: boolean
    profileEntryFormat?: boolean
    darkModeColor?: boolean
    lightModeColor?: boolean
    users?: boolean | Social$usersArgs<ExtArgs>
    _count?: boolean | SocialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["social"]>

  export type SocialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    url?: boolean
    icon?: boolean
    codeName?: boolean
    profileLinkFormat?: boolean
    profileEntryFormat?: boolean
    darkModeColor?: boolean
    lightModeColor?: boolean
  }, ExtArgs["result"]["social"]>

  export type SocialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    url?: boolean
    icon?: boolean
    codeName?: boolean
    profileLinkFormat?: boolean
    profileEntryFormat?: boolean
    darkModeColor?: boolean
    lightModeColor?: boolean
  }, ExtArgs["result"]["social"]>

  export type SocialSelectScalar = {
    name?: boolean
    url?: boolean
    icon?: boolean
    codeName?: boolean
    profileLinkFormat?: boolean
    profileEntryFormat?: boolean
    darkModeColor?: boolean
    lightModeColor?: boolean
  }

  export type SocialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "url" | "icon" | "codeName" | "profileLinkFormat" | "profileEntryFormat" | "darkModeColor" | "lightModeColor", ExtArgs["result"]["social"]>
  export type SocialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Social$usersArgs<ExtArgs>
    _count?: boolean | SocialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SocialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SocialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SocialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Social"
    objects: {
      users: Prisma.$UserSocialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      url: string
      icon: string
      codeName: string
      profileLinkFormat: string
      profileEntryFormat: string
      darkModeColor: string
      lightModeColor: string
    }, ExtArgs["result"]["social"]>
    composites: {}
  }

  type SocialGetPayload<S extends boolean | null | undefined | SocialDefaultArgs> = $Result.GetResult<Prisma.$SocialPayload, S>

  type SocialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialCountAggregateInputType | true
    }

  export interface SocialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Social'], meta: { name: 'Social' } }
    /**
     * Find zero or one Social that matches the filter.
     * @param {SocialFindUniqueArgs} args - Arguments to find a Social
     * @example
     * // Get one Social
     * const social = await prisma.social.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialFindUniqueArgs>(args: SelectSubset<T, SocialFindUniqueArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Social that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialFindUniqueOrThrowArgs} args - Arguments to find a Social
     * @example
     * // Get one Social
     * const social = await prisma.social.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFindFirstArgs} args - Arguments to find a Social
     * @example
     * // Get one Social
     * const social = await prisma.social.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialFindFirstArgs>(args?: SelectSubset<T, SocialFindFirstArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Social that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFindFirstOrThrowArgs} args - Arguments to find a Social
     * @example
     * // Get one Social
     * const social = await prisma.social.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Socials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Socials
     * const socials = await prisma.social.findMany()
     * 
     * // Get first 10 Socials
     * const socials = await prisma.social.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const socialWithNameOnly = await prisma.social.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends SocialFindManyArgs>(args?: SelectSubset<T, SocialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Social.
     * @param {SocialCreateArgs} args - Arguments to create a Social.
     * @example
     * // Create one Social
     * const Social = await prisma.social.create({
     *   data: {
     *     // ... data to create a Social
     *   }
     * })
     * 
     */
    create<T extends SocialCreateArgs>(args: SelectSubset<T, SocialCreateArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Socials.
     * @param {SocialCreateManyArgs} args - Arguments to create many Socials.
     * @example
     * // Create many Socials
     * const social = await prisma.social.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialCreateManyArgs>(args?: SelectSubset<T, SocialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Socials and returns the data saved in the database.
     * @param {SocialCreateManyAndReturnArgs} args - Arguments to create many Socials.
     * @example
     * // Create many Socials
     * const social = await prisma.social.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Socials and only return the `name`
     * const socialWithNameOnly = await prisma.social.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Social.
     * @param {SocialDeleteArgs} args - Arguments to delete one Social.
     * @example
     * // Delete one Social
     * const Social = await prisma.social.delete({
     *   where: {
     *     // ... filter to delete one Social
     *   }
     * })
     * 
     */
    delete<T extends SocialDeleteArgs>(args: SelectSubset<T, SocialDeleteArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Social.
     * @param {SocialUpdateArgs} args - Arguments to update one Social.
     * @example
     * // Update one Social
     * const social = await prisma.social.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialUpdateArgs>(args: SelectSubset<T, SocialUpdateArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Socials.
     * @param {SocialDeleteManyArgs} args - Arguments to filter Socials to delete.
     * @example
     * // Delete a few Socials
     * const { count } = await prisma.social.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialDeleteManyArgs>(args?: SelectSubset<T, SocialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Socials
     * const social = await prisma.social.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialUpdateManyArgs>(args: SelectSubset<T, SocialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Socials and returns the data updated in the database.
     * @param {SocialUpdateManyAndReturnArgs} args - Arguments to update many Socials.
     * @example
     * // Update many Socials
     * const social = await prisma.social.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Socials and only return the `name`
     * const socialWithNameOnly = await prisma.social.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Social.
     * @param {SocialUpsertArgs} args - Arguments to update or create a Social.
     * @example
     * // Update or create a Social
     * const social = await prisma.social.upsert({
     *   create: {
     *     // ... data to create a Social
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Social we want to update
     *   }
     * })
     */
    upsert<T extends SocialUpsertArgs>(args: SelectSubset<T, SocialUpsertArgs<ExtArgs>>): Prisma__SocialClient<$Result.GetResult<Prisma.$SocialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Socials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialCountArgs} args - Arguments to filter Socials to count.
     * @example
     * // Count the number of Socials
     * const count = await prisma.social.count({
     *   where: {
     *     // ... the filter for the Socials we want to count
     *   }
     * })
    **/
    count<T extends SocialCountArgs>(
      args?: Subset<T, SocialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Social.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialAggregateArgs>(args: Subset<T, SocialAggregateArgs>): Prisma.PrismaPromise<GetSocialAggregateType<T>>

    /**
     * Group by Social.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialGroupByArgs['orderBy'] }
        : { orderBy?: SocialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Social model
   */
  readonly fields: SocialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Social.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Social$usersArgs<ExtArgs> = {}>(args?: Subset<T, Social$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSocialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Social model
   */
  interface SocialFieldRefs {
    readonly name: FieldRef<"Social", 'String'>
    readonly url: FieldRef<"Social", 'String'>
    readonly icon: FieldRef<"Social", 'String'>
    readonly codeName: FieldRef<"Social", 'String'>
    readonly profileLinkFormat: FieldRef<"Social", 'String'>
    readonly profileEntryFormat: FieldRef<"Social", 'String'>
    readonly darkModeColor: FieldRef<"Social", 'String'>
    readonly lightModeColor: FieldRef<"Social", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Social findUnique
   */
  export type SocialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter, which Social to fetch.
     */
    where: SocialWhereUniqueInput
  }

  /**
   * Social findUniqueOrThrow
   */
  export type SocialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter, which Social to fetch.
     */
    where: SocialWhereUniqueInput
  }

  /**
   * Social findFirst
   */
  export type SocialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter, which Social to fetch.
     */
    where?: SocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialOrderByWithRelationInput | SocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Socials.
     */
    cursor?: SocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Socials.
     */
    distinct?: SocialScalarFieldEnum | SocialScalarFieldEnum[]
  }

  /**
   * Social findFirstOrThrow
   */
  export type SocialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter, which Social to fetch.
     */
    where?: SocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialOrderByWithRelationInput | SocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Socials.
     */
    cursor?: SocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Socials.
     */
    distinct?: SocialScalarFieldEnum | SocialScalarFieldEnum[]
  }

  /**
   * Social findMany
   */
  export type SocialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter, which Socials to fetch.
     */
    where?: SocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Socials to fetch.
     */
    orderBy?: SocialOrderByWithRelationInput | SocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Socials.
     */
    cursor?: SocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Socials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Socials.
     */
    skip?: number
    distinct?: SocialScalarFieldEnum | SocialScalarFieldEnum[]
  }

  /**
   * Social create
   */
  export type SocialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * The data needed to create a Social.
     */
    data: XOR<SocialCreateInput, SocialUncheckedCreateInput>
  }

  /**
   * Social createMany
   */
  export type SocialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Socials.
     */
    data: SocialCreateManyInput | SocialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Social createManyAndReturn
   */
  export type SocialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * The data used to create many Socials.
     */
    data: SocialCreateManyInput | SocialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Social update
   */
  export type SocialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * The data needed to update a Social.
     */
    data: XOR<SocialUpdateInput, SocialUncheckedUpdateInput>
    /**
     * Choose, which Social to update.
     */
    where: SocialWhereUniqueInput
  }

  /**
   * Social updateMany
   */
  export type SocialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Socials.
     */
    data: XOR<SocialUpdateManyMutationInput, SocialUncheckedUpdateManyInput>
    /**
     * Filter which Socials to update
     */
    where?: SocialWhereInput
    /**
     * Limit how many Socials to update.
     */
    limit?: number
  }

  /**
   * Social updateManyAndReturn
   */
  export type SocialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * The data used to update Socials.
     */
    data: XOR<SocialUpdateManyMutationInput, SocialUncheckedUpdateManyInput>
    /**
     * Filter which Socials to update
     */
    where?: SocialWhereInput
    /**
     * Limit how many Socials to update.
     */
    limit?: number
  }

  /**
   * Social upsert
   */
  export type SocialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * The filter to search for the Social to update in case it exists.
     */
    where: SocialWhereUniqueInput
    /**
     * In case the Social found by the `where` argument doesn't exist, create a new Social with this data.
     */
    create: XOR<SocialCreateInput, SocialUncheckedCreateInput>
    /**
     * In case the Social was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialUpdateInput, SocialUncheckedUpdateInput>
  }

  /**
   * Social delete
   */
  export type SocialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
    /**
     * Filter which Social to delete.
     */
    where: SocialWhereUniqueInput
  }

  /**
   * Social deleteMany
   */
  export type SocialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Socials to delete
     */
    where?: SocialWhereInput
    /**
     * Limit how many Socials to delete.
     */
    limit?: number
  }

  /**
   * Social.users
   */
  export type Social$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSocial
     */
    select?: UserSocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSocial
     */
    omit?: UserSocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSocialInclude<ExtArgs> | null
    where?: UserSocialWhereInput
    orderBy?: UserSocialOrderByWithRelationInput | UserSocialOrderByWithRelationInput[]
    cursor?: UserSocialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSocialScalarFieldEnum | UserSocialScalarFieldEnum[]
  }

  /**
   * Social without action
   */
  export type SocialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Social
     */
    select?: SocialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Social
     */
    omit?: SocialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialInclude<ExtArgs> | null
  }


  /**
   * Model PostVersionHistory
   */

  export type AggregatePostVersionHistory = {
    _count: PostVersionHistoryCountAggregateOutputType | null
    _avg: PostVersionHistoryAvgAggregateOutputType | null
    _sum: PostVersionHistorySumAggregateOutputType | null
    _min: PostVersionHistoryMinAggregateOutputType | null
    _max: PostVersionHistoryMaxAggregateOutputType | null
  }

  export type PostVersionHistoryAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type PostVersionHistorySumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type PostVersionHistoryMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: string | null
    action: string | null
    instanceAt: Date | null
  }

  export type PostVersionHistoryMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: string | null
    action: string | null
    instanceAt: Date | null
  }

  export type PostVersionHistoryCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    action: number
    instanceAt: number
    _all: number
  }


  export type PostVersionHistoryAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type PostVersionHistorySumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type PostVersionHistoryMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    action?: true
    instanceAt?: true
  }

  export type PostVersionHistoryMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    action?: true
    instanceAt?: true
  }

  export type PostVersionHistoryCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    action?: true
    instanceAt?: true
    _all?: true
  }

  export type PostVersionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVersionHistory to aggregate.
     */
    where?: PostVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersionHistories to fetch.
     */
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostVersionHistories
    **/
    _count?: true | PostVersionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostVersionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostVersionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostVersionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostVersionHistoryMaxAggregateInputType
  }

  export type GetPostVersionHistoryAggregateType<T extends PostVersionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePostVersionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostVersionHistory[P]>
      : GetScalarType<T[P], AggregatePostVersionHistory[P]>
  }




  export type PostVersionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVersionHistoryWhereInput
    orderBy?: PostVersionHistoryOrderByWithAggregationInput | PostVersionHistoryOrderByWithAggregationInput[]
    by: PostVersionHistoryScalarFieldEnum[] | PostVersionHistoryScalarFieldEnum
    having?: PostVersionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostVersionHistoryCountAggregateInputType | true
    _avg?: PostVersionHistoryAvgAggregateInputType
    _sum?: PostVersionHistorySumAggregateInputType
    _min?: PostVersionHistoryMinAggregateInputType
    _max?: PostVersionHistoryMaxAggregateInputType
  }

  export type PostVersionHistoryGroupByOutputType = {
    id: number
    postId: number
    userId: string
    action: string
    instanceAt: Date
    _count: PostVersionHistoryCountAggregateOutputType | null
    _avg: PostVersionHistoryAvgAggregateOutputType | null
    _sum: PostVersionHistorySumAggregateOutputType | null
    _min: PostVersionHistoryMinAggregateOutputType | null
    _max: PostVersionHistoryMaxAggregateOutputType | null
  }

  type GetPostVersionHistoryGroupByPayload<T extends PostVersionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostVersionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostVersionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostVersionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PostVersionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PostVersionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    action?: boolean
    instanceAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersionHistory"]>

  export type PostVersionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    action?: boolean
    instanceAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersionHistory"]>

  export type PostVersionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    action?: boolean
    instanceAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVersionHistory"]>

  export type PostVersionHistorySelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    action?: boolean
    instanceAt?: boolean
  }

  export type PostVersionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "action" | "instanceAt", ExtArgs["result"]["postVersionHistory"]>
  export type PostVersionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostVersionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostVersionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostVersionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostVersionHistory"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: string
      action: string
      instanceAt: Date
    }, ExtArgs["result"]["postVersionHistory"]>
    composites: {}
  }

  type PostVersionHistoryGetPayload<S extends boolean | null | undefined | PostVersionHistoryDefaultArgs> = $Result.GetResult<Prisma.$PostVersionHistoryPayload, S>

  type PostVersionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostVersionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostVersionHistoryCountAggregateInputType | true
    }

  export interface PostVersionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostVersionHistory'], meta: { name: 'PostVersionHistory' } }
    /**
     * Find zero or one PostVersionHistory that matches the filter.
     * @param {PostVersionHistoryFindUniqueArgs} args - Arguments to find a PostVersionHistory
     * @example
     * // Get one PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostVersionHistoryFindUniqueArgs>(args: SelectSubset<T, PostVersionHistoryFindUniqueArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostVersionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostVersionHistoryFindUniqueOrThrowArgs} args - Arguments to find a PostVersionHistory
     * @example
     * // Get one PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostVersionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PostVersionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVersionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryFindFirstArgs} args - Arguments to find a PostVersionHistory
     * @example
     * // Get one PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostVersionHistoryFindFirstArgs>(args?: SelectSubset<T, PostVersionHistoryFindFirstArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVersionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryFindFirstOrThrowArgs} args - Arguments to find a PostVersionHistory
     * @example
     * // Get one PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostVersionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PostVersionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostVersionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostVersionHistories
     * const postVersionHistories = await prisma.postVersionHistory.findMany()
     * 
     * // Get first 10 PostVersionHistories
     * const postVersionHistories = await prisma.postVersionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postVersionHistoryWithIdOnly = await prisma.postVersionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostVersionHistoryFindManyArgs>(args?: SelectSubset<T, PostVersionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostVersionHistory.
     * @param {PostVersionHistoryCreateArgs} args - Arguments to create a PostVersionHistory.
     * @example
     * // Create one PostVersionHistory
     * const PostVersionHistory = await prisma.postVersionHistory.create({
     *   data: {
     *     // ... data to create a PostVersionHistory
     *   }
     * })
     * 
     */
    create<T extends PostVersionHistoryCreateArgs>(args: SelectSubset<T, PostVersionHistoryCreateArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostVersionHistories.
     * @param {PostVersionHistoryCreateManyArgs} args - Arguments to create many PostVersionHistories.
     * @example
     * // Create many PostVersionHistories
     * const postVersionHistory = await prisma.postVersionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostVersionHistoryCreateManyArgs>(args?: SelectSubset<T, PostVersionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostVersionHistories and returns the data saved in the database.
     * @param {PostVersionHistoryCreateManyAndReturnArgs} args - Arguments to create many PostVersionHistories.
     * @example
     * // Create many PostVersionHistories
     * const postVersionHistory = await prisma.postVersionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostVersionHistories and only return the `id`
     * const postVersionHistoryWithIdOnly = await prisma.postVersionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostVersionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PostVersionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostVersionHistory.
     * @param {PostVersionHistoryDeleteArgs} args - Arguments to delete one PostVersionHistory.
     * @example
     * // Delete one PostVersionHistory
     * const PostVersionHistory = await prisma.postVersionHistory.delete({
     *   where: {
     *     // ... filter to delete one PostVersionHistory
     *   }
     * })
     * 
     */
    delete<T extends PostVersionHistoryDeleteArgs>(args: SelectSubset<T, PostVersionHistoryDeleteArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostVersionHistory.
     * @param {PostVersionHistoryUpdateArgs} args - Arguments to update one PostVersionHistory.
     * @example
     * // Update one PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostVersionHistoryUpdateArgs>(args: SelectSubset<T, PostVersionHistoryUpdateArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostVersionHistories.
     * @param {PostVersionHistoryDeleteManyArgs} args - Arguments to filter PostVersionHistories to delete.
     * @example
     * // Delete a few PostVersionHistories
     * const { count } = await prisma.postVersionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostVersionHistoryDeleteManyArgs>(args?: SelectSubset<T, PostVersionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVersionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostVersionHistories
     * const postVersionHistory = await prisma.postVersionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostVersionHistoryUpdateManyArgs>(args: SelectSubset<T, PostVersionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVersionHistories and returns the data updated in the database.
     * @param {PostVersionHistoryUpdateManyAndReturnArgs} args - Arguments to update many PostVersionHistories.
     * @example
     * // Update many PostVersionHistories
     * const postVersionHistory = await prisma.postVersionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostVersionHistories and only return the `id`
     * const postVersionHistoryWithIdOnly = await prisma.postVersionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostVersionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PostVersionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostVersionHistory.
     * @param {PostVersionHistoryUpsertArgs} args - Arguments to update or create a PostVersionHistory.
     * @example
     * // Update or create a PostVersionHistory
     * const postVersionHistory = await prisma.postVersionHistory.upsert({
     *   create: {
     *     // ... data to create a PostVersionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostVersionHistory we want to update
     *   }
     * })
     */
    upsert<T extends PostVersionHistoryUpsertArgs>(args: SelectSubset<T, PostVersionHistoryUpsertArgs<ExtArgs>>): Prisma__PostVersionHistoryClient<$Result.GetResult<Prisma.$PostVersionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostVersionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryCountArgs} args - Arguments to filter PostVersionHistories to count.
     * @example
     * // Count the number of PostVersionHistories
     * const count = await prisma.postVersionHistory.count({
     *   where: {
     *     // ... the filter for the PostVersionHistories we want to count
     *   }
     * })
    **/
    count<T extends PostVersionHistoryCountArgs>(
      args?: Subset<T, PostVersionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostVersionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostVersionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostVersionHistoryAggregateArgs>(args: Subset<T, PostVersionHistoryAggregateArgs>): Prisma.PrismaPromise<GetPostVersionHistoryAggregateType<T>>

    /**
     * Group by PostVersionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVersionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostVersionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostVersionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PostVersionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostVersionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostVersionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostVersionHistory model
   */
  readonly fields: PostVersionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostVersionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostVersionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostVersionHistory model
   */
  interface PostVersionHistoryFieldRefs {
    readonly id: FieldRef<"PostVersionHistory", 'Int'>
    readonly postId: FieldRef<"PostVersionHistory", 'Int'>
    readonly userId: FieldRef<"PostVersionHistory", 'String'>
    readonly action: FieldRef<"PostVersionHistory", 'String'>
    readonly instanceAt: FieldRef<"PostVersionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostVersionHistory findUnique
   */
  export type PostVersionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PostVersionHistory to fetch.
     */
    where: PostVersionHistoryWhereUniqueInput
  }

  /**
   * PostVersionHistory findUniqueOrThrow
   */
  export type PostVersionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PostVersionHistory to fetch.
     */
    where: PostVersionHistoryWhereUniqueInput
  }

  /**
   * PostVersionHistory findFirst
   */
  export type PostVersionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PostVersionHistory to fetch.
     */
    where?: PostVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersionHistories to fetch.
     */
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVersionHistories.
     */
    cursor?: PostVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVersionHistories.
     */
    distinct?: PostVersionHistoryScalarFieldEnum | PostVersionHistoryScalarFieldEnum[]
  }

  /**
   * PostVersionHistory findFirstOrThrow
   */
  export type PostVersionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PostVersionHistory to fetch.
     */
    where?: PostVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersionHistories to fetch.
     */
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVersionHistories.
     */
    cursor?: PostVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVersionHistories.
     */
    distinct?: PostVersionHistoryScalarFieldEnum | PostVersionHistoryScalarFieldEnum[]
  }

  /**
   * PostVersionHistory findMany
   */
  export type PostVersionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PostVersionHistories to fetch.
     */
    where?: PostVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVersionHistories to fetch.
     */
    orderBy?: PostVersionHistoryOrderByWithRelationInput | PostVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostVersionHistories.
     */
    cursor?: PostVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVersionHistories.
     */
    skip?: number
    distinct?: PostVersionHistoryScalarFieldEnum | PostVersionHistoryScalarFieldEnum[]
  }

  /**
   * PostVersionHistory create
   */
  export type PostVersionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PostVersionHistory.
     */
    data: XOR<PostVersionHistoryCreateInput, PostVersionHistoryUncheckedCreateInput>
  }

  /**
   * PostVersionHistory createMany
   */
  export type PostVersionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostVersionHistories.
     */
    data: PostVersionHistoryCreateManyInput | PostVersionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostVersionHistory createManyAndReturn
   */
  export type PostVersionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PostVersionHistories.
     */
    data: PostVersionHistoryCreateManyInput | PostVersionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVersionHistory update
   */
  export type PostVersionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PostVersionHistory.
     */
    data: XOR<PostVersionHistoryUpdateInput, PostVersionHistoryUncheckedUpdateInput>
    /**
     * Choose, which PostVersionHistory to update.
     */
    where: PostVersionHistoryWhereUniqueInput
  }

  /**
   * PostVersionHistory updateMany
   */
  export type PostVersionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostVersionHistories.
     */
    data: XOR<PostVersionHistoryUpdateManyMutationInput, PostVersionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PostVersionHistories to update
     */
    where?: PostVersionHistoryWhereInput
    /**
     * Limit how many PostVersionHistories to update.
     */
    limit?: number
  }

  /**
   * PostVersionHistory updateManyAndReturn
   */
  export type PostVersionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PostVersionHistories.
     */
    data: XOR<PostVersionHistoryUpdateManyMutationInput, PostVersionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PostVersionHistories to update
     */
    where?: PostVersionHistoryWhereInput
    /**
     * Limit how many PostVersionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVersionHistory upsert
   */
  export type PostVersionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PostVersionHistory to update in case it exists.
     */
    where: PostVersionHistoryWhereUniqueInput
    /**
     * In case the PostVersionHistory found by the `where` argument doesn't exist, create a new PostVersionHistory with this data.
     */
    create: XOR<PostVersionHistoryCreateInput, PostVersionHistoryUncheckedCreateInput>
    /**
     * In case the PostVersionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostVersionHistoryUpdateInput, PostVersionHistoryUncheckedUpdateInput>
  }

  /**
   * PostVersionHistory delete
   */
  export type PostVersionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter which PostVersionHistory to delete.
     */
    where: PostVersionHistoryWhereUniqueInput
  }

  /**
   * PostVersionHistory deleteMany
   */
  export type PostVersionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVersionHistories to delete
     */
    where?: PostVersionHistoryWhereInput
    /**
     * Limit how many PostVersionHistories to delete.
     */
    limit?: number
  }

  /**
   * PostVersionHistory without action
   */
  export type PostVersionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVersionHistory
     */
    select?: PostVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVersionHistory
     */
    omit?: PostVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVersionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PathwayTypes
   */

  export type AggregatePathwayTypes = {
    _count: PathwayTypesCountAggregateOutputType | null
    _avg: PathwayTypesAvgAggregateOutputType | null
    _sum: PathwayTypesSumAggregateOutputType | null
    _min: PathwayTypesMinAggregateOutputType | null
    _max: PathwayTypesMaxAggregateOutputType | null
  }

  export type PathwayTypesAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type PathwayTypesSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type PathwayTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    description: string | null
  }

  export type PathwayTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    description: string | null
  }

  export type PathwayTypesCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    description: number
    _all: number
  }


  export type PathwayTypesAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type PathwayTypesSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type PathwayTypesMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    description?: true
  }

  export type PathwayTypesMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    description?: true
  }

  export type PathwayTypesCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    description?: true
    _all?: true
  }

  export type PathwayTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayTypes to aggregate.
     */
    where?: PathwayTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayTypes to fetch.
     */
    orderBy?: PathwayTypesOrderByWithRelationInput | PathwayTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PathwayTypes
    **/
    _count?: true | PathwayTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwayTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayTypesMaxAggregateInputType
  }

  export type GetPathwayTypesAggregateType<T extends PathwayTypesAggregateArgs> = {
        [P in keyof T & keyof AggregatePathwayTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathwayTypes[P]>
      : GetScalarType<T[P], AggregatePathwayTypes[P]>
  }




  export type PathwayTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayTypesWhereInput
    orderBy?: PathwayTypesOrderByWithAggregationInput | PathwayTypesOrderByWithAggregationInput[]
    by: PathwayTypesScalarFieldEnum[] | PathwayTypesScalarFieldEnum
    having?: PathwayTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayTypesCountAggregateInputType | true
    _avg?: PathwayTypesAvgAggregateInputType
    _sum?: PathwayTypesSumAggregateInputType
    _min?: PathwayTypesMinAggregateInputType
    _max?: PathwayTypesMaxAggregateInputType
  }

  export type PathwayTypesGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    description: string | null
    _count: PathwayTypesCountAggregateOutputType | null
    _avg: PathwayTypesAvgAggregateOutputType | null
    _sum: PathwayTypesSumAggregateOutputType | null
    _min: PathwayTypesMinAggregateOutputType | null
    _max: PathwayTypesMaxAggregateOutputType | null
  }

  type GetPathwayTypesGroupByPayload<T extends PathwayTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayTypesGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayTypesGroupByOutputType[P]>
        }
      >
    >


  export type PathwayTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    description?: boolean
    pathwayCategories?: boolean | PathwayTypes$pathwayCategoriesArgs<ExtArgs>
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
    children?: boolean | PathwayTypes$childrenArgs<ExtArgs>
    _count?: boolean | PathwayTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayTypes"]>

  export type PathwayTypesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    description?: boolean
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayTypes"]>

  export type PathwayTypesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    description?: boolean
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayTypes"]>

  export type PathwayTypesSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    description?: boolean
  }

  export type PathwayTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "description", ExtArgs["result"]["pathwayTypes"]>
  export type PathwayTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathwayCategories?: boolean | PathwayTypes$pathwayCategoriesArgs<ExtArgs>
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
    children?: boolean | PathwayTypes$childrenArgs<ExtArgs>
    _count?: boolean | PathwayTypesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PathwayTypesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
  }
  export type PathwayTypesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | PathwayTypes$parentArgs<ExtArgs>
  }

  export type $PathwayTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PathwayTypes"
    objects: {
      pathwayCategories: Prisma.$PathwayCategoriesPayload<ExtArgs>[]
      parent: Prisma.$PathwayTypesPayload<ExtArgs> | null
      children: Prisma.$PathwayTypesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      description: string | null
    }, ExtArgs["result"]["pathwayTypes"]>
    composites: {}
  }

  type PathwayTypesGetPayload<S extends boolean | null | undefined | PathwayTypesDefaultArgs> = $Result.GetResult<Prisma.$PathwayTypesPayload, S>

  type PathwayTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayTypesCountAggregateInputType | true
    }

  export interface PathwayTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PathwayTypes'], meta: { name: 'PathwayTypes' } }
    /**
     * Find zero or one PathwayTypes that matches the filter.
     * @param {PathwayTypesFindUniqueArgs} args - Arguments to find a PathwayTypes
     * @example
     * // Get one PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayTypesFindUniqueArgs>(args: SelectSubset<T, PathwayTypesFindUniqueArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PathwayTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayTypesFindUniqueOrThrowArgs} args - Arguments to find a PathwayTypes
     * @example
     * // Get one PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesFindFirstArgs} args - Arguments to find a PathwayTypes
     * @example
     * // Get one PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayTypesFindFirstArgs>(args?: SelectSubset<T, PathwayTypesFindFirstArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesFindFirstOrThrowArgs} args - Arguments to find a PathwayTypes
     * @example
     * // Get one PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PathwayTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findMany()
     * 
     * // Get first 10 PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathwayTypesWithIdOnly = await prisma.pathwayTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathwayTypesFindManyArgs>(args?: SelectSubset<T, PathwayTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PathwayTypes.
     * @param {PathwayTypesCreateArgs} args - Arguments to create a PathwayTypes.
     * @example
     * // Create one PathwayTypes
     * const PathwayTypes = await prisma.pathwayTypes.create({
     *   data: {
     *     // ... data to create a PathwayTypes
     *   }
     * })
     * 
     */
    create<T extends PathwayTypesCreateArgs>(args: SelectSubset<T, PathwayTypesCreateArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PathwayTypes.
     * @param {PathwayTypesCreateManyArgs} args - Arguments to create many PathwayTypes.
     * @example
     * // Create many PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayTypesCreateManyArgs>(args?: SelectSubset<T, PathwayTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PathwayTypes and returns the data saved in the database.
     * @param {PathwayTypesCreateManyAndReturnArgs} args - Arguments to create many PathwayTypes.
     * @example
     * // Create many PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PathwayTypes and only return the `id`
     * const pathwayTypesWithIdOnly = await prisma.pathwayTypes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayTypesCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayTypesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PathwayTypes.
     * @param {PathwayTypesDeleteArgs} args - Arguments to delete one PathwayTypes.
     * @example
     * // Delete one PathwayTypes
     * const PathwayTypes = await prisma.pathwayTypes.delete({
     *   where: {
     *     // ... filter to delete one PathwayTypes
     *   }
     * })
     * 
     */
    delete<T extends PathwayTypesDeleteArgs>(args: SelectSubset<T, PathwayTypesDeleteArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PathwayTypes.
     * @param {PathwayTypesUpdateArgs} args - Arguments to update one PathwayTypes.
     * @example
     * // Update one PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayTypesUpdateArgs>(args: SelectSubset<T, PathwayTypesUpdateArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PathwayTypes.
     * @param {PathwayTypesDeleteManyArgs} args - Arguments to filter PathwayTypes to delete.
     * @example
     * // Delete a few PathwayTypes
     * const { count } = await prisma.pathwayTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayTypesDeleteManyArgs>(args?: SelectSubset<T, PathwayTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayTypesUpdateManyArgs>(args: SelectSubset<T, PathwayTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayTypes and returns the data updated in the database.
     * @param {PathwayTypesUpdateManyAndReturnArgs} args - Arguments to update many PathwayTypes.
     * @example
     * // Update many PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PathwayTypes and only return the `id`
     * const pathwayTypesWithIdOnly = await prisma.pathwayTypes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayTypesUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayTypesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PathwayTypes.
     * @param {PathwayTypesUpsertArgs} args - Arguments to update or create a PathwayTypes.
     * @example
     * // Update or create a PathwayTypes
     * const pathwayTypes = await prisma.pathwayTypes.upsert({
     *   create: {
     *     // ... data to create a PathwayTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PathwayTypes we want to update
     *   }
     * })
     */
    upsert<T extends PathwayTypesUpsertArgs>(args: SelectSubset<T, PathwayTypesUpsertArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PathwayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesCountArgs} args - Arguments to filter PathwayTypes to count.
     * @example
     * // Count the number of PathwayTypes
     * const count = await prisma.pathwayTypes.count({
     *   where: {
     *     // ... the filter for the PathwayTypes we want to count
     *   }
     * })
    **/
    count<T extends PathwayTypesCountArgs>(
      args?: Subset<T, PathwayTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PathwayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayTypesAggregateArgs>(args: Subset<T, PathwayTypesAggregateArgs>): Prisma.PrismaPromise<GetPathwayTypesAggregateType<T>>

    /**
     * Group by PathwayTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayTypesGroupByArgs['orderBy'] }
        : { orderBy?: PathwayTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PathwayTypes model
   */
  readonly fields: PathwayTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PathwayTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pathwayCategories<T extends PathwayTypes$pathwayCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, PathwayTypes$pathwayCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends PathwayTypes$parentArgs<ExtArgs> = {}>(args?: Subset<T, PathwayTypes$parentArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends PathwayTypes$childrenArgs<ExtArgs> = {}>(args?: Subset<T, PathwayTypes$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PathwayTypes model
   */
  interface PathwayTypesFieldRefs {
    readonly id: FieldRef<"PathwayTypes", 'Int'>
    readonly name: FieldRef<"PathwayTypes", 'String'>
    readonly parentId: FieldRef<"PathwayTypes", 'Int'>
    readonly description: FieldRef<"PathwayTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PathwayTypes findUnique
   */
  export type PathwayTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayTypes to fetch.
     */
    where: PathwayTypesWhereUniqueInput
  }

  /**
   * PathwayTypes findUniqueOrThrow
   */
  export type PathwayTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayTypes to fetch.
     */
    where: PathwayTypesWhereUniqueInput
  }

  /**
   * PathwayTypes findFirst
   */
  export type PathwayTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayTypes to fetch.
     */
    where?: PathwayTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayTypes to fetch.
     */
    orderBy?: PathwayTypesOrderByWithRelationInput | PathwayTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayTypes.
     */
    cursor?: PathwayTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayTypes.
     */
    distinct?: PathwayTypesScalarFieldEnum | PathwayTypesScalarFieldEnum[]
  }

  /**
   * PathwayTypes findFirstOrThrow
   */
  export type PathwayTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayTypes to fetch.
     */
    where?: PathwayTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayTypes to fetch.
     */
    orderBy?: PathwayTypesOrderByWithRelationInput | PathwayTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayTypes.
     */
    cursor?: PathwayTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayTypes.
     */
    distinct?: PathwayTypesScalarFieldEnum | PathwayTypesScalarFieldEnum[]
  }

  /**
   * PathwayTypes findMany
   */
  export type PathwayTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayTypes to fetch.
     */
    where?: PathwayTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayTypes to fetch.
     */
    orderBy?: PathwayTypesOrderByWithRelationInput | PathwayTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PathwayTypes.
     */
    cursor?: PathwayTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayTypes.
     */
    skip?: number
    distinct?: PathwayTypesScalarFieldEnum | PathwayTypesScalarFieldEnum[]
  }

  /**
   * PathwayTypes create
   */
  export type PathwayTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a PathwayTypes.
     */
    data: XOR<PathwayTypesCreateInput, PathwayTypesUncheckedCreateInput>
  }

  /**
   * PathwayTypes createMany
   */
  export type PathwayTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PathwayTypes.
     */
    data: PathwayTypesCreateManyInput | PathwayTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PathwayTypes createManyAndReturn
   */
  export type PathwayTypesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * The data used to create many PathwayTypes.
     */
    data: PathwayTypesCreateManyInput | PathwayTypesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayTypes update
   */
  export type PathwayTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a PathwayTypes.
     */
    data: XOR<PathwayTypesUpdateInput, PathwayTypesUncheckedUpdateInput>
    /**
     * Choose, which PathwayTypes to update.
     */
    where: PathwayTypesWhereUniqueInput
  }

  /**
   * PathwayTypes updateMany
   */
  export type PathwayTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PathwayTypes.
     */
    data: XOR<PathwayTypesUpdateManyMutationInput, PathwayTypesUncheckedUpdateManyInput>
    /**
     * Filter which PathwayTypes to update
     */
    where?: PathwayTypesWhereInput
    /**
     * Limit how many PathwayTypes to update.
     */
    limit?: number
  }

  /**
   * PathwayTypes updateManyAndReturn
   */
  export type PathwayTypesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * The data used to update PathwayTypes.
     */
    data: XOR<PathwayTypesUpdateManyMutationInput, PathwayTypesUncheckedUpdateManyInput>
    /**
     * Filter which PathwayTypes to update
     */
    where?: PathwayTypesWhereInput
    /**
     * Limit how many PathwayTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayTypes upsert
   */
  export type PathwayTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the PathwayTypes to update in case it exists.
     */
    where: PathwayTypesWhereUniqueInput
    /**
     * In case the PathwayTypes found by the `where` argument doesn't exist, create a new PathwayTypes with this data.
     */
    create: XOR<PathwayTypesCreateInput, PathwayTypesUncheckedCreateInput>
    /**
     * In case the PathwayTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayTypesUpdateInput, PathwayTypesUncheckedUpdateInput>
  }

  /**
   * PathwayTypes delete
   */
  export type PathwayTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    /**
     * Filter which PathwayTypes to delete.
     */
    where: PathwayTypesWhereUniqueInput
  }

  /**
   * PathwayTypes deleteMany
   */
  export type PathwayTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayTypes to delete
     */
    where?: PathwayTypesWhereInput
    /**
     * Limit how many PathwayTypes to delete.
     */
    limit?: number
  }

  /**
   * PathwayTypes.pathwayCategories
   */
  export type PathwayTypes$pathwayCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    where?: PathwayCategoriesWhereInput
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    cursor?: PathwayCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayCategoriesScalarFieldEnum | PathwayCategoriesScalarFieldEnum[]
  }

  /**
   * PathwayTypes.parent
   */
  export type PathwayTypes$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    where?: PathwayTypesWhereInput
  }

  /**
   * PathwayTypes.children
   */
  export type PathwayTypes$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
    where?: PathwayTypesWhereInput
    orderBy?: PathwayTypesOrderByWithRelationInput | PathwayTypesOrderByWithRelationInput[]
    cursor?: PathwayTypesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayTypesScalarFieldEnum | PathwayTypesScalarFieldEnum[]
  }

  /**
   * PathwayTypes without action
   */
  export type PathwayTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayTypes
     */
    select?: PathwayTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayTypes
     */
    omit?: PathwayTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayTypesInclude<ExtArgs> | null
  }


  /**
   * Model PathwayCategories
   */

  export type AggregatePathwayCategories = {
    _count: PathwayCategoriesCountAggregateOutputType | null
    _avg: PathwayCategoriesAvgAggregateOutputType | null
    _sum: PathwayCategoriesSumAggregateOutputType | null
    _min: PathwayCategoriesMinAggregateOutputType | null
    _max: PathwayCategoriesMaxAggregateOutputType | null
  }

  export type PathwayCategoriesAvgAggregateOutputType = {
    pathwayId: number | null
    pathwayTypeId: number | null
  }

  export type PathwayCategoriesSumAggregateOutputType = {
    pathwayId: number | null
    pathwayTypeId: number | null
  }

  export type PathwayCategoriesMinAggregateOutputType = {
    pathwayId: number | null
    pathwayTypeId: number | null
  }

  export type PathwayCategoriesMaxAggregateOutputType = {
    pathwayId: number | null
    pathwayTypeId: number | null
  }

  export type PathwayCategoriesCountAggregateOutputType = {
    pathwayId: number
    pathwayTypeId: number
    _all: number
  }


  export type PathwayCategoriesAvgAggregateInputType = {
    pathwayId?: true
    pathwayTypeId?: true
  }

  export type PathwayCategoriesSumAggregateInputType = {
    pathwayId?: true
    pathwayTypeId?: true
  }

  export type PathwayCategoriesMinAggregateInputType = {
    pathwayId?: true
    pathwayTypeId?: true
  }

  export type PathwayCategoriesMaxAggregateInputType = {
    pathwayId?: true
    pathwayTypeId?: true
  }

  export type PathwayCategoriesCountAggregateInputType = {
    pathwayId?: true
    pathwayTypeId?: true
    _all?: true
  }

  export type PathwayCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayCategories to aggregate.
     */
    where?: PathwayCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayCategories to fetch.
     */
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PathwayCategories
    **/
    _count?: true | PathwayCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwayCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayCategoriesMaxAggregateInputType
  }

  export type GetPathwayCategoriesAggregateType<T extends PathwayCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregatePathwayCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathwayCategories[P]>
      : GetScalarType<T[P], AggregatePathwayCategories[P]>
  }




  export type PathwayCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayCategoriesWhereInput
    orderBy?: PathwayCategoriesOrderByWithAggregationInput | PathwayCategoriesOrderByWithAggregationInput[]
    by: PathwayCategoriesScalarFieldEnum[] | PathwayCategoriesScalarFieldEnum
    having?: PathwayCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayCategoriesCountAggregateInputType | true
    _avg?: PathwayCategoriesAvgAggregateInputType
    _sum?: PathwayCategoriesSumAggregateInputType
    _min?: PathwayCategoriesMinAggregateInputType
    _max?: PathwayCategoriesMaxAggregateInputType
  }

  export type PathwayCategoriesGroupByOutputType = {
    pathwayId: number
    pathwayTypeId: number
    _count: PathwayCategoriesCountAggregateOutputType | null
    _avg: PathwayCategoriesAvgAggregateOutputType | null
    _sum: PathwayCategoriesSumAggregateOutputType | null
    _min: PathwayCategoriesMinAggregateOutputType | null
    _max: PathwayCategoriesMaxAggregateOutputType | null
  }

  type GetPathwayCategoriesGroupByPayload<T extends PathwayCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type PathwayCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    pathwayTypeId?: boolean
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayCategories"]>

  export type PathwayCategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    pathwayTypeId?: boolean
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayCategories"]>

  export type PathwayCategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pathwayId?: boolean
    pathwayTypeId?: boolean
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pathwayCategories"]>

  export type PathwayCategoriesSelectScalar = {
    pathwayId?: boolean
    pathwayTypeId?: boolean
  }

  export type PathwayCategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pathwayId" | "pathwayTypeId", ExtArgs["result"]["pathwayCategories"]>
  export type PathwayCategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }
  export type PathwayCategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }
  export type PathwayCategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pathways?: boolean | PathwayDefaultArgs<ExtArgs>
    pathway_categories?: boolean | PathwayTypesDefaultArgs<ExtArgs>
  }

  export type $PathwayCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PathwayCategories"
    objects: {
      pathways: Prisma.$PathwayPayload<ExtArgs>
      pathway_categories: Prisma.$PathwayTypesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pathwayId: number
      pathwayTypeId: number
    }, ExtArgs["result"]["pathwayCategories"]>
    composites: {}
  }

  type PathwayCategoriesGetPayload<S extends boolean | null | undefined | PathwayCategoriesDefaultArgs> = $Result.GetResult<Prisma.$PathwayCategoriesPayload, S>

  type PathwayCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayCategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayCategoriesCountAggregateInputType | true
    }

  export interface PathwayCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PathwayCategories'], meta: { name: 'PathwayCategories' } }
    /**
     * Find zero or one PathwayCategories that matches the filter.
     * @param {PathwayCategoriesFindUniqueArgs} args - Arguments to find a PathwayCategories
     * @example
     * // Get one PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayCategoriesFindUniqueArgs>(args: SelectSubset<T, PathwayCategoriesFindUniqueArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PathwayCategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayCategoriesFindUniqueOrThrowArgs} args - Arguments to find a PathwayCategories
     * @example
     * // Get one PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesFindFirstArgs} args - Arguments to find a PathwayCategories
     * @example
     * // Get one PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayCategoriesFindFirstArgs>(args?: SelectSubset<T, PathwayCategoriesFindFirstArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PathwayCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesFindFirstOrThrowArgs} args - Arguments to find a PathwayCategories
     * @example
     * // Get one PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PathwayCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findMany()
     * 
     * // Get first 10 PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.findMany({ take: 10 })
     * 
     * // Only select the `pathwayId`
     * const pathwayCategoriesWithPathwayIdOnly = await prisma.pathwayCategories.findMany({ select: { pathwayId: true } })
     * 
     */
    findMany<T extends PathwayCategoriesFindManyArgs>(args?: SelectSubset<T, PathwayCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PathwayCategories.
     * @param {PathwayCategoriesCreateArgs} args - Arguments to create a PathwayCategories.
     * @example
     * // Create one PathwayCategories
     * const PathwayCategories = await prisma.pathwayCategories.create({
     *   data: {
     *     // ... data to create a PathwayCategories
     *   }
     * })
     * 
     */
    create<T extends PathwayCategoriesCreateArgs>(args: SelectSubset<T, PathwayCategoriesCreateArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PathwayCategories.
     * @param {PathwayCategoriesCreateManyArgs} args - Arguments to create many PathwayCategories.
     * @example
     * // Create many PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayCategoriesCreateManyArgs>(args?: SelectSubset<T, PathwayCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PathwayCategories and returns the data saved in the database.
     * @param {PathwayCategoriesCreateManyAndReturnArgs} args - Arguments to create many PathwayCategories.
     * @example
     * // Create many PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PathwayCategories and only return the `pathwayId`
     * const pathwayCategoriesWithPathwayIdOnly = await prisma.pathwayCategories.createManyAndReturn({
     *   select: { pathwayId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayCategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayCategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PathwayCategories.
     * @param {PathwayCategoriesDeleteArgs} args - Arguments to delete one PathwayCategories.
     * @example
     * // Delete one PathwayCategories
     * const PathwayCategories = await prisma.pathwayCategories.delete({
     *   where: {
     *     // ... filter to delete one PathwayCategories
     *   }
     * })
     * 
     */
    delete<T extends PathwayCategoriesDeleteArgs>(args: SelectSubset<T, PathwayCategoriesDeleteArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PathwayCategories.
     * @param {PathwayCategoriesUpdateArgs} args - Arguments to update one PathwayCategories.
     * @example
     * // Update one PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayCategoriesUpdateArgs>(args: SelectSubset<T, PathwayCategoriesUpdateArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PathwayCategories.
     * @param {PathwayCategoriesDeleteManyArgs} args - Arguments to filter PathwayCategories to delete.
     * @example
     * // Delete a few PathwayCategories
     * const { count } = await prisma.pathwayCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayCategoriesDeleteManyArgs>(args?: SelectSubset<T, PathwayCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayCategoriesUpdateManyArgs>(args: SelectSubset<T, PathwayCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PathwayCategories and returns the data updated in the database.
     * @param {PathwayCategoriesUpdateManyAndReturnArgs} args - Arguments to update many PathwayCategories.
     * @example
     * // Update many PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PathwayCategories and only return the `pathwayId`
     * const pathwayCategoriesWithPathwayIdOnly = await prisma.pathwayCategories.updateManyAndReturn({
     *   select: { pathwayId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayCategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayCategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PathwayCategories.
     * @param {PathwayCategoriesUpsertArgs} args - Arguments to update or create a PathwayCategories.
     * @example
     * // Update or create a PathwayCategories
     * const pathwayCategories = await prisma.pathwayCategories.upsert({
     *   create: {
     *     // ... data to create a PathwayCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PathwayCategories we want to update
     *   }
     * })
     */
    upsert<T extends PathwayCategoriesUpsertArgs>(args: SelectSubset<T, PathwayCategoriesUpsertArgs<ExtArgs>>): Prisma__PathwayCategoriesClient<$Result.GetResult<Prisma.$PathwayCategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PathwayCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesCountArgs} args - Arguments to filter PathwayCategories to count.
     * @example
     * // Count the number of PathwayCategories
     * const count = await prisma.pathwayCategories.count({
     *   where: {
     *     // ... the filter for the PathwayCategories we want to count
     *   }
     * })
    **/
    count<T extends PathwayCategoriesCountArgs>(
      args?: Subset<T, PathwayCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PathwayCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayCategoriesAggregateArgs>(args: Subset<T, PathwayCategoriesAggregateArgs>): Prisma.PrismaPromise<GetPathwayCategoriesAggregateType<T>>

    /**
     * Group by PathwayCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: PathwayCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PathwayCategories model
   */
  readonly fields: PathwayCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PathwayCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pathways<T extends PathwayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathwayDefaultArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pathway_categories<T extends PathwayTypesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathwayTypesDefaultArgs<ExtArgs>>): Prisma__PathwayTypesClient<$Result.GetResult<Prisma.$PathwayTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PathwayCategories model
   */
  interface PathwayCategoriesFieldRefs {
    readonly pathwayId: FieldRef<"PathwayCategories", 'Int'>
    readonly pathwayTypeId: FieldRef<"PathwayCategories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PathwayCategories findUnique
   */
  export type PathwayCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayCategories to fetch.
     */
    where: PathwayCategoriesWhereUniqueInput
  }

  /**
   * PathwayCategories findUniqueOrThrow
   */
  export type PathwayCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayCategories to fetch.
     */
    where: PathwayCategoriesWhereUniqueInput
  }

  /**
   * PathwayCategories findFirst
   */
  export type PathwayCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayCategories to fetch.
     */
    where?: PathwayCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayCategories to fetch.
     */
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayCategories.
     */
    cursor?: PathwayCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayCategories.
     */
    distinct?: PathwayCategoriesScalarFieldEnum | PathwayCategoriesScalarFieldEnum[]
  }

  /**
   * PathwayCategories findFirstOrThrow
   */
  export type PathwayCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayCategories to fetch.
     */
    where?: PathwayCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayCategories to fetch.
     */
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PathwayCategories.
     */
    cursor?: PathwayCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PathwayCategories.
     */
    distinct?: PathwayCategoriesScalarFieldEnum | PathwayCategoriesScalarFieldEnum[]
  }

  /**
   * PathwayCategories findMany
   */
  export type PathwayCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PathwayCategories to fetch.
     */
    where?: PathwayCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PathwayCategories to fetch.
     */
    orderBy?: PathwayCategoriesOrderByWithRelationInput | PathwayCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PathwayCategories.
     */
    cursor?: PathwayCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PathwayCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PathwayCategories.
     */
    skip?: number
    distinct?: PathwayCategoriesScalarFieldEnum | PathwayCategoriesScalarFieldEnum[]
  }

  /**
   * PathwayCategories create
   */
  export type PathwayCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a PathwayCategories.
     */
    data: XOR<PathwayCategoriesCreateInput, PathwayCategoriesUncheckedCreateInput>
  }

  /**
   * PathwayCategories createMany
   */
  export type PathwayCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PathwayCategories.
     */
    data: PathwayCategoriesCreateManyInput | PathwayCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PathwayCategories createManyAndReturn
   */
  export type PathwayCategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many PathwayCategories.
     */
    data: PathwayCategoriesCreateManyInput | PathwayCategoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayCategories update
   */
  export type PathwayCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a PathwayCategories.
     */
    data: XOR<PathwayCategoriesUpdateInput, PathwayCategoriesUncheckedUpdateInput>
    /**
     * Choose, which PathwayCategories to update.
     */
    where: PathwayCategoriesWhereUniqueInput
  }

  /**
   * PathwayCategories updateMany
   */
  export type PathwayCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PathwayCategories.
     */
    data: XOR<PathwayCategoriesUpdateManyMutationInput, PathwayCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which PathwayCategories to update
     */
    where?: PathwayCategoriesWhereInput
    /**
     * Limit how many PathwayCategories to update.
     */
    limit?: number
  }

  /**
   * PathwayCategories updateManyAndReturn
   */
  export type PathwayCategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * The data used to update PathwayCategories.
     */
    data: XOR<PathwayCategoriesUpdateManyMutationInput, PathwayCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which PathwayCategories to update
     */
    where?: PathwayCategoriesWhereInput
    /**
     * Limit how many PathwayCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PathwayCategories upsert
   */
  export type PathwayCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the PathwayCategories to update in case it exists.
     */
    where: PathwayCategoriesWhereUniqueInput
    /**
     * In case the PathwayCategories found by the `where` argument doesn't exist, create a new PathwayCategories with this data.
     */
    create: XOR<PathwayCategoriesCreateInput, PathwayCategoriesUncheckedCreateInput>
    /**
     * In case the PathwayCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayCategoriesUpdateInput, PathwayCategoriesUncheckedUpdateInput>
  }

  /**
   * PathwayCategories delete
   */
  export type PathwayCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
    /**
     * Filter which PathwayCategories to delete.
     */
    where: PathwayCategoriesWhereUniqueInput
  }

  /**
   * PathwayCategories deleteMany
   */
  export type PathwayCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PathwayCategories to delete
     */
    where?: PathwayCategoriesWhereInput
    /**
     * Limit how many PathwayCategories to delete.
     */
    limit?: number
  }

  /**
   * PathwayCategories without action
   */
  export type PathwayCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathwayCategories
     */
    select?: PathwayCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PathwayCategories
     */
    omit?: PathwayCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayCategoriesInclude<ExtArgs> | null
  }


  /**
   * Model ContentResourceType
   */

  export type AggregateContentResourceType = {
    _count: ContentResourceTypeCountAggregateOutputType | null
    _avg: ContentResourceTypeAvgAggregateOutputType | null
    _sum: ContentResourceTypeSumAggregateOutputType | null
    _min: ContentResourceTypeMinAggregateOutputType | null
    _max: ContentResourceTypeMaxAggregateOutputType | null
  }

  export type ContentResourceTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ContentResourceTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ContentResourceTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
    icon: string | null
    color: string | null
  }

  export type ContentResourceTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    icon: string | null
    color: string | null
  }

  export type ContentResourceTypeCountAggregateOutputType = {
    id: number
    type: number
    icon: number
    color: number
    _all: number
  }


  export type ContentResourceTypeAvgAggregateInputType = {
    id?: true
  }

  export type ContentResourceTypeSumAggregateInputType = {
    id?: true
  }

  export type ContentResourceTypeMinAggregateInputType = {
    id?: true
    type?: true
    icon?: true
    color?: true
  }

  export type ContentResourceTypeMaxAggregateInputType = {
    id?: true
    type?: true
    icon?: true
    color?: true
  }

  export type ContentResourceTypeCountAggregateInputType = {
    id?: true
    type?: true
    icon?: true
    color?: true
    _all?: true
  }

  export type ContentResourceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResourceType to aggregate.
     */
    where?: ContentResourceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceTypes to fetch.
     */
    orderBy?: ContentResourceTypeOrderByWithRelationInput | ContentResourceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentResourceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentResourceTypes
    **/
    _count?: true | ContentResourceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentResourceTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentResourceTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentResourceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentResourceTypeMaxAggregateInputType
  }

  export type GetContentResourceTypeAggregateType<T extends ContentResourceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContentResourceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentResourceType[P]>
      : GetScalarType<T[P], AggregateContentResourceType[P]>
  }




  export type ContentResourceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceTypeWhereInput
    orderBy?: ContentResourceTypeOrderByWithAggregationInput | ContentResourceTypeOrderByWithAggregationInput[]
    by: ContentResourceTypeScalarFieldEnum[] | ContentResourceTypeScalarFieldEnum
    having?: ContentResourceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentResourceTypeCountAggregateInputType | true
    _avg?: ContentResourceTypeAvgAggregateInputType
    _sum?: ContentResourceTypeSumAggregateInputType
    _min?: ContentResourceTypeMinAggregateInputType
    _max?: ContentResourceTypeMaxAggregateInputType
  }

  export type ContentResourceTypeGroupByOutputType = {
    id: number
    type: string
    icon: string | null
    color: string | null
    _count: ContentResourceTypeCountAggregateOutputType | null
    _avg: ContentResourceTypeAvgAggregateOutputType | null
    _sum: ContentResourceTypeSumAggregateOutputType | null
    _min: ContentResourceTypeMinAggregateOutputType | null
    _max: ContentResourceTypeMaxAggregateOutputType | null
  }

  type GetContentResourceTypeGroupByPayload<T extends ContentResourceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentResourceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentResourceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentResourceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContentResourceTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContentResourceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    icon?: boolean
    color?: boolean
    contentResources?: boolean | ContentResourceType$contentResourcesArgs<ExtArgs>
    _count?: boolean | ContentResourceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentResourceType"]>

  export type ContentResourceTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    icon?: boolean
    color?: boolean
  }, ExtArgs["result"]["contentResourceType"]>

  export type ContentResourceTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    icon?: boolean
    color?: boolean
  }, ExtArgs["result"]["contentResourceType"]>

  export type ContentResourceTypeSelectScalar = {
    id?: boolean
    type?: boolean
    icon?: boolean
    color?: boolean
  }

  export type ContentResourceTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "icon" | "color", ExtArgs["result"]["contentResourceType"]>
  export type ContentResourceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentResources?: boolean | ContentResourceType$contentResourcesArgs<ExtArgs>
    _count?: boolean | ContentResourceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentResourceTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentResourceTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentResourceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentResourceType"
    objects: {
      contentResources: Prisma.$ContentResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      icon: string | null
      color: string | null
    }, ExtArgs["result"]["contentResourceType"]>
    composites: {}
  }

  type ContentResourceTypeGetPayload<S extends boolean | null | undefined | ContentResourceTypeDefaultArgs> = $Result.GetResult<Prisma.$ContentResourceTypePayload, S>

  type ContentResourceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentResourceTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentResourceTypeCountAggregateInputType | true
    }

  export interface ContentResourceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentResourceType'], meta: { name: 'ContentResourceType' } }
    /**
     * Find zero or one ContentResourceType that matches the filter.
     * @param {ContentResourceTypeFindUniqueArgs} args - Arguments to find a ContentResourceType
     * @example
     * // Get one ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentResourceTypeFindUniqueArgs>(args: SelectSubset<T, ContentResourceTypeFindUniqueArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentResourceType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentResourceTypeFindUniqueOrThrowArgs} args - Arguments to find a ContentResourceType
     * @example
     * // Get one ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentResourceTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentResourceTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResourceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeFindFirstArgs} args - Arguments to find a ContentResourceType
     * @example
     * // Get one ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentResourceTypeFindFirstArgs>(args?: SelectSubset<T, ContentResourceTypeFindFirstArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResourceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeFindFirstOrThrowArgs} args - Arguments to find a ContentResourceType
     * @example
     * // Get one ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentResourceTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentResourceTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentResourceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentResourceTypes
     * const contentResourceTypes = await prisma.contentResourceType.findMany()
     * 
     * // Get first 10 ContentResourceTypes
     * const contentResourceTypes = await prisma.contentResourceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentResourceTypeWithIdOnly = await prisma.contentResourceType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentResourceTypeFindManyArgs>(args?: SelectSubset<T, ContentResourceTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentResourceType.
     * @param {ContentResourceTypeCreateArgs} args - Arguments to create a ContentResourceType.
     * @example
     * // Create one ContentResourceType
     * const ContentResourceType = await prisma.contentResourceType.create({
     *   data: {
     *     // ... data to create a ContentResourceType
     *   }
     * })
     * 
     */
    create<T extends ContentResourceTypeCreateArgs>(args: SelectSubset<T, ContentResourceTypeCreateArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentResourceTypes.
     * @param {ContentResourceTypeCreateManyArgs} args - Arguments to create many ContentResourceTypes.
     * @example
     * // Create many ContentResourceTypes
     * const contentResourceType = await prisma.contentResourceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentResourceTypeCreateManyArgs>(args?: SelectSubset<T, ContentResourceTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentResourceTypes and returns the data saved in the database.
     * @param {ContentResourceTypeCreateManyAndReturnArgs} args - Arguments to create many ContentResourceTypes.
     * @example
     * // Create many ContentResourceTypes
     * const contentResourceType = await prisma.contentResourceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentResourceTypes and only return the `id`
     * const contentResourceTypeWithIdOnly = await prisma.contentResourceType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentResourceTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentResourceTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentResourceType.
     * @param {ContentResourceTypeDeleteArgs} args - Arguments to delete one ContentResourceType.
     * @example
     * // Delete one ContentResourceType
     * const ContentResourceType = await prisma.contentResourceType.delete({
     *   where: {
     *     // ... filter to delete one ContentResourceType
     *   }
     * })
     * 
     */
    delete<T extends ContentResourceTypeDeleteArgs>(args: SelectSubset<T, ContentResourceTypeDeleteArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentResourceType.
     * @param {ContentResourceTypeUpdateArgs} args - Arguments to update one ContentResourceType.
     * @example
     * // Update one ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentResourceTypeUpdateArgs>(args: SelectSubset<T, ContentResourceTypeUpdateArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentResourceTypes.
     * @param {ContentResourceTypeDeleteManyArgs} args - Arguments to filter ContentResourceTypes to delete.
     * @example
     * // Delete a few ContentResourceTypes
     * const { count } = await prisma.contentResourceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentResourceTypeDeleteManyArgs>(args?: SelectSubset<T, ContentResourceTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResourceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentResourceTypes
     * const contentResourceType = await prisma.contentResourceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentResourceTypeUpdateManyArgs>(args: SelectSubset<T, ContentResourceTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResourceTypes and returns the data updated in the database.
     * @param {ContentResourceTypeUpdateManyAndReturnArgs} args - Arguments to update many ContentResourceTypes.
     * @example
     * // Update many ContentResourceTypes
     * const contentResourceType = await prisma.contentResourceType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentResourceTypes and only return the `id`
     * const contentResourceTypeWithIdOnly = await prisma.contentResourceType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentResourceTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentResourceTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentResourceType.
     * @param {ContentResourceTypeUpsertArgs} args - Arguments to update or create a ContentResourceType.
     * @example
     * // Update or create a ContentResourceType
     * const contentResourceType = await prisma.contentResourceType.upsert({
     *   create: {
     *     // ... data to create a ContentResourceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentResourceType we want to update
     *   }
     * })
     */
    upsert<T extends ContentResourceTypeUpsertArgs>(args: SelectSubset<T, ContentResourceTypeUpsertArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentResourceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeCountArgs} args - Arguments to filter ContentResourceTypes to count.
     * @example
     * // Count the number of ContentResourceTypes
     * const count = await prisma.contentResourceType.count({
     *   where: {
     *     // ... the filter for the ContentResourceTypes we want to count
     *   }
     * })
    **/
    count<T extends ContentResourceTypeCountArgs>(
      args?: Subset<T, ContentResourceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentResourceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentResourceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentResourceTypeAggregateArgs>(args: Subset<T, ContentResourceTypeAggregateArgs>): Prisma.PrismaPromise<GetContentResourceTypeAggregateType<T>>

    /**
     * Group by ContentResourceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentResourceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentResourceTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContentResourceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentResourceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentResourceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentResourceType model
   */
  readonly fields: ContentResourceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentResourceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentResourceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentResources<T extends ContentResourceType$contentResourcesArgs<ExtArgs> = {}>(args?: Subset<T, ContentResourceType$contentResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentResourceType model
   */
  interface ContentResourceTypeFieldRefs {
    readonly id: FieldRef<"ContentResourceType", 'Int'>
    readonly type: FieldRef<"ContentResourceType", 'String'>
    readonly icon: FieldRef<"ContentResourceType", 'String'>
    readonly color: FieldRef<"ContentResourceType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentResourceType findUnique
   */
  export type ContentResourceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceType to fetch.
     */
    where: ContentResourceTypeWhereUniqueInput
  }

  /**
   * ContentResourceType findUniqueOrThrow
   */
  export type ContentResourceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceType to fetch.
     */
    where: ContentResourceTypeWhereUniqueInput
  }

  /**
   * ContentResourceType findFirst
   */
  export type ContentResourceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceType to fetch.
     */
    where?: ContentResourceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceTypes to fetch.
     */
    orderBy?: ContentResourceTypeOrderByWithRelationInput | ContentResourceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResourceTypes.
     */
    cursor?: ContentResourceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResourceTypes.
     */
    distinct?: ContentResourceTypeScalarFieldEnum | ContentResourceTypeScalarFieldEnum[]
  }

  /**
   * ContentResourceType findFirstOrThrow
   */
  export type ContentResourceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceType to fetch.
     */
    where?: ContentResourceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceTypes to fetch.
     */
    orderBy?: ContentResourceTypeOrderByWithRelationInput | ContentResourceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResourceTypes.
     */
    cursor?: ContentResourceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResourceTypes.
     */
    distinct?: ContentResourceTypeScalarFieldEnum | ContentResourceTypeScalarFieldEnum[]
  }

  /**
   * ContentResourceType findMany
   */
  export type ContentResourceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceTypes to fetch.
     */
    where?: ContentResourceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceTypes to fetch.
     */
    orderBy?: ContentResourceTypeOrderByWithRelationInput | ContentResourceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentResourceTypes.
     */
    cursor?: ContentResourceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceTypes.
     */
    skip?: number
    distinct?: ContentResourceTypeScalarFieldEnum | ContentResourceTypeScalarFieldEnum[]
  }

  /**
   * ContentResourceType create
   */
  export type ContentResourceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentResourceType.
     */
    data: XOR<ContentResourceTypeCreateInput, ContentResourceTypeUncheckedCreateInput>
  }

  /**
   * ContentResourceType createMany
   */
  export type ContentResourceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentResourceTypes.
     */
    data: ContentResourceTypeCreateManyInput | ContentResourceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentResourceType createManyAndReturn
   */
  export type ContentResourceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ContentResourceTypes.
     */
    data: ContentResourceTypeCreateManyInput | ContentResourceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentResourceType update
   */
  export type ContentResourceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentResourceType.
     */
    data: XOR<ContentResourceTypeUpdateInput, ContentResourceTypeUncheckedUpdateInput>
    /**
     * Choose, which ContentResourceType to update.
     */
    where: ContentResourceTypeWhereUniqueInput
  }

  /**
   * ContentResourceType updateMany
   */
  export type ContentResourceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentResourceTypes.
     */
    data: XOR<ContentResourceTypeUpdateManyMutationInput, ContentResourceTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContentResourceTypes to update
     */
    where?: ContentResourceTypeWhereInput
    /**
     * Limit how many ContentResourceTypes to update.
     */
    limit?: number
  }

  /**
   * ContentResourceType updateManyAndReturn
   */
  export type ContentResourceTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * The data used to update ContentResourceTypes.
     */
    data: XOR<ContentResourceTypeUpdateManyMutationInput, ContentResourceTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContentResourceTypes to update
     */
    where?: ContentResourceTypeWhereInput
    /**
     * Limit how many ContentResourceTypes to update.
     */
    limit?: number
  }

  /**
   * ContentResourceType upsert
   */
  export type ContentResourceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentResourceType to update in case it exists.
     */
    where: ContentResourceTypeWhereUniqueInput
    /**
     * In case the ContentResourceType found by the `where` argument doesn't exist, create a new ContentResourceType with this data.
     */
    create: XOR<ContentResourceTypeCreateInput, ContentResourceTypeUncheckedCreateInput>
    /**
     * In case the ContentResourceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentResourceTypeUpdateInput, ContentResourceTypeUncheckedUpdateInput>
  }

  /**
   * ContentResourceType delete
   */
  export type ContentResourceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
    /**
     * Filter which ContentResourceType to delete.
     */
    where: ContentResourceTypeWhereUniqueInput
  }

  /**
   * ContentResourceType deleteMany
   */
  export type ContentResourceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResourceTypes to delete
     */
    where?: ContentResourceTypeWhereInput
    /**
     * Limit how many ContentResourceTypes to delete.
     */
    limit?: number
  }

  /**
   * ContentResourceType.contentResources
   */
  export type ContentResourceType$contentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    where?: ContentResourceWhereInput
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    cursor?: ContentResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * ContentResourceType without action
   */
  export type ContentResourceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceType
     */
    select?: ContentResourceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceType
     */
    omit?: ContentResourceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceTypeInclude<ExtArgs> | null
  }


  /**
   * Model ContentResourceArea
   */

  export type AggregateContentResourceArea = {
    _count: ContentResourceAreaCountAggregateOutputType | null
    _avg: ContentResourceAreaAvgAggregateOutputType | null
    _sum: ContentResourceAreaSumAggregateOutputType | null
    _min: ContentResourceAreaMinAggregateOutputType | null
    _max: ContentResourceAreaMaxAggregateOutputType | null
  }

  export type ContentResourceAreaAvgAggregateOutputType = {
    id: number | null
  }

  export type ContentResourceAreaSumAggregateOutputType = {
    id: number | null
  }

  export type ContentResourceAreaMinAggregateOutputType = {
    id: number | null
    area: string | null
    tagline: string | null
  }

  export type ContentResourceAreaMaxAggregateOutputType = {
    id: number | null
    area: string | null
    tagline: string | null
  }

  export type ContentResourceAreaCountAggregateOutputType = {
    id: number
    area: number
    tagline: number
    _all: number
  }


  export type ContentResourceAreaAvgAggregateInputType = {
    id?: true
  }

  export type ContentResourceAreaSumAggregateInputType = {
    id?: true
  }

  export type ContentResourceAreaMinAggregateInputType = {
    id?: true
    area?: true
    tagline?: true
  }

  export type ContentResourceAreaMaxAggregateInputType = {
    id?: true
    area?: true
    tagline?: true
  }

  export type ContentResourceAreaCountAggregateInputType = {
    id?: true
    area?: true
    tagline?: true
    _all?: true
  }

  export type ContentResourceAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResourceArea to aggregate.
     */
    where?: ContentResourceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceAreas to fetch.
     */
    orderBy?: ContentResourceAreaOrderByWithRelationInput | ContentResourceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentResourceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentResourceAreas
    **/
    _count?: true | ContentResourceAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentResourceAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentResourceAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentResourceAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentResourceAreaMaxAggregateInputType
  }

  export type GetContentResourceAreaAggregateType<T extends ContentResourceAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateContentResourceArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentResourceArea[P]>
      : GetScalarType<T[P], AggregateContentResourceArea[P]>
  }




  export type ContentResourceAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceAreaWhereInput
    orderBy?: ContentResourceAreaOrderByWithAggregationInput | ContentResourceAreaOrderByWithAggregationInput[]
    by: ContentResourceAreaScalarFieldEnum[] | ContentResourceAreaScalarFieldEnum
    having?: ContentResourceAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentResourceAreaCountAggregateInputType | true
    _avg?: ContentResourceAreaAvgAggregateInputType
    _sum?: ContentResourceAreaSumAggregateInputType
    _min?: ContentResourceAreaMinAggregateInputType
    _max?: ContentResourceAreaMaxAggregateInputType
  }

  export type ContentResourceAreaGroupByOutputType = {
    id: number
    area: string
    tagline: string | null
    _count: ContentResourceAreaCountAggregateOutputType | null
    _avg: ContentResourceAreaAvgAggregateOutputType | null
    _sum: ContentResourceAreaSumAggregateOutputType | null
    _min: ContentResourceAreaMinAggregateOutputType | null
    _max: ContentResourceAreaMaxAggregateOutputType | null
  }

  type GetContentResourceAreaGroupByPayload<T extends ContentResourceAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentResourceAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentResourceAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentResourceAreaGroupByOutputType[P]>
            : GetScalarType<T[P], ContentResourceAreaGroupByOutputType[P]>
        }
      >
    >


  export type ContentResourceAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area?: boolean
    tagline?: boolean
    contentResources?: boolean | ContentResourceArea$contentResourcesArgs<ExtArgs>
    _count?: boolean | ContentResourceAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentResourceArea"]>

  export type ContentResourceAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area?: boolean
    tagline?: boolean
  }, ExtArgs["result"]["contentResourceArea"]>

  export type ContentResourceAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area?: boolean
    tagline?: boolean
  }, ExtArgs["result"]["contentResourceArea"]>

  export type ContentResourceAreaSelectScalar = {
    id?: boolean
    area?: boolean
    tagline?: boolean
  }

  export type ContentResourceAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "area" | "tagline", ExtArgs["result"]["contentResourceArea"]>
  export type ContentResourceAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentResources?: boolean | ContentResourceArea$contentResourcesArgs<ExtArgs>
    _count?: boolean | ContentResourceAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentResourceAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentResourceAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentResourceAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentResourceArea"
    objects: {
      contentResources: Prisma.$ContentResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      area: string
      tagline: string | null
    }, ExtArgs["result"]["contentResourceArea"]>
    composites: {}
  }

  type ContentResourceAreaGetPayload<S extends boolean | null | undefined | ContentResourceAreaDefaultArgs> = $Result.GetResult<Prisma.$ContentResourceAreaPayload, S>

  type ContentResourceAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentResourceAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentResourceAreaCountAggregateInputType | true
    }

  export interface ContentResourceAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentResourceArea'], meta: { name: 'ContentResourceArea' } }
    /**
     * Find zero or one ContentResourceArea that matches the filter.
     * @param {ContentResourceAreaFindUniqueArgs} args - Arguments to find a ContentResourceArea
     * @example
     * // Get one ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentResourceAreaFindUniqueArgs>(args: SelectSubset<T, ContentResourceAreaFindUniqueArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentResourceArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentResourceAreaFindUniqueOrThrowArgs} args - Arguments to find a ContentResourceArea
     * @example
     * // Get one ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentResourceAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentResourceAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResourceArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaFindFirstArgs} args - Arguments to find a ContentResourceArea
     * @example
     * // Get one ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentResourceAreaFindFirstArgs>(args?: SelectSubset<T, ContentResourceAreaFindFirstArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResourceArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaFindFirstOrThrowArgs} args - Arguments to find a ContentResourceArea
     * @example
     * // Get one ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentResourceAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentResourceAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentResourceAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentResourceAreas
     * const contentResourceAreas = await prisma.contentResourceArea.findMany()
     * 
     * // Get first 10 ContentResourceAreas
     * const contentResourceAreas = await prisma.contentResourceArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentResourceAreaWithIdOnly = await prisma.contentResourceArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentResourceAreaFindManyArgs>(args?: SelectSubset<T, ContentResourceAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentResourceArea.
     * @param {ContentResourceAreaCreateArgs} args - Arguments to create a ContentResourceArea.
     * @example
     * // Create one ContentResourceArea
     * const ContentResourceArea = await prisma.contentResourceArea.create({
     *   data: {
     *     // ... data to create a ContentResourceArea
     *   }
     * })
     * 
     */
    create<T extends ContentResourceAreaCreateArgs>(args: SelectSubset<T, ContentResourceAreaCreateArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentResourceAreas.
     * @param {ContentResourceAreaCreateManyArgs} args - Arguments to create many ContentResourceAreas.
     * @example
     * // Create many ContentResourceAreas
     * const contentResourceArea = await prisma.contentResourceArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentResourceAreaCreateManyArgs>(args?: SelectSubset<T, ContentResourceAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentResourceAreas and returns the data saved in the database.
     * @param {ContentResourceAreaCreateManyAndReturnArgs} args - Arguments to create many ContentResourceAreas.
     * @example
     * // Create many ContentResourceAreas
     * const contentResourceArea = await prisma.contentResourceArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentResourceAreas and only return the `id`
     * const contentResourceAreaWithIdOnly = await prisma.contentResourceArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentResourceAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentResourceAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentResourceArea.
     * @param {ContentResourceAreaDeleteArgs} args - Arguments to delete one ContentResourceArea.
     * @example
     * // Delete one ContentResourceArea
     * const ContentResourceArea = await prisma.contentResourceArea.delete({
     *   where: {
     *     // ... filter to delete one ContentResourceArea
     *   }
     * })
     * 
     */
    delete<T extends ContentResourceAreaDeleteArgs>(args: SelectSubset<T, ContentResourceAreaDeleteArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentResourceArea.
     * @param {ContentResourceAreaUpdateArgs} args - Arguments to update one ContentResourceArea.
     * @example
     * // Update one ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentResourceAreaUpdateArgs>(args: SelectSubset<T, ContentResourceAreaUpdateArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentResourceAreas.
     * @param {ContentResourceAreaDeleteManyArgs} args - Arguments to filter ContentResourceAreas to delete.
     * @example
     * // Delete a few ContentResourceAreas
     * const { count } = await prisma.contentResourceArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentResourceAreaDeleteManyArgs>(args?: SelectSubset<T, ContentResourceAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResourceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentResourceAreas
     * const contentResourceArea = await prisma.contentResourceArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentResourceAreaUpdateManyArgs>(args: SelectSubset<T, ContentResourceAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResourceAreas and returns the data updated in the database.
     * @param {ContentResourceAreaUpdateManyAndReturnArgs} args - Arguments to update many ContentResourceAreas.
     * @example
     * // Update many ContentResourceAreas
     * const contentResourceArea = await prisma.contentResourceArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentResourceAreas and only return the `id`
     * const contentResourceAreaWithIdOnly = await prisma.contentResourceArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentResourceAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentResourceAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentResourceArea.
     * @param {ContentResourceAreaUpsertArgs} args - Arguments to update or create a ContentResourceArea.
     * @example
     * // Update or create a ContentResourceArea
     * const contentResourceArea = await prisma.contentResourceArea.upsert({
     *   create: {
     *     // ... data to create a ContentResourceArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentResourceArea we want to update
     *   }
     * })
     */
    upsert<T extends ContentResourceAreaUpsertArgs>(args: SelectSubset<T, ContentResourceAreaUpsertArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentResourceAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaCountArgs} args - Arguments to filter ContentResourceAreas to count.
     * @example
     * // Count the number of ContentResourceAreas
     * const count = await prisma.contentResourceArea.count({
     *   where: {
     *     // ... the filter for the ContentResourceAreas we want to count
     *   }
     * })
    **/
    count<T extends ContentResourceAreaCountArgs>(
      args?: Subset<T, ContentResourceAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentResourceAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentResourceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentResourceAreaAggregateArgs>(args: Subset<T, ContentResourceAreaAggregateArgs>): Prisma.PrismaPromise<GetContentResourceAreaAggregateType<T>>

    /**
     * Group by ContentResourceArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentResourceAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentResourceAreaGroupByArgs['orderBy'] }
        : { orderBy?: ContentResourceAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentResourceAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentResourceAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentResourceArea model
   */
  readonly fields: ContentResourceAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentResourceArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentResourceAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentResources<T extends ContentResourceArea$contentResourcesArgs<ExtArgs> = {}>(args?: Subset<T, ContentResourceArea$contentResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentResourceArea model
   */
  interface ContentResourceAreaFieldRefs {
    readonly id: FieldRef<"ContentResourceArea", 'Int'>
    readonly area: FieldRef<"ContentResourceArea", 'String'>
    readonly tagline: FieldRef<"ContentResourceArea", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentResourceArea findUnique
   */
  export type ContentResourceAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceArea to fetch.
     */
    where: ContentResourceAreaWhereUniqueInput
  }

  /**
   * ContentResourceArea findUniqueOrThrow
   */
  export type ContentResourceAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceArea to fetch.
     */
    where: ContentResourceAreaWhereUniqueInput
  }

  /**
   * ContentResourceArea findFirst
   */
  export type ContentResourceAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceArea to fetch.
     */
    where?: ContentResourceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceAreas to fetch.
     */
    orderBy?: ContentResourceAreaOrderByWithRelationInput | ContentResourceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResourceAreas.
     */
    cursor?: ContentResourceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResourceAreas.
     */
    distinct?: ContentResourceAreaScalarFieldEnum | ContentResourceAreaScalarFieldEnum[]
  }

  /**
   * ContentResourceArea findFirstOrThrow
   */
  export type ContentResourceAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceArea to fetch.
     */
    where?: ContentResourceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceAreas to fetch.
     */
    orderBy?: ContentResourceAreaOrderByWithRelationInput | ContentResourceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResourceAreas.
     */
    cursor?: ContentResourceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResourceAreas.
     */
    distinct?: ContentResourceAreaScalarFieldEnum | ContentResourceAreaScalarFieldEnum[]
  }

  /**
   * ContentResourceArea findMany
   */
  export type ContentResourceAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter, which ContentResourceAreas to fetch.
     */
    where?: ContentResourceAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResourceAreas to fetch.
     */
    orderBy?: ContentResourceAreaOrderByWithRelationInput | ContentResourceAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentResourceAreas.
     */
    cursor?: ContentResourceAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResourceAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResourceAreas.
     */
    skip?: number
    distinct?: ContentResourceAreaScalarFieldEnum | ContentResourceAreaScalarFieldEnum[]
  }

  /**
   * ContentResourceArea create
   */
  export type ContentResourceAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentResourceArea.
     */
    data: XOR<ContentResourceAreaCreateInput, ContentResourceAreaUncheckedCreateInput>
  }

  /**
   * ContentResourceArea createMany
   */
  export type ContentResourceAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentResourceAreas.
     */
    data: ContentResourceAreaCreateManyInput | ContentResourceAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentResourceArea createManyAndReturn
   */
  export type ContentResourceAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * The data used to create many ContentResourceAreas.
     */
    data: ContentResourceAreaCreateManyInput | ContentResourceAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentResourceArea update
   */
  export type ContentResourceAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentResourceArea.
     */
    data: XOR<ContentResourceAreaUpdateInput, ContentResourceAreaUncheckedUpdateInput>
    /**
     * Choose, which ContentResourceArea to update.
     */
    where: ContentResourceAreaWhereUniqueInput
  }

  /**
   * ContentResourceArea updateMany
   */
  export type ContentResourceAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentResourceAreas.
     */
    data: XOR<ContentResourceAreaUpdateManyMutationInput, ContentResourceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ContentResourceAreas to update
     */
    where?: ContentResourceAreaWhereInput
    /**
     * Limit how many ContentResourceAreas to update.
     */
    limit?: number
  }

  /**
   * ContentResourceArea updateManyAndReturn
   */
  export type ContentResourceAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * The data used to update ContentResourceAreas.
     */
    data: XOR<ContentResourceAreaUpdateManyMutationInput, ContentResourceAreaUncheckedUpdateManyInput>
    /**
     * Filter which ContentResourceAreas to update
     */
    where?: ContentResourceAreaWhereInput
    /**
     * Limit how many ContentResourceAreas to update.
     */
    limit?: number
  }

  /**
   * ContentResourceArea upsert
   */
  export type ContentResourceAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentResourceArea to update in case it exists.
     */
    where: ContentResourceAreaWhereUniqueInput
    /**
     * In case the ContentResourceArea found by the `where` argument doesn't exist, create a new ContentResourceArea with this data.
     */
    create: XOR<ContentResourceAreaCreateInput, ContentResourceAreaUncheckedCreateInput>
    /**
     * In case the ContentResourceArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentResourceAreaUpdateInput, ContentResourceAreaUncheckedUpdateInput>
  }

  /**
   * ContentResourceArea delete
   */
  export type ContentResourceAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
    /**
     * Filter which ContentResourceArea to delete.
     */
    where: ContentResourceAreaWhereUniqueInput
  }

  /**
   * ContentResourceArea deleteMany
   */
  export type ContentResourceAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResourceAreas to delete
     */
    where?: ContentResourceAreaWhereInput
    /**
     * Limit how many ContentResourceAreas to delete.
     */
    limit?: number
  }

  /**
   * ContentResourceArea.contentResources
   */
  export type ContentResourceArea$contentResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    where?: ContentResourceWhereInput
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    cursor?: ContentResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * ContentResourceArea without action
   */
  export type ContentResourceAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResourceArea
     */
    select?: ContentResourceAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResourceArea
     */
    omit?: ContentResourceAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceAreaInclude<ExtArgs> | null
  }


  /**
   * Model ContentResource
   */

  export type AggregateContentResource = {
    _count: ContentResourceCountAggregateOutputType | null
    _avg: ContentResourceAvgAggregateOutputType | null
    _sum: ContentResourceSumAggregateOutputType | null
    _min: ContentResourceMinAggregateOutputType | null
    _max: ContentResourceMaxAggregateOutputType | null
  }

  export type ContentResourceAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
    areaId: number | null
  }

  export type ContentResourceSumAggregateOutputType = {
    id: number | null
    typeId: number | null
    areaId: number | null
  }

  export type ContentResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    typeId: number | null
    icon: string | null
    authorId: string | null
    date: Date | null
    areaId: number | null
    authorString: string | null
  }

  export type ContentResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    typeId: number | null
    icon: string | null
    authorId: string | null
    date: Date | null
    areaId: number | null
    authorString: string | null
  }

  export type ContentResourceCountAggregateOutputType = {
    id: number
    href: number
    title: number
    subtitle: number
    typeId: number
    icon: number
    authorId: number
    date: number
    areaId: number
    authorString: number
    _all: number
  }


  export type ContentResourceAvgAggregateInputType = {
    id?: true
    typeId?: true
    areaId?: true
  }

  export type ContentResourceSumAggregateInputType = {
    id?: true
    typeId?: true
    areaId?: true
  }

  export type ContentResourceMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    typeId?: true
    icon?: true
    authorId?: true
    date?: true
    areaId?: true
    authorString?: true
  }

  export type ContentResourceMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    typeId?: true
    icon?: true
    authorId?: true
    date?: true
    areaId?: true
    authorString?: true
  }

  export type ContentResourceCountAggregateInputType = {
    id?: true
    href?: true
    title?: true
    subtitle?: true
    typeId?: true
    icon?: true
    authorId?: true
    date?: true
    areaId?: true
    authorString?: true
    _all?: true
  }

  export type ContentResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResource to aggregate.
     */
    where?: ContentResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResources to fetch.
     */
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentResources
    **/
    _count?: true | ContentResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentResourceMaxAggregateInputType
  }

  export type GetContentResourceAggregateType<T extends ContentResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateContentResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentResource[P]>
      : GetScalarType<T[P], AggregateContentResource[P]>
  }




  export type ContentResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentResourceWhereInput
    orderBy?: ContentResourceOrderByWithAggregationInput | ContentResourceOrderByWithAggregationInput[]
    by: ContentResourceScalarFieldEnum[] | ContentResourceScalarFieldEnum
    having?: ContentResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentResourceCountAggregateInputType | true
    _avg?: ContentResourceAvgAggregateInputType
    _sum?: ContentResourceSumAggregateInputType
    _min?: ContentResourceMinAggregateInputType
    _max?: ContentResourceMaxAggregateInputType
  }

  export type ContentResourceGroupByOutputType = {
    id: number
    href: JsonValue
    title: string
    subtitle: string | null
    typeId: number
    icon: string | null
    authorId: string | null
    date: Date
    areaId: number
    authorString: string | null
    _count: ContentResourceCountAggregateOutputType | null
    _avg: ContentResourceAvgAggregateOutputType | null
    _sum: ContentResourceSumAggregateOutputType | null
    _min: ContentResourceMinAggregateOutputType | null
    _max: ContentResourceMaxAggregateOutputType | null
  }

  type GetContentResourceGroupByPayload<T extends ContentResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ContentResourceGroupByOutputType[P]>
        }
      >
    >


  export type ContentResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    href?: boolean
    title?: boolean
    subtitle?: boolean
    typeId?: boolean
    icon?: boolean
    authorId?: boolean
    date?: boolean
    areaId?: boolean
    authorString?: boolean
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentResource"]>

  export type ContentResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    href?: boolean
    title?: boolean
    subtitle?: boolean
    typeId?: boolean
    icon?: boolean
    authorId?: boolean
    date?: boolean
    areaId?: boolean
    authorString?: boolean
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentResource"]>

  export type ContentResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    href?: boolean
    title?: boolean
    subtitle?: boolean
    typeId?: boolean
    icon?: boolean
    authorId?: boolean
    date?: boolean
    areaId?: boolean
    authorString?: boolean
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentResource"]>

  export type ContentResourceSelectScalar = {
    id?: boolean
    href?: boolean
    title?: boolean
    subtitle?: boolean
    typeId?: boolean
    icon?: boolean
    authorId?: boolean
    date?: boolean
    areaId?: boolean
    authorString?: boolean
  }

  export type ContentResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "href" | "title" | "subtitle" | "typeId" | "icon" | "authorId" | "date" | "areaId" | "authorString", ExtArgs["result"]["contentResource"]>
  export type ContentResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }
  export type ContentResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }
  export type ContentResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | ContentResourceAreaDefaultArgs<ExtArgs>
    author?: boolean | ContentResource$authorArgs<ExtArgs>
    type?: boolean | ContentResourceTypeDefaultArgs<ExtArgs>
  }

  export type $ContentResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentResource"
    objects: {
      area: Prisma.$ContentResourceAreaPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs> | null
      type: Prisma.$ContentResourceTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      href: Prisma.JsonValue
      title: string
      subtitle: string | null
      typeId: number
      icon: string | null
      authorId: string | null
      date: Date
      areaId: number
      authorString: string | null
    }, ExtArgs["result"]["contentResource"]>
    composites: {}
  }

  type ContentResourceGetPayload<S extends boolean | null | undefined | ContentResourceDefaultArgs> = $Result.GetResult<Prisma.$ContentResourcePayload, S>

  type ContentResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentResourceCountAggregateInputType | true
    }

  export interface ContentResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentResource'], meta: { name: 'ContentResource' } }
    /**
     * Find zero or one ContentResource that matches the filter.
     * @param {ContentResourceFindUniqueArgs} args - Arguments to find a ContentResource
     * @example
     * // Get one ContentResource
     * const contentResource = await prisma.contentResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentResourceFindUniqueArgs>(args: SelectSubset<T, ContentResourceFindUniqueArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentResourceFindUniqueOrThrowArgs} args - Arguments to find a ContentResource
     * @example
     * // Get one ContentResource
     * const contentResource = await prisma.contentResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceFindFirstArgs} args - Arguments to find a ContentResource
     * @example
     * // Get one ContentResource
     * const contentResource = await prisma.contentResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentResourceFindFirstArgs>(args?: SelectSubset<T, ContentResourceFindFirstArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceFindFirstOrThrowArgs} args - Arguments to find a ContentResource
     * @example
     * // Get one ContentResource
     * const contentResource = await prisma.contentResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentResources
     * const contentResources = await prisma.contentResource.findMany()
     * 
     * // Get first 10 ContentResources
     * const contentResources = await prisma.contentResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentResourceWithIdOnly = await prisma.contentResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentResourceFindManyArgs>(args?: SelectSubset<T, ContentResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentResource.
     * @param {ContentResourceCreateArgs} args - Arguments to create a ContentResource.
     * @example
     * // Create one ContentResource
     * const ContentResource = await prisma.contentResource.create({
     *   data: {
     *     // ... data to create a ContentResource
     *   }
     * })
     * 
     */
    create<T extends ContentResourceCreateArgs>(args: SelectSubset<T, ContentResourceCreateArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentResources.
     * @param {ContentResourceCreateManyArgs} args - Arguments to create many ContentResources.
     * @example
     * // Create many ContentResources
     * const contentResource = await prisma.contentResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentResourceCreateManyArgs>(args?: SelectSubset<T, ContentResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentResources and returns the data saved in the database.
     * @param {ContentResourceCreateManyAndReturnArgs} args - Arguments to create many ContentResources.
     * @example
     * // Create many ContentResources
     * const contentResource = await prisma.contentResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentResources and only return the `id`
     * const contentResourceWithIdOnly = await prisma.contentResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentResource.
     * @param {ContentResourceDeleteArgs} args - Arguments to delete one ContentResource.
     * @example
     * // Delete one ContentResource
     * const ContentResource = await prisma.contentResource.delete({
     *   where: {
     *     // ... filter to delete one ContentResource
     *   }
     * })
     * 
     */
    delete<T extends ContentResourceDeleteArgs>(args: SelectSubset<T, ContentResourceDeleteArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentResource.
     * @param {ContentResourceUpdateArgs} args - Arguments to update one ContentResource.
     * @example
     * // Update one ContentResource
     * const contentResource = await prisma.contentResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentResourceUpdateArgs>(args: SelectSubset<T, ContentResourceUpdateArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentResources.
     * @param {ContentResourceDeleteManyArgs} args - Arguments to filter ContentResources to delete.
     * @example
     * // Delete a few ContentResources
     * const { count } = await prisma.contentResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentResourceDeleteManyArgs>(args?: SelectSubset<T, ContentResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentResources
     * const contentResource = await prisma.contentResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentResourceUpdateManyArgs>(args: SelectSubset<T, ContentResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentResources and returns the data updated in the database.
     * @param {ContentResourceUpdateManyAndReturnArgs} args - Arguments to update many ContentResources.
     * @example
     * // Update many ContentResources
     * const contentResource = await prisma.contentResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentResources and only return the `id`
     * const contentResourceWithIdOnly = await prisma.contentResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentResource.
     * @param {ContentResourceUpsertArgs} args - Arguments to update or create a ContentResource.
     * @example
     * // Update or create a ContentResource
     * const contentResource = await prisma.contentResource.upsert({
     *   create: {
     *     // ... data to create a ContentResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentResource we want to update
     *   }
     * })
     */
    upsert<T extends ContentResourceUpsertArgs>(args: SelectSubset<T, ContentResourceUpsertArgs<ExtArgs>>): Prisma__ContentResourceClient<$Result.GetResult<Prisma.$ContentResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceCountArgs} args - Arguments to filter ContentResources to count.
     * @example
     * // Count the number of ContentResources
     * const count = await prisma.contentResource.count({
     *   where: {
     *     // ... the filter for the ContentResources we want to count
     *   }
     * })
    **/
    count<T extends ContentResourceCountArgs>(
      args?: Subset<T, ContentResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentResourceAggregateArgs>(args: Subset<T, ContentResourceAggregateArgs>): Prisma.PrismaPromise<GetContentResourceAggregateType<T>>

    /**
     * Group by ContentResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentResourceGroupByArgs['orderBy'] }
        : { orderBy?: ContentResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentResource model
   */
  readonly fields: ContentResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends ContentResourceAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentResourceAreaDefaultArgs<ExtArgs>>): Prisma__ContentResourceAreaClient<$Result.GetResult<Prisma.$ContentResourceAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends ContentResource$authorArgs<ExtArgs> = {}>(args?: Subset<T, ContentResource$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    type<T extends ContentResourceTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentResourceTypeDefaultArgs<ExtArgs>>): Prisma__ContentResourceTypeClient<$Result.GetResult<Prisma.$ContentResourceTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentResource model
   */
  interface ContentResourceFieldRefs {
    readonly id: FieldRef<"ContentResource", 'Int'>
    readonly href: FieldRef<"ContentResource", 'Json'>
    readonly title: FieldRef<"ContentResource", 'String'>
    readonly subtitle: FieldRef<"ContentResource", 'String'>
    readonly typeId: FieldRef<"ContentResource", 'Int'>
    readonly icon: FieldRef<"ContentResource", 'String'>
    readonly authorId: FieldRef<"ContentResource", 'String'>
    readonly date: FieldRef<"ContentResource", 'DateTime'>
    readonly areaId: FieldRef<"ContentResource", 'Int'>
    readonly authorString: FieldRef<"ContentResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentResource findUnique
   */
  export type ContentResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter, which ContentResource to fetch.
     */
    where: ContentResourceWhereUniqueInput
  }

  /**
   * ContentResource findUniqueOrThrow
   */
  export type ContentResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter, which ContentResource to fetch.
     */
    where: ContentResourceWhereUniqueInput
  }

  /**
   * ContentResource findFirst
   */
  export type ContentResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter, which ContentResource to fetch.
     */
    where?: ContentResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResources to fetch.
     */
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResources.
     */
    cursor?: ContentResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResources.
     */
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * ContentResource findFirstOrThrow
   */
  export type ContentResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter, which ContentResource to fetch.
     */
    where?: ContentResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResources to fetch.
     */
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentResources.
     */
    cursor?: ContentResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentResources.
     */
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * ContentResource findMany
   */
  export type ContentResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter, which ContentResources to fetch.
     */
    where?: ContentResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentResources to fetch.
     */
    orderBy?: ContentResourceOrderByWithRelationInput | ContentResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentResources.
     */
    cursor?: ContentResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentResources.
     */
    skip?: number
    distinct?: ContentResourceScalarFieldEnum | ContentResourceScalarFieldEnum[]
  }

  /**
   * ContentResource create
   */
  export type ContentResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentResource.
     */
    data: XOR<ContentResourceCreateInput, ContentResourceUncheckedCreateInput>
  }

  /**
   * ContentResource createMany
   */
  export type ContentResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentResources.
     */
    data: ContentResourceCreateManyInput | ContentResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentResource createManyAndReturn
   */
  export type ContentResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * The data used to create many ContentResources.
     */
    data: ContentResourceCreateManyInput | ContentResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentResource update
   */
  export type ContentResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentResource.
     */
    data: XOR<ContentResourceUpdateInput, ContentResourceUncheckedUpdateInput>
    /**
     * Choose, which ContentResource to update.
     */
    where: ContentResourceWhereUniqueInput
  }

  /**
   * ContentResource updateMany
   */
  export type ContentResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentResources.
     */
    data: XOR<ContentResourceUpdateManyMutationInput, ContentResourceUncheckedUpdateManyInput>
    /**
     * Filter which ContentResources to update
     */
    where?: ContentResourceWhereInput
    /**
     * Limit how many ContentResources to update.
     */
    limit?: number
  }

  /**
   * ContentResource updateManyAndReturn
   */
  export type ContentResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * The data used to update ContentResources.
     */
    data: XOR<ContentResourceUpdateManyMutationInput, ContentResourceUncheckedUpdateManyInput>
    /**
     * Filter which ContentResources to update
     */
    where?: ContentResourceWhereInput
    /**
     * Limit how many ContentResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentResource upsert
   */
  export type ContentResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentResource to update in case it exists.
     */
    where: ContentResourceWhereUniqueInput
    /**
     * In case the ContentResource found by the `where` argument doesn't exist, create a new ContentResource with this data.
     */
    create: XOR<ContentResourceCreateInput, ContentResourceUncheckedCreateInput>
    /**
     * In case the ContentResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentResourceUpdateInput, ContentResourceUncheckedUpdateInput>
  }

  /**
   * ContentResource delete
   */
  export type ContentResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
    /**
     * Filter which ContentResource to delete.
     */
    where: ContentResourceWhereUniqueInput
  }

  /**
   * ContentResource deleteMany
   */
  export type ContentResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentResources to delete
     */
    where?: ContentResourceWhereInput
    /**
     * Limit how many ContentResources to delete.
     */
    limit?: number
  }

  /**
   * ContentResource.author
   */
  export type ContentResource$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContentResource without action
   */
  export type ContentResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentResource
     */
    select?: ContentResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentResource
     */
    omit?: ContentResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentResourceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    code: 'code',
    name: 'name'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CountryLanguageScalarFieldEnum: {
    countryCode: 'countryCode',
    languageCode: 'languageCode'
  };

  export type CountryLanguageScalarFieldEnum = (typeof CountryLanguageScalarFieldEnum)[keyof typeof CountryLanguageScalarFieldEnum]


  export const CountryCurrencyScalarFieldEnum: {
    countryCode: 'countryCode',
    currencyCode: 'currencyCode'
  };

  export type CountryCurrencyScalarFieldEnum = (typeof CountryCurrencyScalarFieldEnum)[keyof typeof CountryCurrencyScalarFieldEnum]


  export const PathwayScalarFieldEnum: {
    id: 'id',
    countryCode: 'countryCode',
    name: 'name',
    link: 'link',
    description: 'description',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currencyCode: 'currencyCode',
    notes: 'notes',
    limitations: 'limitations',
    requirements: 'requirements',
    restrictions: 'restrictions',
    duration: 'duration',
    processTime: 'processTime',
    renewal: 'renewal',
    cost: 'cost',
    createdby: 'createdby'
  };

  export type PathwayScalarFieldEnum = (typeof PathwayScalarFieldEnum)[keyof typeof PathwayScalarFieldEnum]


  export const PathwayPipelineScalarFieldEnum: {
    id: 'id',
    pathwayId: 'pathwayId',
    pipeline: 'pipeline',
    note: 'note'
  };

  export type PathwayPipelineScalarFieldEnum = (typeof PathwayPipelineScalarFieldEnum)[keyof typeof PathwayPipelineScalarFieldEnum]


  export const PathwayRestrictedNationalityScalarFieldEnum: {
    pathwayId: 'pathwayId',
    countryCode: 'countryCode',
    note: 'note'
  };

  export type PathwayRestrictedNationalityScalarFieldEnum = (typeof PathwayRestrictedNationalityScalarFieldEnum)[keyof typeof PathwayRestrictedNationalityScalarFieldEnum]


  export const PathwayDocumentsScalarFieldEnum: {
    id: 'id',
    pathwayId: 'pathwayId',
    documentId: 'documentId',
    description: 'description',
    cost: 'cost',
    isRequired: 'isRequired',
    link: 'link',
    title: 'title'
  };

  export type PathwayDocumentsScalarFieldEnum = (typeof PathwayDocumentsScalarFieldEnum)[keyof typeof PathwayDocumentsScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    code: 'code',
    name: 'name',
    symbol: 'symbol'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    code: 'code',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    contentHTML: 'contentHTML',
    contentText: 'contentText',
    subtitle: 'subtitle',
    slug: 'slug',
    image: 'image',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    status: 'status',
    contentDelta: 'contentDelta',
    imageExt: 'imageExt',
    imageKey: 'imageKey'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    color: 'color'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagHierarchyScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    childId: 'childId'
  };

  export type TagHierarchyScalarFieldEnum = (typeof TagHierarchyScalarFieldEnum)[keyof typeof TagHierarchyScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    content: 'content'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    component: 'component',
    type: 'type'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const BlockFieldScalarFieldEnum: {
    id: 'id',
    blockId: 'blockId',
    name: 'name',
    type: 'type',
    options: 'options',
    slug: 'slug',
    defaultValue: 'defaultValue'
  };

  export type BlockFieldScalarFieldEnum = (typeof BlockFieldScalarFieldEnum)[keyof typeof BlockFieldScalarFieldEnum]


  export const PostBlockScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    blockId: 'blockId',
    type: 'type',
    content: 'content',
    position: 'position'
  };

  export type PostBlockScalarFieldEnum = (typeof PostBlockScalarFieldEnum)[keyof typeof PostBlockScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    secret: 'secret',
    firstName: 'firstName',
    lastName: 'lastName',
    discordHandle: 'discordHandle',
    key: 'key',
    created: 'created'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserSocialScalarFieldEnum: {
    userId: 'userId',
    handle: 'handle',
    socialCode: 'socialCode'
  };

  export type UserSocialScalarFieldEnum = (typeof UserSocialScalarFieldEnum)[keyof typeof UserSocialScalarFieldEnum]


  export const UserRolesScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRolesScalarFieldEnum = (typeof UserRolesScalarFieldEnum)[keyof typeof UserRolesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SocialScalarFieldEnum: {
    name: 'name',
    url: 'url',
    icon: 'icon',
    codeName: 'codeName',
    profileLinkFormat: 'profileLinkFormat',
    profileEntryFormat: 'profileEntryFormat',
    darkModeColor: 'darkModeColor',
    lightModeColor: 'lightModeColor'
  };

  export type SocialScalarFieldEnum = (typeof SocialScalarFieldEnum)[keyof typeof SocialScalarFieldEnum]


  export const PostVersionHistoryScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    action: 'action',
    instanceAt: 'instanceAt'
  };

  export type PostVersionHistoryScalarFieldEnum = (typeof PostVersionHistoryScalarFieldEnum)[keyof typeof PostVersionHistoryScalarFieldEnum]


  export const PathwayTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    description: 'description'
  };

  export type PathwayTypesScalarFieldEnum = (typeof PathwayTypesScalarFieldEnum)[keyof typeof PathwayTypesScalarFieldEnum]


  export const PathwayCategoriesScalarFieldEnum: {
    pathwayId: 'pathwayId',
    pathwayTypeId: 'pathwayTypeId'
  };

  export type PathwayCategoriesScalarFieldEnum = (typeof PathwayCategoriesScalarFieldEnum)[keyof typeof PathwayCategoriesScalarFieldEnum]


  export const ContentResourceTypeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    icon: 'icon',
    color: 'color'
  };

  export type ContentResourceTypeScalarFieldEnum = (typeof ContentResourceTypeScalarFieldEnum)[keyof typeof ContentResourceTypeScalarFieldEnum]


  export const ContentResourceAreaScalarFieldEnum: {
    id: 'id',
    area: 'area',
    tagline: 'tagline'
  };

  export type ContentResourceAreaScalarFieldEnum = (typeof ContentResourceAreaScalarFieldEnum)[keyof typeof ContentResourceAreaScalarFieldEnum]


  export const ContentResourceScalarFieldEnum: {
    id: 'id',
    href: 'href',
    title: 'title',
    subtitle: 'subtitle',
    typeId: 'typeId',
    icon: 'icon',
    authorId: 'authorId',
    date: 'date',
    areaId: 'areaId',
    authorString: 'authorString'
  };

  export type ContentResourceScalarFieldEnum = (typeof ContentResourceScalarFieldEnum)[keyof typeof ContentResourceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'PathwayType'
   */
  export type EnumPathwayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PathwayType'>
    


  /**
   * Reference to a field of type 'PathwayType[]'
   */
  export type ListEnumPathwayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PathwayType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PathwayPipelines'
   */
  export type EnumPathwayPipelinesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PathwayPipelines'>
    


  /**
   * Reference to a field of type 'PathwayPipelines[]'
   */
  export type ListEnumPathwayPipelinesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PathwayPipelines[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    value?: StringFilter<"Settings"> | string
  }, "id" | "key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: StringWithAggregatesFilter<"Settings"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    code?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    countryCurrencies?: CountryCurrencyListRelationFilter
    countryLanguages?: CountryLanguageListRelationFilter
    restrictedPathways?: PathwayRestrictedNationalityListRelationFilter
    pathways?: PathwayListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    countryCurrencies?: CountryCurrencyOrderByRelationAggregateInput
    countryLanguages?: CountryLanguageOrderByRelationAggregateInput
    restrictedPathways?: PathwayRestrictedNationalityOrderByRelationAggregateInput
    pathways?: PathwayOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    countryCurrencies?: CountryCurrencyListRelationFilter
    countryLanguages?: CountryLanguageListRelationFilter
    restrictedPathways?: PathwayRestrictedNationalityListRelationFilter
    pathways?: PathwayListRelationFilter
  }, "code" | "code">

  export type CountryOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
  }

  export type CountryLanguageWhereInput = {
    AND?: CountryLanguageWhereInput | CountryLanguageWhereInput[]
    OR?: CountryLanguageWhereInput[]
    NOT?: CountryLanguageWhereInput | CountryLanguageWhereInput[]
    countryCode?: StringFilter<"CountryLanguage"> | string
    languageCode?: StringFilter<"CountryLanguage"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }

  export type CountryLanguageOrderByWithRelationInput = {
    countryCode?: SortOrder
    languageCode?: SortOrder
    country?: CountryOrderByWithRelationInput
    language?: LanguageOrderByWithRelationInput
  }

  export type CountryLanguageWhereUniqueInput = Prisma.AtLeast<{
    countryCode_languageCode?: CountryLanguageCountryCodeLanguageCodeCompoundUniqueInput
    AND?: CountryLanguageWhereInput | CountryLanguageWhereInput[]
    OR?: CountryLanguageWhereInput[]
    NOT?: CountryLanguageWhereInput | CountryLanguageWhereInput[]
    countryCode?: StringFilter<"CountryLanguage"> | string
    languageCode?: StringFilter<"CountryLanguage"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
  }, "countryCode_languageCode">

  export type CountryLanguageOrderByWithAggregationInput = {
    countryCode?: SortOrder
    languageCode?: SortOrder
    _count?: CountryLanguageCountOrderByAggregateInput
    _max?: CountryLanguageMaxOrderByAggregateInput
    _min?: CountryLanguageMinOrderByAggregateInput
  }

  export type CountryLanguageScalarWhereWithAggregatesInput = {
    AND?: CountryLanguageScalarWhereWithAggregatesInput | CountryLanguageScalarWhereWithAggregatesInput[]
    OR?: CountryLanguageScalarWhereWithAggregatesInput[]
    NOT?: CountryLanguageScalarWhereWithAggregatesInput | CountryLanguageScalarWhereWithAggregatesInput[]
    countryCode?: StringWithAggregatesFilter<"CountryLanguage"> | string
    languageCode?: StringWithAggregatesFilter<"CountryLanguage"> | string
  }

  export type CountryCurrencyWhereInput = {
    AND?: CountryCurrencyWhereInput | CountryCurrencyWhereInput[]
    OR?: CountryCurrencyWhereInput[]
    NOT?: CountryCurrencyWhereInput | CountryCurrencyWhereInput[]
    countryCode?: StringFilter<"CountryCurrency"> | string
    currencyCode?: StringFilter<"CountryCurrency"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type CountryCurrencyOrderByWithRelationInput = {
    countryCode?: SortOrder
    currencyCode?: SortOrder
    country?: CountryOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type CountryCurrencyWhereUniqueInput = Prisma.AtLeast<{
    countryCode_currencyCode?: CountryCurrencyCountryCodeCurrencyCodeCompoundUniqueInput
    AND?: CountryCurrencyWhereInput | CountryCurrencyWhereInput[]
    OR?: CountryCurrencyWhereInput[]
    NOT?: CountryCurrencyWhereInput | CountryCurrencyWhereInput[]
    countryCode?: StringFilter<"CountryCurrency"> | string
    currencyCode?: StringFilter<"CountryCurrency"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "countryCode_currencyCode">

  export type CountryCurrencyOrderByWithAggregationInput = {
    countryCode?: SortOrder
    currencyCode?: SortOrder
    _count?: CountryCurrencyCountOrderByAggregateInput
    _max?: CountryCurrencyMaxOrderByAggregateInput
    _min?: CountryCurrencyMinOrderByAggregateInput
  }

  export type CountryCurrencyScalarWhereWithAggregatesInput = {
    AND?: CountryCurrencyScalarWhereWithAggregatesInput | CountryCurrencyScalarWhereWithAggregatesInput[]
    OR?: CountryCurrencyScalarWhereWithAggregatesInput[]
    NOT?: CountryCurrencyScalarWhereWithAggregatesInput | CountryCurrencyScalarWhereWithAggregatesInput[]
    countryCode?: StringWithAggregatesFilter<"CountryCurrency"> | string
    currencyCode?: StringWithAggregatesFilter<"CountryCurrency"> | string
  }

  export type PathwayWhereInput = {
    AND?: PathwayWhereInput | PathwayWhereInput[]
    OR?: PathwayWhereInput[]
    NOT?: PathwayWhereInput | PathwayWhereInput[]
    id?: IntFilter<"Pathway"> | number
    countryCode?: StringFilter<"Pathway"> | string
    name?: StringFilter<"Pathway"> | string
    link?: StringFilter<"Pathway"> | string
    description?: StringFilter<"Pathway"> | string
    type?: EnumPathwayTypeFilter<"Pathway"> | $Enums.PathwayType
    createdAt?: DateTimeFilter<"Pathway"> | Date | string
    updatedAt?: DateTimeFilter<"Pathway"> | Date | string
    currencyCode?: StringFilter<"Pathway"> | string
    notes?: StringNullableListFilter<"Pathway">
    limitations?: StringNullableListFilter<"Pathway">
    requirements?: StringNullableListFilter<"Pathway">
    restrictions?: StringNullableListFilter<"Pathway">
    duration?: JsonNullableFilter<"Pathway">
    processTime?: JsonNullableFilter<"Pathway">
    renewal?: JsonNullableFilter<"Pathway">
    cost?: JsonNullableFilter<"Pathway">
    createdby?: StringFilter<"Pathway"> | string
    documents?: PathwayDocumentsListRelationFilter
    categories?: PathwayCategoriesListRelationFilter
    pipelines?: PathwayPipelineListRelationFilter
    restrictedNationalities?: PathwayRestrictedNationalityListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    CMS_User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PathwayOrderByWithRelationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    link?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyCode?: SortOrder
    notes?: SortOrder
    limitations?: SortOrder
    requirements?: SortOrder
    restrictions?: SortOrder
    duration?: SortOrderInput | SortOrder
    processTime?: SortOrderInput | SortOrder
    renewal?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdby?: SortOrder
    documents?: PathwayDocumentsOrderByRelationAggregateInput
    categories?: PathwayCategoriesOrderByRelationAggregateInput
    pipelines?: PathwayPipelineOrderByRelationAggregateInput
    restrictedNationalities?: PathwayRestrictedNationalityOrderByRelationAggregateInput
    country?: CountryOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    CMS_User?: UserOrderByWithRelationInput
  }

  export type PathwayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PathwayWhereInput | PathwayWhereInput[]
    OR?: PathwayWhereInput[]
    NOT?: PathwayWhereInput | PathwayWhereInput[]
    countryCode?: StringFilter<"Pathway"> | string
    name?: StringFilter<"Pathway"> | string
    link?: StringFilter<"Pathway"> | string
    description?: StringFilter<"Pathway"> | string
    type?: EnumPathwayTypeFilter<"Pathway"> | $Enums.PathwayType
    createdAt?: DateTimeFilter<"Pathway"> | Date | string
    updatedAt?: DateTimeFilter<"Pathway"> | Date | string
    currencyCode?: StringFilter<"Pathway"> | string
    notes?: StringNullableListFilter<"Pathway">
    limitations?: StringNullableListFilter<"Pathway">
    requirements?: StringNullableListFilter<"Pathway">
    restrictions?: StringNullableListFilter<"Pathway">
    duration?: JsonNullableFilter<"Pathway">
    processTime?: JsonNullableFilter<"Pathway">
    renewal?: JsonNullableFilter<"Pathway">
    cost?: JsonNullableFilter<"Pathway">
    createdby?: StringFilter<"Pathway"> | string
    documents?: PathwayDocumentsListRelationFilter
    categories?: PathwayCategoriesListRelationFilter
    pipelines?: PathwayPipelineListRelationFilter
    restrictedNationalities?: PathwayRestrictedNationalityListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    CMS_User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PathwayOrderByWithAggregationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    link?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyCode?: SortOrder
    notes?: SortOrder
    limitations?: SortOrder
    requirements?: SortOrder
    restrictions?: SortOrder
    duration?: SortOrderInput | SortOrder
    processTime?: SortOrderInput | SortOrder
    renewal?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdby?: SortOrder
    _count?: PathwayCountOrderByAggregateInput
    _avg?: PathwayAvgOrderByAggregateInput
    _max?: PathwayMaxOrderByAggregateInput
    _min?: PathwayMinOrderByAggregateInput
    _sum?: PathwaySumOrderByAggregateInput
  }

  export type PathwayScalarWhereWithAggregatesInput = {
    AND?: PathwayScalarWhereWithAggregatesInput | PathwayScalarWhereWithAggregatesInput[]
    OR?: PathwayScalarWhereWithAggregatesInput[]
    NOT?: PathwayScalarWhereWithAggregatesInput | PathwayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pathway"> | number
    countryCode?: StringWithAggregatesFilter<"Pathway"> | string
    name?: StringWithAggregatesFilter<"Pathway"> | string
    link?: StringWithAggregatesFilter<"Pathway"> | string
    description?: StringWithAggregatesFilter<"Pathway"> | string
    type?: EnumPathwayTypeWithAggregatesFilter<"Pathway"> | $Enums.PathwayType
    createdAt?: DateTimeWithAggregatesFilter<"Pathway"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pathway"> | Date | string
    currencyCode?: StringWithAggregatesFilter<"Pathway"> | string
    notes?: StringNullableListFilter<"Pathway">
    limitations?: StringNullableListFilter<"Pathway">
    requirements?: StringNullableListFilter<"Pathway">
    restrictions?: StringNullableListFilter<"Pathway">
    duration?: JsonNullableWithAggregatesFilter<"Pathway">
    processTime?: JsonNullableWithAggregatesFilter<"Pathway">
    renewal?: JsonNullableWithAggregatesFilter<"Pathway">
    cost?: JsonNullableWithAggregatesFilter<"Pathway">
    createdby?: StringWithAggregatesFilter<"Pathway"> | string
  }

  export type PathwayPipelineWhereInput = {
    AND?: PathwayPipelineWhereInput | PathwayPipelineWhereInput[]
    OR?: PathwayPipelineWhereInput[]
    NOT?: PathwayPipelineWhereInput | PathwayPipelineWhereInput[]
    id?: IntFilter<"PathwayPipeline"> | number
    pathwayId?: IntFilter<"PathwayPipeline"> | number
    pipeline?: EnumPathwayPipelinesFilter<"PathwayPipeline"> | $Enums.PathwayPipelines
    note?: StringNullableFilter<"PathwayPipeline"> | string | null
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }

  export type PathwayPipelineOrderByWithRelationInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    pipeline?: SortOrder
    note?: SortOrderInput | SortOrder
    pathway?: PathwayOrderByWithRelationInput
  }

  export type PathwayPipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PathwayPipelineWhereInput | PathwayPipelineWhereInput[]
    OR?: PathwayPipelineWhereInput[]
    NOT?: PathwayPipelineWhereInput | PathwayPipelineWhereInput[]
    pathwayId?: IntFilter<"PathwayPipeline"> | number
    pipeline?: EnumPathwayPipelinesFilter<"PathwayPipeline"> | $Enums.PathwayPipelines
    note?: StringNullableFilter<"PathwayPipeline"> | string | null
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }, "id">

  export type PathwayPipelineOrderByWithAggregationInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    pipeline?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: PathwayPipelineCountOrderByAggregateInput
    _avg?: PathwayPipelineAvgOrderByAggregateInput
    _max?: PathwayPipelineMaxOrderByAggregateInput
    _min?: PathwayPipelineMinOrderByAggregateInput
    _sum?: PathwayPipelineSumOrderByAggregateInput
  }

  export type PathwayPipelineScalarWhereWithAggregatesInput = {
    AND?: PathwayPipelineScalarWhereWithAggregatesInput | PathwayPipelineScalarWhereWithAggregatesInput[]
    OR?: PathwayPipelineScalarWhereWithAggregatesInput[]
    NOT?: PathwayPipelineScalarWhereWithAggregatesInput | PathwayPipelineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PathwayPipeline"> | number
    pathwayId?: IntWithAggregatesFilter<"PathwayPipeline"> | number
    pipeline?: EnumPathwayPipelinesWithAggregatesFilter<"PathwayPipeline"> | $Enums.PathwayPipelines
    note?: StringNullableWithAggregatesFilter<"PathwayPipeline"> | string | null
  }

  export type PathwayRestrictedNationalityWhereInput = {
    AND?: PathwayRestrictedNationalityWhereInput | PathwayRestrictedNationalityWhereInput[]
    OR?: PathwayRestrictedNationalityWhereInput[]
    NOT?: PathwayRestrictedNationalityWhereInput | PathwayRestrictedNationalityWhereInput[]
    pathwayId?: IntFilter<"PathwayRestrictedNationality"> | number
    countryCode?: StringFilter<"PathwayRestrictedNationality"> | string
    note?: StringNullableFilter<"PathwayRestrictedNationality"> | string | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }

  export type PathwayRestrictedNationalityOrderByWithRelationInput = {
    pathwayId?: SortOrder
    countryCode?: SortOrder
    note?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    pathway?: PathwayOrderByWithRelationInput
  }

  export type PathwayRestrictedNationalityWhereUniqueInput = Prisma.AtLeast<{
    pathwayId_countryCode?: PathwayRestrictedNationalityPathwayIdCountryCodeCompoundUniqueInput
    AND?: PathwayRestrictedNationalityWhereInput | PathwayRestrictedNationalityWhereInput[]
    OR?: PathwayRestrictedNationalityWhereInput[]
    NOT?: PathwayRestrictedNationalityWhereInput | PathwayRestrictedNationalityWhereInput[]
    pathwayId?: IntFilter<"PathwayRestrictedNationality"> | number
    countryCode?: StringFilter<"PathwayRestrictedNationality"> | string
    note?: StringNullableFilter<"PathwayRestrictedNationality"> | string | null
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }, "pathwayId_countryCode">

  export type PathwayRestrictedNationalityOrderByWithAggregationInput = {
    pathwayId?: SortOrder
    countryCode?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: PathwayRestrictedNationalityCountOrderByAggregateInput
    _avg?: PathwayRestrictedNationalityAvgOrderByAggregateInput
    _max?: PathwayRestrictedNationalityMaxOrderByAggregateInput
    _min?: PathwayRestrictedNationalityMinOrderByAggregateInput
    _sum?: PathwayRestrictedNationalitySumOrderByAggregateInput
  }

  export type PathwayRestrictedNationalityScalarWhereWithAggregatesInput = {
    AND?: PathwayRestrictedNationalityScalarWhereWithAggregatesInput | PathwayRestrictedNationalityScalarWhereWithAggregatesInput[]
    OR?: PathwayRestrictedNationalityScalarWhereWithAggregatesInput[]
    NOT?: PathwayRestrictedNationalityScalarWhereWithAggregatesInput | PathwayRestrictedNationalityScalarWhereWithAggregatesInput[]
    pathwayId?: IntWithAggregatesFilter<"PathwayRestrictedNationality"> | number
    countryCode?: StringWithAggregatesFilter<"PathwayRestrictedNationality"> | string
    note?: StringNullableWithAggregatesFilter<"PathwayRestrictedNationality"> | string | null
  }

  export type PathwayDocumentsWhereInput = {
    AND?: PathwayDocumentsWhereInput | PathwayDocumentsWhereInput[]
    OR?: PathwayDocumentsWhereInput[]
    NOT?: PathwayDocumentsWhereInput | PathwayDocumentsWhereInput[]
    id?: IntFilter<"PathwayDocuments"> | number
    pathwayId?: IntFilter<"PathwayDocuments"> | number
    documentId?: IntFilter<"PathwayDocuments"> | number
    description?: StringNullableFilter<"PathwayDocuments"> | string | null
    cost?: DecimalFilter<"PathwayDocuments"> | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFilter<"PathwayDocuments"> | boolean
    link?: StringNullableFilter<"PathwayDocuments"> | string | null
    title?: StringNullableFilter<"PathwayDocuments"> | string | null
    document?: XOR<DocumentsScalarRelationFilter, DocumentsWhereInput>
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }

  export type PathwayDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    description?: SortOrderInput | SortOrder
    cost?: SortOrder
    isRequired?: SortOrder
    link?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    document?: DocumentsOrderByWithRelationInput
    pathway?: PathwayOrderByWithRelationInput
  }

  export type PathwayDocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PathwayDocumentsWhereInput | PathwayDocumentsWhereInput[]
    OR?: PathwayDocumentsWhereInput[]
    NOT?: PathwayDocumentsWhereInput | PathwayDocumentsWhereInput[]
    pathwayId?: IntFilter<"PathwayDocuments"> | number
    documentId?: IntFilter<"PathwayDocuments"> | number
    description?: StringNullableFilter<"PathwayDocuments"> | string | null
    cost?: DecimalFilter<"PathwayDocuments"> | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFilter<"PathwayDocuments"> | boolean
    link?: StringNullableFilter<"PathwayDocuments"> | string | null
    title?: StringNullableFilter<"PathwayDocuments"> | string | null
    document?: XOR<DocumentsScalarRelationFilter, DocumentsWhereInput>
    pathway?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
  }, "id">

  export type PathwayDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    description?: SortOrderInput | SortOrder
    cost?: SortOrder
    isRequired?: SortOrder
    link?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    _count?: PathwayDocumentsCountOrderByAggregateInput
    _avg?: PathwayDocumentsAvgOrderByAggregateInput
    _max?: PathwayDocumentsMaxOrderByAggregateInput
    _min?: PathwayDocumentsMinOrderByAggregateInput
    _sum?: PathwayDocumentsSumOrderByAggregateInput
  }

  export type PathwayDocumentsScalarWhereWithAggregatesInput = {
    AND?: PathwayDocumentsScalarWhereWithAggregatesInput | PathwayDocumentsScalarWhereWithAggregatesInput[]
    OR?: PathwayDocumentsScalarWhereWithAggregatesInput[]
    NOT?: PathwayDocumentsScalarWhereWithAggregatesInput | PathwayDocumentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PathwayDocuments"> | number
    pathwayId?: IntWithAggregatesFilter<"PathwayDocuments"> | number
    documentId?: IntWithAggregatesFilter<"PathwayDocuments"> | number
    description?: StringNullableWithAggregatesFilter<"PathwayDocuments"> | string | null
    cost?: DecimalWithAggregatesFilter<"PathwayDocuments"> | Decimal | DecimalJsLike | number | string
    isRequired?: BoolWithAggregatesFilter<"PathwayDocuments"> | boolean
    link?: StringNullableWithAggregatesFilter<"PathwayDocuments"> | string | null
    title?: StringNullableWithAggregatesFilter<"PathwayDocuments"> | string | null
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    code?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    countryCurrencies?: CountryCurrencyListRelationFilter
    pathways?: PathwayListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    countryCurrencies?: CountryCurrencyOrderByRelationAggregateInput
    pathways?: PathwayOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    countryCurrencies?: CountryCurrencyListRelationFilter
    pathways?: PathwayListRelationFilter
  }, "code" | "code">

  export type CurrencyOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Currency"> | string
    name?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
  }

  export type DocumentsWhereInput = {
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    id?: IntFilter<"Documents"> | number
    name?: StringFilter<"Documents"> | string
    description?: StringNullableFilter<"Documents"> | string | null
    type?: EnumDocumentTypeNullableListFilter<"Documents">
    pathwayDocuments?: PathwayDocumentsListRelationFilter
  }

  export type DocumentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    pathwayDocuments?: PathwayDocumentsOrderByRelationAggregateInput
  }

  export type DocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentsWhereInput | DocumentsWhereInput[]
    OR?: DocumentsWhereInput[]
    NOT?: DocumentsWhereInput | DocumentsWhereInput[]
    name?: StringFilter<"Documents"> | string
    description?: StringNullableFilter<"Documents"> | string | null
    type?: EnumDocumentTypeNullableListFilter<"Documents">
    pathwayDocuments?: PathwayDocumentsListRelationFilter
  }, "id">

  export type DocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: DocumentsCountOrderByAggregateInput
    _avg?: DocumentsAvgOrderByAggregateInput
    _max?: DocumentsMaxOrderByAggregateInput
    _min?: DocumentsMinOrderByAggregateInput
    _sum?: DocumentsSumOrderByAggregateInput
  }

  export type DocumentsScalarWhereWithAggregatesInput = {
    AND?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    OR?: DocumentsScalarWhereWithAggregatesInput[]
    NOT?: DocumentsScalarWhereWithAggregatesInput | DocumentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Documents"> | number
    name?: StringWithAggregatesFilter<"Documents"> | string
    description?: StringNullableWithAggregatesFilter<"Documents"> | string | null
    type?: EnumDocumentTypeNullableListFilter<"Documents">
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    countryLanguages?: CountryLanguageListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    countryLanguages?: CountryLanguageOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    countryLanguages?: CountryLanguageListRelationFilter
  }, "code" | "code">

  export type LanguageOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: StringFilter<"Post"> | string
    contentHTML?: StringFilter<"Post"> | string
    contentText?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    slug?: StringFilter<"Post"> | string
    image?: BoolFilter<"Post"> | boolean
    metaDescription?: StringNullableFilter<"Post"> | string | null
    metaKeywords?: StringNullableListFilter<"Post">
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    contentDelta?: StringFilter<"Post"> | string
    imageExt?: StringNullableFilter<"Post"> | string | null
    imageKey?: StringNullableFilter<"Post"> | string | null
    postBlock?: PostBlockListRelationFilter
    tags?: PostTagListRelationFilter
    postVersionHistories?: PostVersionHistoryListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    contentHTML?: SortOrder
    contentText?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    image?: SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrder
    status?: SortOrder
    contentDelta?: SortOrder
    imageExt?: SortOrderInput | SortOrder
    imageKey?: SortOrderInput | SortOrder
    postBlock?: PostBlockOrderByRelationAggregateInput
    tags?: PostTagOrderByRelationAggregateInput
    postVersionHistories?: PostVersionHistoryOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: StringFilter<"Post"> | string
    contentHTML?: StringFilter<"Post"> | string
    contentText?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    image?: BoolFilter<"Post"> | boolean
    metaDescription?: StringNullableFilter<"Post"> | string | null
    metaKeywords?: StringNullableListFilter<"Post">
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    contentDelta?: StringFilter<"Post"> | string
    imageExt?: StringNullableFilter<"Post"> | string | null
    imageKey?: StringNullableFilter<"Post"> | string | null
    postBlock?: PostBlockListRelationFilter
    tags?: PostTagListRelationFilter
    postVersionHistories?: PostVersionHistoryListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    contentHTML?: SortOrder
    contentText?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    slug?: SortOrder
    image?: SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrder
    status?: SortOrder
    contentDelta?: SortOrder
    imageExt?: SortOrderInput | SortOrder
    imageKey?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    name?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    contentHTML?: StringWithAggregatesFilter<"Post"> | string
    contentText?: StringWithAggregatesFilter<"Post"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Post"> | string | null
    slug?: StringWithAggregatesFilter<"Post"> | string
    image?: BoolWithAggregatesFilter<"Post"> | boolean
    metaDescription?: StringNullableWithAggregatesFilter<"Post"> | string | null
    metaKeywords?: StringNullableListFilter<"Post">
    status?: EnumContentStatusWithAggregatesFilter<"Post"> | $Enums.ContentStatus
    contentDelta?: StringWithAggregatesFilter<"Post"> | string
    imageExt?: StringNullableWithAggregatesFilter<"Post"> | string | null
    imageKey?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: IntFilter<"PostTag"> | number
    tagId?: IntFilter<"PostTag"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PostTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    post?: PostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostTagPostIdTagIdCompoundUniqueInput
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: IntFilter<"PostTag"> | number
    tagId?: IntFilter<"PostTag"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _avg?: PostTagAvgOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
    _sum?: PostTagSumOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    postId?: IntWithAggregatesFilter<"PostTag"> | number
    tagId?: IntWithAggregatesFilter<"PostTag"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    parentId?: IntNullableFilter<"Tag"> | number | null
    color?: StringFilter<"Tag"> | string
    posts?: PostTagListRelationFilter
    childTag?: TagHierarchyListRelationFilter
    parentTag?: TagHierarchyListRelationFilter
    parent?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
    children?: TagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    color?: SortOrder
    posts?: PostTagOrderByRelationAggregateInput
    childTag?: TagHierarchyOrderByRelationAggregateInput
    parentTag?: TagHierarchyOrderByRelationAggregateInput
    parent?: TagOrderByWithRelationInput
    children?: TagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    parentId?: IntNullableFilter<"Tag"> | number | null
    color?: StringFilter<"Tag"> | string
    posts?: PostTagListRelationFilter
    childTag?: TagHierarchyListRelationFilter
    parentTag?: TagHierarchyListRelationFilter
    parent?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
    children?: TagListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    color?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    parentId?: IntNullableWithAggregatesFilter<"Tag"> | number | null
    color?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type TagHierarchyWhereInput = {
    AND?: TagHierarchyWhereInput | TagHierarchyWhereInput[]
    OR?: TagHierarchyWhereInput[]
    NOT?: TagHierarchyWhereInput | TagHierarchyWhereInput[]
    id?: IntFilter<"TagHierarchy"> | number
    parentId?: IntFilter<"TagHierarchy"> | number
    childId?: IntFilter<"TagHierarchy"> | number
    parent?: XOR<TagScalarRelationFilter, TagWhereInput>
    child?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TagHierarchyOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
    parent?: TagOrderByWithRelationInput
    child?: TagOrderByWithRelationInput
  }

  export type TagHierarchyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parentId_childId?: TagHierarchyParentIdChildIdCompoundUniqueInput
    AND?: TagHierarchyWhereInput | TagHierarchyWhereInput[]
    OR?: TagHierarchyWhereInput[]
    NOT?: TagHierarchyWhereInput | TagHierarchyWhereInput[]
    parentId?: IntFilter<"TagHierarchy"> | number
    childId?: IntFilter<"TagHierarchy"> | number
    parent?: XOR<TagScalarRelationFilter, TagWhereInput>
    child?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "parentId_childId">

  export type TagHierarchyOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
    _count?: TagHierarchyCountOrderByAggregateInput
    _avg?: TagHierarchyAvgOrderByAggregateInput
    _max?: TagHierarchyMaxOrderByAggregateInput
    _min?: TagHierarchyMinOrderByAggregateInput
    _sum?: TagHierarchySumOrderByAggregateInput
  }

  export type TagHierarchyScalarWhereWithAggregatesInput = {
    AND?: TagHierarchyScalarWhereWithAggregatesInput | TagHierarchyScalarWhereWithAggregatesInput[]
    OR?: TagHierarchyScalarWhereWithAggregatesInput[]
    NOT?: TagHierarchyScalarWhereWithAggregatesInput | TagHierarchyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TagHierarchy"> | number
    parentId?: IntWithAggregatesFilter<"TagHierarchy"> | number
    childId?: IntWithAggregatesFilter<"TagHierarchy"> | number
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    name?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    authorId?: StringFilter<"Resource"> | string
    content?: StringFilter<"Resource"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    name?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    authorId?: StringFilter<"Resource"> | string
    content?: StringFilter<"Resource"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    name?: StringWithAggregatesFilter<"Resource"> | string
    type?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    authorId?: StringWithAggregatesFilter<"Resource"> | string
    content?: StringWithAggregatesFilter<"Resource"> | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: IntFilter<"Block"> | number
    slug?: StringFilter<"Block"> | string
    name?: StringFilter<"Block"> | string
    component?: StringFilter<"Block"> | string
    type?: StringFilter<"Block"> | string
    blockField?: BlockFieldListRelationFilter
    postBlock?: PostBlockListRelationFilter
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    component?: SortOrder
    type?: SortOrder
    blockField?: BlockFieldOrderByRelationAggregateInput
    postBlock?: PostBlockOrderByRelationAggregateInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    name?: StringFilter<"Block"> | string
    component?: StringFilter<"Block"> | string
    type?: StringFilter<"Block"> | string
    blockField?: BlockFieldListRelationFilter
    postBlock?: PostBlockListRelationFilter
  }, "id" | "slug">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    component?: SortOrder
    type?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _avg?: BlockAvgOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
    _sum?: BlockSumOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Block"> | number
    slug?: StringWithAggregatesFilter<"Block"> | string
    name?: StringWithAggregatesFilter<"Block"> | string
    component?: StringWithAggregatesFilter<"Block"> | string
    type?: StringWithAggregatesFilter<"Block"> | string
  }

  export type BlockFieldWhereInput = {
    AND?: BlockFieldWhereInput | BlockFieldWhereInput[]
    OR?: BlockFieldWhereInput[]
    NOT?: BlockFieldWhereInput | BlockFieldWhereInput[]
    id?: IntFilter<"BlockField"> | number
    blockId?: IntFilter<"BlockField"> | number
    name?: StringFilter<"BlockField"> | string
    type?: StringFilter<"BlockField"> | string
    options?: StringNullableFilter<"BlockField"> | string | null
    slug?: StringFilter<"BlockField"> | string
    defaultValue?: StringNullableFilter<"BlockField"> | string | null
    block?: XOR<BlockScalarRelationFilter, BlockWhereInput>
  }

  export type BlockFieldOrderByWithRelationInput = {
    id?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    slug?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    block?: BlockOrderByWithRelationInput
  }

  export type BlockFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    blockId_name?: BlockFieldBlockIdNameCompoundUniqueInput
    AND?: BlockFieldWhereInput | BlockFieldWhereInput[]
    OR?: BlockFieldWhereInput[]
    NOT?: BlockFieldWhereInput | BlockFieldWhereInput[]
    blockId?: IntFilter<"BlockField"> | number
    name?: StringFilter<"BlockField"> | string
    type?: StringFilter<"BlockField"> | string
    options?: StringNullableFilter<"BlockField"> | string | null
    slug?: StringFilter<"BlockField"> | string
    defaultValue?: StringNullableFilter<"BlockField"> | string | null
    block?: XOR<BlockScalarRelationFilter, BlockWhereInput>
  }, "id" | "blockId_name">

  export type BlockFieldOrderByWithAggregationInput = {
    id?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    slug?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    _count?: BlockFieldCountOrderByAggregateInput
    _avg?: BlockFieldAvgOrderByAggregateInput
    _max?: BlockFieldMaxOrderByAggregateInput
    _min?: BlockFieldMinOrderByAggregateInput
    _sum?: BlockFieldSumOrderByAggregateInput
  }

  export type BlockFieldScalarWhereWithAggregatesInput = {
    AND?: BlockFieldScalarWhereWithAggregatesInput | BlockFieldScalarWhereWithAggregatesInput[]
    OR?: BlockFieldScalarWhereWithAggregatesInput[]
    NOT?: BlockFieldScalarWhereWithAggregatesInput | BlockFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlockField"> | number
    blockId?: IntWithAggregatesFilter<"BlockField"> | number
    name?: StringWithAggregatesFilter<"BlockField"> | string
    type?: StringWithAggregatesFilter<"BlockField"> | string
    options?: StringNullableWithAggregatesFilter<"BlockField"> | string | null
    slug?: StringWithAggregatesFilter<"BlockField"> | string
    defaultValue?: StringNullableWithAggregatesFilter<"BlockField"> | string | null
  }

  export type PostBlockWhereInput = {
    AND?: PostBlockWhereInput | PostBlockWhereInput[]
    OR?: PostBlockWhereInput[]
    NOT?: PostBlockWhereInput | PostBlockWhereInput[]
    id?: IntFilter<"PostBlock"> | number
    postId?: IntFilter<"PostBlock"> | number
    blockId?: IntFilter<"PostBlock"> | number
    type?: StringFilter<"PostBlock"> | string
    content?: StringFilter<"PostBlock"> | string
    position?: IntFilter<"PostBlock"> | number
    block?: XOR<BlockScalarRelationFilter, BlockWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type PostBlockOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    position?: SortOrder
    block?: BlockOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostBlockWhereInput | PostBlockWhereInput[]
    OR?: PostBlockWhereInput[]
    NOT?: PostBlockWhereInput | PostBlockWhereInput[]
    postId?: IntFilter<"PostBlock"> | number
    blockId?: IntFilter<"PostBlock"> | number
    type?: StringFilter<"PostBlock"> | string
    content?: StringFilter<"PostBlock"> | string
    position?: IntFilter<"PostBlock"> | number
    block?: XOR<BlockScalarRelationFilter, BlockWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type PostBlockOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    position?: SortOrder
    _count?: PostBlockCountOrderByAggregateInput
    _avg?: PostBlockAvgOrderByAggregateInput
    _max?: PostBlockMaxOrderByAggregateInput
    _min?: PostBlockMinOrderByAggregateInput
    _sum?: PostBlockSumOrderByAggregateInput
  }

  export type PostBlockScalarWhereWithAggregatesInput = {
    AND?: PostBlockScalarWhereWithAggregatesInput | PostBlockScalarWhereWithAggregatesInput[]
    OR?: PostBlockScalarWhereWithAggregatesInput[]
    NOT?: PostBlockScalarWhereWithAggregatesInput | PostBlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostBlock"> | number
    postId?: IntWithAggregatesFilter<"PostBlock"> | number
    blockId?: IntWithAggregatesFilter<"PostBlock"> | number
    type?: StringWithAggregatesFilter<"PostBlock"> | string
    content?: StringWithAggregatesFilter<"PostBlock"> | string
    position?: IntWithAggregatesFilter<"PostBlock"> | number
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    secret?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    discordHandle?: StringNullableFilter<"User"> | string | null
    key?: StringNullableFilter<"User"> | string | null
    created?: DateTimeFilter<"User"> | Date | string
    postVersionHistory?: PostVersionHistoryListRelationFilter
    posts?: PostListRelationFilter
    sessions?: SessionListRelationFilter
    roles?: UserRolesListRelationFilter
    socials?: UserSocialListRelationFilter
    Pathway?: PathwayListRelationFilter
    resources?: ResourceListRelationFilter
    contentResources?: ContentResourceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    secret?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    discordHandle?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    created?: SortOrder
    postVersionHistory?: PostVersionHistoryOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    roles?: UserRolesOrderByRelationAggregateInput
    socials?: UserSocialOrderByRelationAggregateInput
    Pathway?: PathwayOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
    contentResources?: ContentResourceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    secret?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    discordHandle?: StringNullableFilter<"User"> | string | null
    key?: StringNullableFilter<"User"> | string | null
    created?: DateTimeFilter<"User"> | Date | string
    postVersionHistory?: PostVersionHistoryListRelationFilter
    posts?: PostListRelationFilter
    sessions?: SessionListRelationFilter
    roles?: UserRolesListRelationFilter
    socials?: UserSocialListRelationFilter
    Pathway?: PathwayListRelationFilter
    resources?: ResourceListRelationFilter
    contentResources?: ContentResourceListRelationFilter
  }, "id" | "name">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    secret?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    discordHandle?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    created?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    secret?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    discordHandle?: StringNullableWithAggregatesFilter<"User"> | string | null
    key?: StringNullableWithAggregatesFilter<"User"> | string | null
    created?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserSocialWhereInput = {
    AND?: UserSocialWhereInput | UserSocialWhereInput[]
    OR?: UserSocialWhereInput[]
    NOT?: UserSocialWhereInput | UserSocialWhereInput[]
    userId?: StringFilter<"UserSocial"> | string
    handle?: StringFilter<"UserSocial"> | string
    socialCode?: StringFilter<"UserSocial"> | string
    social?: XOR<SocialScalarRelationFilter, SocialWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSocialOrderByWithRelationInput = {
    userId?: SortOrder
    handle?: SortOrder
    socialCode?: SortOrder
    social?: SocialOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSocialWhereUniqueInput = Prisma.AtLeast<{
    userId_socialCode?: UserSocialUserIdSocialCodeCompoundUniqueInput
    AND?: UserSocialWhereInput | UserSocialWhereInput[]
    OR?: UserSocialWhereInput[]
    NOT?: UserSocialWhereInput | UserSocialWhereInput[]
    userId?: StringFilter<"UserSocial"> | string
    handle?: StringFilter<"UserSocial"> | string
    socialCode?: StringFilter<"UserSocial"> | string
    social?: XOR<SocialScalarRelationFilter, SocialWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_socialCode">

  export type UserSocialOrderByWithAggregationInput = {
    userId?: SortOrder
    handle?: SortOrder
    socialCode?: SortOrder
    _count?: UserSocialCountOrderByAggregateInput
    _max?: UserSocialMaxOrderByAggregateInput
    _min?: UserSocialMinOrderByAggregateInput
  }

  export type UserSocialScalarWhereWithAggregatesInput = {
    AND?: UserSocialScalarWhereWithAggregatesInput | UserSocialScalarWhereWithAggregatesInput[]
    OR?: UserSocialScalarWhereWithAggregatesInput[]
    NOT?: UserSocialScalarWhereWithAggregatesInput | UserSocialScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSocial"> | string
    handle?: StringWithAggregatesFilter<"UserSocial"> | string
    socialCode?: StringWithAggregatesFilter<"UserSocial"> | string
  }

  export type UserRolesWhereInput = {
    AND?: UserRolesWhereInput | UserRolesWhereInput[]
    OR?: UserRolesWhereInput[]
    NOT?: UserRolesWhereInput | UserRolesWhereInput[]
    userId?: StringFilter<"UserRoles"> | string
    roleId?: IntFilter<"UserRoles"> | number
    role?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRolesOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    role?: RolesOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRolesWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRolesUserIdRoleIdCompoundUniqueInput
    AND?: UserRolesWhereInput | UserRolesWhereInput[]
    OR?: UserRolesWhereInput[]
    NOT?: UserRolesWhereInput | UserRolesWhereInput[]
    userId?: StringFilter<"UserRoles"> | string
    roleId?: IntFilter<"UserRoles"> | number
    role?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_roleId">

  export type UserRolesOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRolesCountOrderByAggregateInput
    _avg?: UserRolesAvgOrderByAggregateInput
    _max?: UserRolesMaxOrderByAggregateInput
    _min?: UserRolesMinOrderByAggregateInput
    _sum?: UserRolesSumOrderByAggregateInput
  }

  export type UserRolesScalarWhereWithAggregatesInput = {
    AND?: UserRolesScalarWhereWithAggregatesInput | UserRolesScalarWhereWithAggregatesInput[]
    OR?: UserRolesScalarWhereWithAggregatesInput[]
    NOT?: UserRolesScalarWhereWithAggregatesInput | UserRolesScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRoles"> | string
    roleId?: IntWithAggregatesFilter<"UserRoles"> | number
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    name?: StringFilter<"Roles"> | string
    UserRoles?: UserRolesListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    UserRoles?: UserRolesOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    UserRoles?: UserRolesListRelationFilter
  }, "id" | "name">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    name?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type SocialWhereInput = {
    AND?: SocialWhereInput | SocialWhereInput[]
    OR?: SocialWhereInput[]
    NOT?: SocialWhereInput | SocialWhereInput[]
    name?: StringFilter<"Social"> | string
    url?: StringFilter<"Social"> | string
    icon?: StringFilter<"Social"> | string
    codeName?: StringFilter<"Social"> | string
    profileLinkFormat?: StringFilter<"Social"> | string
    profileEntryFormat?: StringFilter<"Social"> | string
    darkModeColor?: StringFilter<"Social"> | string
    lightModeColor?: StringFilter<"Social"> | string
    users?: UserSocialListRelationFilter
  }

  export type SocialOrderByWithRelationInput = {
    name?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    codeName?: SortOrder
    profileLinkFormat?: SortOrder
    profileEntryFormat?: SortOrder
    darkModeColor?: SortOrder
    lightModeColor?: SortOrder
    users?: UserSocialOrderByRelationAggregateInput
  }

  export type SocialWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    codeName?: string
    AND?: SocialWhereInput | SocialWhereInput[]
    OR?: SocialWhereInput[]
    NOT?: SocialWhereInput | SocialWhereInput[]
    url?: StringFilter<"Social"> | string
    icon?: StringFilter<"Social"> | string
    profileLinkFormat?: StringFilter<"Social"> | string
    profileEntryFormat?: StringFilter<"Social"> | string
    darkModeColor?: StringFilter<"Social"> | string
    lightModeColor?: StringFilter<"Social"> | string
    users?: UserSocialListRelationFilter
  }, "codeName" | "name">

  export type SocialOrderByWithAggregationInput = {
    name?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    codeName?: SortOrder
    profileLinkFormat?: SortOrder
    profileEntryFormat?: SortOrder
    darkModeColor?: SortOrder
    lightModeColor?: SortOrder
    _count?: SocialCountOrderByAggregateInput
    _max?: SocialMaxOrderByAggregateInput
    _min?: SocialMinOrderByAggregateInput
  }

  export type SocialScalarWhereWithAggregatesInput = {
    AND?: SocialScalarWhereWithAggregatesInput | SocialScalarWhereWithAggregatesInput[]
    OR?: SocialScalarWhereWithAggregatesInput[]
    NOT?: SocialScalarWhereWithAggregatesInput | SocialScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Social"> | string
    url?: StringWithAggregatesFilter<"Social"> | string
    icon?: StringWithAggregatesFilter<"Social"> | string
    codeName?: StringWithAggregatesFilter<"Social"> | string
    profileLinkFormat?: StringWithAggregatesFilter<"Social"> | string
    profileEntryFormat?: StringWithAggregatesFilter<"Social"> | string
    darkModeColor?: StringWithAggregatesFilter<"Social"> | string
    lightModeColor?: StringWithAggregatesFilter<"Social"> | string
  }

  export type PostVersionHistoryWhereInput = {
    AND?: PostVersionHistoryWhereInput | PostVersionHistoryWhereInput[]
    OR?: PostVersionHistoryWhereInput[]
    NOT?: PostVersionHistoryWhereInput | PostVersionHistoryWhereInput[]
    id?: IntFilter<"PostVersionHistory"> | number
    postId?: IntFilter<"PostVersionHistory"> | number
    userId?: StringFilter<"PostVersionHistory"> | string
    action?: StringFilter<"PostVersionHistory"> | string
    instanceAt?: DateTimeFilter<"PostVersionHistory"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostVersionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    instanceAt?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostVersionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostVersionHistoryWhereInput | PostVersionHistoryWhereInput[]
    OR?: PostVersionHistoryWhereInput[]
    NOT?: PostVersionHistoryWhereInput | PostVersionHistoryWhereInput[]
    postId?: IntFilter<"PostVersionHistory"> | number
    userId?: StringFilter<"PostVersionHistory"> | string
    action?: StringFilter<"PostVersionHistory"> | string
    instanceAt?: DateTimeFilter<"PostVersionHistory"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostVersionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    instanceAt?: SortOrder
    _count?: PostVersionHistoryCountOrderByAggregateInput
    _avg?: PostVersionHistoryAvgOrderByAggregateInput
    _max?: PostVersionHistoryMaxOrderByAggregateInput
    _min?: PostVersionHistoryMinOrderByAggregateInput
    _sum?: PostVersionHistorySumOrderByAggregateInput
  }

  export type PostVersionHistoryScalarWhereWithAggregatesInput = {
    AND?: PostVersionHistoryScalarWhereWithAggregatesInput | PostVersionHistoryScalarWhereWithAggregatesInput[]
    OR?: PostVersionHistoryScalarWhereWithAggregatesInput[]
    NOT?: PostVersionHistoryScalarWhereWithAggregatesInput | PostVersionHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostVersionHistory"> | number
    postId?: IntWithAggregatesFilter<"PostVersionHistory"> | number
    userId?: StringWithAggregatesFilter<"PostVersionHistory"> | string
    action?: StringWithAggregatesFilter<"PostVersionHistory"> | string
    instanceAt?: DateTimeWithAggregatesFilter<"PostVersionHistory"> | Date | string
  }

  export type PathwayTypesWhereInput = {
    AND?: PathwayTypesWhereInput | PathwayTypesWhereInput[]
    OR?: PathwayTypesWhereInput[]
    NOT?: PathwayTypesWhereInput | PathwayTypesWhereInput[]
    id?: IntFilter<"PathwayTypes"> | number
    name?: StringFilter<"PathwayTypes"> | string
    parentId?: IntNullableFilter<"PathwayTypes"> | number | null
    description?: StringNullableFilter<"PathwayTypes"> | string | null
    pathwayCategories?: PathwayCategoriesListRelationFilter
    parent?: XOR<PathwayTypesNullableScalarRelationFilter, PathwayTypesWhereInput> | null
    children?: PathwayTypesListRelationFilter
  }

  export type PathwayTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    pathwayCategories?: PathwayCategoriesOrderByRelationAggregateInput
    parent?: PathwayTypesOrderByWithRelationInput
    children?: PathwayTypesOrderByRelationAggregateInput
  }

  export type PathwayTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PathwayTypesWhereInput | PathwayTypesWhereInput[]
    OR?: PathwayTypesWhereInput[]
    NOT?: PathwayTypesWhereInput | PathwayTypesWhereInput[]
    name?: StringFilter<"PathwayTypes"> | string
    parentId?: IntNullableFilter<"PathwayTypes"> | number | null
    description?: StringNullableFilter<"PathwayTypes"> | string | null
    pathwayCategories?: PathwayCategoriesListRelationFilter
    parent?: XOR<PathwayTypesNullableScalarRelationFilter, PathwayTypesWhereInput> | null
    children?: PathwayTypesListRelationFilter
  }, "id">

  export type PathwayTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PathwayTypesCountOrderByAggregateInput
    _avg?: PathwayTypesAvgOrderByAggregateInput
    _max?: PathwayTypesMaxOrderByAggregateInput
    _min?: PathwayTypesMinOrderByAggregateInput
    _sum?: PathwayTypesSumOrderByAggregateInput
  }

  export type PathwayTypesScalarWhereWithAggregatesInput = {
    AND?: PathwayTypesScalarWhereWithAggregatesInput | PathwayTypesScalarWhereWithAggregatesInput[]
    OR?: PathwayTypesScalarWhereWithAggregatesInput[]
    NOT?: PathwayTypesScalarWhereWithAggregatesInput | PathwayTypesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PathwayTypes"> | number
    name?: StringWithAggregatesFilter<"PathwayTypes"> | string
    parentId?: IntNullableWithAggregatesFilter<"PathwayTypes"> | number | null
    description?: StringNullableWithAggregatesFilter<"PathwayTypes"> | string | null
  }

  export type PathwayCategoriesWhereInput = {
    AND?: PathwayCategoriesWhereInput | PathwayCategoriesWhereInput[]
    OR?: PathwayCategoriesWhereInput[]
    NOT?: PathwayCategoriesWhereInput | PathwayCategoriesWhereInput[]
    pathwayId?: IntFilter<"PathwayCategories"> | number
    pathwayTypeId?: IntFilter<"PathwayCategories"> | number
    pathways?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
    pathway_categories?: XOR<PathwayTypesScalarRelationFilter, PathwayTypesWhereInput>
  }

  export type PathwayCategoriesOrderByWithRelationInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
    pathways?: PathwayOrderByWithRelationInput
    pathway_categories?: PathwayTypesOrderByWithRelationInput
  }

  export type PathwayCategoriesWhereUniqueInput = Prisma.AtLeast<{
    pathwayId_pathwayTypeId?: PathwayCategoriesPathwayIdPathwayTypeIdCompoundUniqueInput
    AND?: PathwayCategoriesWhereInput | PathwayCategoriesWhereInput[]
    OR?: PathwayCategoriesWhereInput[]
    NOT?: PathwayCategoriesWhereInput | PathwayCategoriesWhereInput[]
    pathwayId?: IntFilter<"PathwayCategories"> | number
    pathwayTypeId?: IntFilter<"PathwayCategories"> | number
    pathways?: XOR<PathwayScalarRelationFilter, PathwayWhereInput>
    pathway_categories?: XOR<PathwayTypesScalarRelationFilter, PathwayTypesWhereInput>
  }, "pathwayId_pathwayTypeId">

  export type PathwayCategoriesOrderByWithAggregationInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
    _count?: PathwayCategoriesCountOrderByAggregateInput
    _avg?: PathwayCategoriesAvgOrderByAggregateInput
    _max?: PathwayCategoriesMaxOrderByAggregateInput
    _min?: PathwayCategoriesMinOrderByAggregateInput
    _sum?: PathwayCategoriesSumOrderByAggregateInput
  }

  export type PathwayCategoriesScalarWhereWithAggregatesInput = {
    AND?: PathwayCategoriesScalarWhereWithAggregatesInput | PathwayCategoriesScalarWhereWithAggregatesInput[]
    OR?: PathwayCategoriesScalarWhereWithAggregatesInput[]
    NOT?: PathwayCategoriesScalarWhereWithAggregatesInput | PathwayCategoriesScalarWhereWithAggregatesInput[]
    pathwayId?: IntWithAggregatesFilter<"PathwayCategories"> | number
    pathwayTypeId?: IntWithAggregatesFilter<"PathwayCategories"> | number
  }

  export type ContentResourceTypeWhereInput = {
    AND?: ContentResourceTypeWhereInput | ContentResourceTypeWhereInput[]
    OR?: ContentResourceTypeWhereInput[]
    NOT?: ContentResourceTypeWhereInput | ContentResourceTypeWhereInput[]
    id?: IntFilter<"ContentResourceType"> | number
    type?: StringFilter<"ContentResourceType"> | string
    icon?: StringNullableFilter<"ContentResourceType"> | string | null
    color?: StringNullableFilter<"ContentResourceType"> | string | null
    contentResources?: ContentResourceListRelationFilter
  }

  export type ContentResourceTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    contentResources?: ContentResourceOrderByRelationAggregateInput
  }

  export type ContentResourceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentResourceTypeWhereInput | ContentResourceTypeWhereInput[]
    OR?: ContentResourceTypeWhereInput[]
    NOT?: ContentResourceTypeWhereInput | ContentResourceTypeWhereInput[]
    type?: StringFilter<"ContentResourceType"> | string
    icon?: StringNullableFilter<"ContentResourceType"> | string | null
    color?: StringNullableFilter<"ContentResourceType"> | string | null
    contentResources?: ContentResourceListRelationFilter
  }, "id">

  export type ContentResourceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    _count?: ContentResourceTypeCountOrderByAggregateInput
    _avg?: ContentResourceTypeAvgOrderByAggregateInput
    _max?: ContentResourceTypeMaxOrderByAggregateInput
    _min?: ContentResourceTypeMinOrderByAggregateInput
    _sum?: ContentResourceTypeSumOrderByAggregateInput
  }

  export type ContentResourceTypeScalarWhereWithAggregatesInput = {
    AND?: ContentResourceTypeScalarWhereWithAggregatesInput | ContentResourceTypeScalarWhereWithAggregatesInput[]
    OR?: ContentResourceTypeScalarWhereWithAggregatesInput[]
    NOT?: ContentResourceTypeScalarWhereWithAggregatesInput | ContentResourceTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentResourceType"> | number
    type?: StringWithAggregatesFilter<"ContentResourceType"> | string
    icon?: StringNullableWithAggregatesFilter<"ContentResourceType"> | string | null
    color?: StringNullableWithAggregatesFilter<"ContentResourceType"> | string | null
  }

  export type ContentResourceAreaWhereInput = {
    AND?: ContentResourceAreaWhereInput | ContentResourceAreaWhereInput[]
    OR?: ContentResourceAreaWhereInput[]
    NOT?: ContentResourceAreaWhereInput | ContentResourceAreaWhereInput[]
    id?: IntFilter<"ContentResourceArea"> | number
    area?: StringFilter<"ContentResourceArea"> | string
    tagline?: StringNullableFilter<"ContentResourceArea"> | string | null
    contentResources?: ContentResourceListRelationFilter
  }

  export type ContentResourceAreaOrderByWithRelationInput = {
    id?: SortOrder
    area?: SortOrder
    tagline?: SortOrderInput | SortOrder
    contentResources?: ContentResourceOrderByRelationAggregateInput
  }

  export type ContentResourceAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentResourceAreaWhereInput | ContentResourceAreaWhereInput[]
    OR?: ContentResourceAreaWhereInput[]
    NOT?: ContentResourceAreaWhereInput | ContentResourceAreaWhereInput[]
    area?: StringFilter<"ContentResourceArea"> | string
    tagline?: StringNullableFilter<"ContentResourceArea"> | string | null
    contentResources?: ContentResourceListRelationFilter
  }, "id">

  export type ContentResourceAreaOrderByWithAggregationInput = {
    id?: SortOrder
    area?: SortOrder
    tagline?: SortOrderInput | SortOrder
    _count?: ContentResourceAreaCountOrderByAggregateInput
    _avg?: ContentResourceAreaAvgOrderByAggregateInput
    _max?: ContentResourceAreaMaxOrderByAggregateInput
    _min?: ContentResourceAreaMinOrderByAggregateInput
    _sum?: ContentResourceAreaSumOrderByAggregateInput
  }

  export type ContentResourceAreaScalarWhereWithAggregatesInput = {
    AND?: ContentResourceAreaScalarWhereWithAggregatesInput | ContentResourceAreaScalarWhereWithAggregatesInput[]
    OR?: ContentResourceAreaScalarWhereWithAggregatesInput[]
    NOT?: ContentResourceAreaScalarWhereWithAggregatesInput | ContentResourceAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentResourceArea"> | number
    area?: StringWithAggregatesFilter<"ContentResourceArea"> | string
    tagline?: StringNullableWithAggregatesFilter<"ContentResourceArea"> | string | null
  }

  export type ContentResourceWhereInput = {
    AND?: ContentResourceWhereInput | ContentResourceWhereInput[]
    OR?: ContentResourceWhereInput[]
    NOT?: ContentResourceWhereInput | ContentResourceWhereInput[]
    id?: IntFilter<"ContentResource"> | number
    href?: JsonFilter<"ContentResource">
    title?: StringFilter<"ContentResource"> | string
    subtitle?: StringNullableFilter<"ContentResource"> | string | null
    typeId?: IntFilter<"ContentResource"> | number
    icon?: StringNullableFilter<"ContentResource"> | string | null
    authorId?: StringNullableFilter<"ContentResource"> | string | null
    date?: DateTimeFilter<"ContentResource"> | Date | string
    areaId?: IntFilter<"ContentResource"> | number
    authorString?: StringNullableFilter<"ContentResource"> | string | null
    area?: XOR<ContentResourceAreaScalarRelationFilter, ContentResourceAreaWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    type?: XOR<ContentResourceTypeScalarRelationFilter, ContentResourceTypeWhereInput>
  }

  export type ContentResourceOrderByWithRelationInput = {
    id?: SortOrder
    href?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    typeId?: SortOrder
    icon?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    date?: SortOrder
    areaId?: SortOrder
    authorString?: SortOrderInput | SortOrder
    area?: ContentResourceAreaOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    type?: ContentResourceTypeOrderByWithRelationInput
  }

  export type ContentResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentResourceWhereInput | ContentResourceWhereInput[]
    OR?: ContentResourceWhereInput[]
    NOT?: ContentResourceWhereInput | ContentResourceWhereInput[]
    href?: JsonFilter<"ContentResource">
    title?: StringFilter<"ContentResource"> | string
    subtitle?: StringNullableFilter<"ContentResource"> | string | null
    typeId?: IntFilter<"ContentResource"> | number
    icon?: StringNullableFilter<"ContentResource"> | string | null
    authorId?: StringNullableFilter<"ContentResource"> | string | null
    date?: DateTimeFilter<"ContentResource"> | Date | string
    areaId?: IntFilter<"ContentResource"> | number
    authorString?: StringNullableFilter<"ContentResource"> | string | null
    area?: XOR<ContentResourceAreaScalarRelationFilter, ContentResourceAreaWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    type?: XOR<ContentResourceTypeScalarRelationFilter, ContentResourceTypeWhereInput>
  }, "id">

  export type ContentResourceOrderByWithAggregationInput = {
    id?: SortOrder
    href?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    typeId?: SortOrder
    icon?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    date?: SortOrder
    areaId?: SortOrder
    authorString?: SortOrderInput | SortOrder
    _count?: ContentResourceCountOrderByAggregateInput
    _avg?: ContentResourceAvgOrderByAggregateInput
    _max?: ContentResourceMaxOrderByAggregateInput
    _min?: ContentResourceMinOrderByAggregateInput
    _sum?: ContentResourceSumOrderByAggregateInput
  }

  export type ContentResourceScalarWhereWithAggregatesInput = {
    AND?: ContentResourceScalarWhereWithAggregatesInput | ContentResourceScalarWhereWithAggregatesInput[]
    OR?: ContentResourceScalarWhereWithAggregatesInput[]
    NOT?: ContentResourceScalarWhereWithAggregatesInput | ContentResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentResource"> | number
    href?: JsonWithAggregatesFilter<"ContentResource">
    title?: StringWithAggregatesFilter<"ContentResource"> | string
    subtitle?: StringNullableWithAggregatesFilter<"ContentResource"> | string | null
    typeId?: IntWithAggregatesFilter<"ContentResource"> | number
    icon?: StringNullableWithAggregatesFilter<"ContentResource"> | string | null
    authorId?: StringNullableWithAggregatesFilter<"ContentResource"> | string | null
    date?: DateTimeWithAggregatesFilter<"ContentResource"> | Date | string
    areaId?: IntWithAggregatesFilter<"ContentResource"> | number
    authorString?: StringNullableWithAggregatesFilter<"ContentResource"> | string | null
  }

  export type SettingsCreateInput = {
    key: string
    value: string
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    key: string
    value: string
  }

  export type SettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type SettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityCreateNestedManyWithoutCountryInput
    pathways?: PathwayCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageUncheckedCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutCountryInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUncheckedUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    code: string
    name: string
  }

  export type CountryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryLanguageCreateInput = {
    country: CountryCreateNestedOneWithoutCountryLanguagesInput
    language: LanguageCreateNestedOneWithoutCountryLanguagesInput
  }

  export type CountryLanguageUncheckedCreateInput = {
    countryCode: string
    languageCode: string
  }

  export type CountryLanguageUpdateInput = {
    country?: CountryUpdateOneRequiredWithoutCountryLanguagesNestedInput
    language?: LanguageUpdateOneRequiredWithoutCountryLanguagesNestedInput
  }

  export type CountryLanguageUncheckedUpdateInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryLanguageCreateManyInput = {
    countryCode: string
    languageCode: string
  }

  export type CountryLanguageUpdateManyMutationInput = {

  }

  export type CountryLanguageUncheckedUpdateManyInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCurrencyCreateInput = {
    country: CountryCreateNestedOneWithoutCountryCurrenciesInput
    currency: CurrencyCreateNestedOneWithoutCountryCurrenciesInput
  }

  export type CountryCurrencyUncheckedCreateInput = {
    countryCode: string
    currencyCode: string
  }

  export type CountryCurrencyUpdateInput = {
    country?: CountryUpdateOneRequiredWithoutCountryCurrenciesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutCountryCurrenciesNestedInput
  }

  export type CountryCurrencyUncheckedUpdateInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    currencyCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCurrencyCreateManyInput = {
    countryCode: string
    currencyCode: string
  }

  export type CountryCurrencyUpdateManyMutationInput = {

  }

  export type CountryCurrencyUncheckedUpdateManyInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    currencyCode?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayCreateInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type PathwayCreateManyInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
  }

  export type PathwayUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PathwayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayPipelineCreateInput = {
    pipeline: $Enums.PathwayPipelines
    note?: string | null
    pathway: PathwayCreateNestedOneWithoutPipelinesInput
  }

  export type PathwayPipelineUncheckedCreateInput = {
    id?: number
    pathwayId: number
    pipeline: $Enums.PathwayPipelines
    note?: string | null
  }

  export type PathwayPipelineUpdateInput = {
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: PathwayUpdateOneRequiredWithoutPipelinesNestedInput
  }

  export type PathwayPipelineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayPipelineCreateManyInput = {
    id?: number
    pathwayId: number
    pipeline: $Enums.PathwayPipelines
    note?: string | null
  }

  export type PathwayPipelineUpdateManyMutationInput = {
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayPipelineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityCreateInput = {
    note?: string | null
    country: CountryCreateNestedOneWithoutRestrictedPathwaysInput
    pathway: PathwayCreateNestedOneWithoutRestrictedNationalitiesInput
  }

  export type PathwayRestrictedNationalityUncheckedCreateInput = {
    pathwayId: number
    countryCode: string
    note?: string | null
  }

  export type PathwayRestrictedNationalityUpdateInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutRestrictedPathwaysNestedInput
    pathway?: PathwayUpdateOneRequiredWithoutRestrictedNationalitiesNestedInput
  }

  export type PathwayRestrictedNationalityUncheckedUpdateInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityCreateManyInput = {
    pathwayId: number
    countryCode: string
    note?: string | null
  }

  export type PathwayRestrictedNationalityUpdateManyMutationInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityUncheckedUpdateManyInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayDocumentsCreateInput = {
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
    document?: DocumentsCreateNestedOneWithoutPathwayDocumentsInput
    pathway: PathwayCreateNestedOneWithoutDocumentsInput
  }

  export type PathwayDocumentsUncheckedCreateInput = {
    id?: number
    pathwayId: number
    documentId?: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayDocumentsUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneRequiredWithoutPathwayDocumentsNestedInput
    pathway?: PathwayUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PathwayDocumentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayDocumentsCreateManyInput = {
    id?: number
    pathwayId: number
    documentId?: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayDocumentsUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayDocumentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CurrencyCreateInput = {
    code: string
    name: string
    symbol: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCurrencyInput
    pathways?: PathwayCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    code: string
    name: string
    symbol: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCurrencyNestedInput
    pathways?: PathwayUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    code: string
    name: string
    symbol: string
  }

  export type CurrencyUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentsCreateInput = {
    name: string
    description?: string | null
    type?: DocumentsCreatetypeInput | $Enums.DocumentType[]
    pathwayDocuments?: PathwayDocumentsCreateNestedManyWithoutDocumentInput
  }

  export type DocumentsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    type?: DocumentsCreatetypeInput | $Enums.DocumentType[]
    pathwayDocuments?: PathwayDocumentsUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
    pathwayDocuments?: PathwayDocumentsUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
    pathwayDocuments?: PathwayDocumentsUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    type?: DocumentsCreatetypeInput | $Enums.DocumentType[]
  }

  export type DocumentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
  }

  export type DocumentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
  }

  export type LanguageCreateInput = {
    code: string
    name: string
    countryLanguages?: CountryLanguageCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    code: string
    name: string
    countryLanguages?: CountryLanguageUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryLanguages?: CountryLanguageUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryLanguages?: CountryLanguageUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    code: string
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryCreateNestedManyWithoutPostInput
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
  }

  export type PostUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostTagCreateInput = {
    post: PostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateInput = {
    postId: number
    tagId: number
  }

  export type PostTagUpdateInput = {
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    postId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PostTagCreateManyInput = {
    postId: number
    tagId: number
  }

  export type PostTagUpdateManyMutationInput = {

  }

  export type PostTagUncheckedUpdateManyInput = {
    postId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    name: string
    color?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyCreateNestedManyWithoutChildInput
    parent?: TagCreateNestedOneWithoutChildrenInput
    children?: TagCreateNestedManyWithoutParentInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyUncheckedCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyUncheckedCreateNestedManyWithoutChildInput
    children?: TagUncheckedCreateNestedManyWithoutParentInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUpdateManyWithoutChildNestedInput
    parent?: TagUpdateOneWithoutChildrenNestedInput
    children?: TagUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUncheckedUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUncheckedUpdateManyWithoutChildNestedInput
    children?: TagUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagHierarchyCreateInput = {
    parent: TagCreateNestedOneWithoutChildTagInput
    child: TagCreateNestedOneWithoutParentTagInput
  }

  export type TagHierarchyUncheckedCreateInput = {
    id?: number
    parentId: number
    childId: number
  }

  export type TagHierarchyUpdateInput = {
    parent?: TagUpdateOneRequiredWithoutChildTagNestedInput
    child?: TagUpdateOneRequiredWithoutParentTagNestedInput
  }

  export type TagHierarchyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    childId?: IntFieldUpdateOperationsInput | number
  }

  export type TagHierarchyCreateManyInput = {
    id?: number
    parentId: number
    childId: number
  }

  export type TagHierarchyUpdateManyMutationInput = {

  }

  export type TagHierarchyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    childId?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceCreateInput = {
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
    author: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    content: string
  }

  export type ResourceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceCreateManyInput = {
    id?: number
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    content: string
  }

  export type ResourceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type BlockCreateInput = {
    slug: string
    name: string
    component: string
    type?: string
    blockField?: BlockFieldCreateNestedManyWithoutBlockInput
    postBlock?: PostBlockCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    component: string
    type?: string
    blockField?: BlockFieldUncheckedCreateNestedManyWithoutBlockInput
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    blockField?: BlockFieldUpdateManyWithoutBlockNestedInput
    postBlock?: PostBlockUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    blockField?: BlockFieldUncheckedUpdateManyWithoutBlockNestedInput
    postBlock?: PostBlockUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockCreateManyInput = {
    id?: number
    slug: string
    name: string
    component: string
    type?: string
  }

  export type BlockUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type BlockFieldCreateInput = {
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
    block: BlockCreateNestedOneWithoutBlockFieldInput
  }

  export type BlockFieldUncheckedCreateInput = {
    id?: number
    blockId: number
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
  }

  export type BlockFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    block?: BlockUpdateOneRequiredWithoutBlockFieldNestedInput
  }

  export type BlockFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockFieldCreateManyInput = {
    id?: number
    blockId: number
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
  }

  export type BlockFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostBlockCreateInput = {
    type: string
    content: string
    position: number
    block: BlockCreateNestedOneWithoutPostBlockInput
    post: PostCreateNestedOneWithoutPostBlockInput
  }

  export type PostBlockUncheckedCreateInput = {
    id?: number
    postId: number
    blockId: number
    type: string
    content: string
    position: number
  }

  export type PostBlockUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    block?: BlockUpdateOneRequiredWithoutPostBlockNestedInput
    post?: PostUpdateOneRequiredWithoutPostBlockNestedInput
  }

  export type PostBlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostBlockCreateManyInput = {
    id?: number
    postId: number
    blockId: number
    type: string
    content: string
    position: number
  }

  export type PostBlockUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostBlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSocialCreateInput = {
    handle: string
    social: SocialCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutSocialsInput
  }

  export type UserSocialUncheckedCreateInput = {
    userId: string
    handle: string
    socialCode: string
  }

  export type UserSocialUpdateInput = {
    handle?: StringFieldUpdateOperationsInput | string
    social?: SocialUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutSocialsNestedInput
  }

  export type UserSocialUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    socialCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialCreateManyInput = {
    userId: string
    handle: string
    socialCode: string
  }

  export type UserSocialUpdateManyMutationInput = {
    handle?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    socialCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserRolesCreateInput = {
    role: RolesCreateNestedOneWithoutUserRolesInput
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRolesUncheckedCreateInput = {
    userId: string
    roleId: number
  }

  export type UserRolesUpdateInput = {
    role?: RolesUpdateOneRequiredWithoutUserRolesNestedInput
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRolesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRolesCreateManyInput = {
    userId: string
    roleId: number
  }

  export type UserRolesUpdateManyMutationInput = {

  }

  export type UserRolesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type RolesCreateInput = {
    name: string
    UserRoles?: UserRolesCreateNestedManyWithoutRoleInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    name: string
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    UserRoles?: UserRolesUpdateManyWithoutRoleNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    UserRoles?: UserRolesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    name: string
  }

  export type RolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SocialCreateInput = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
    users?: UserSocialCreateNestedManyWithoutSocialInput
  }

  export type SocialUncheckedCreateInput = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
    users?: UserSocialUncheckedCreateNestedManyWithoutSocialInput
  }

  export type SocialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
    users?: UserSocialUpdateManyWithoutSocialNestedInput
  }

  export type SocialUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
    users?: UserSocialUncheckedUpdateManyWithoutSocialNestedInput
  }

  export type SocialCreateManyInput = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
  }

  export type SocialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
  }

  export type SocialUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
  }

  export type PostVersionHistoryCreateInput = {
    action: string
    instanceAt?: Date | string
    post: PostCreateNestedOneWithoutPostVersionHistoriesInput
    user: UserCreateNestedOneWithoutPostVersionHistoryInput
  }

  export type PostVersionHistoryUncheckedCreateInput = {
    id?: number
    postId: number
    userId: string
    action: string
    instanceAt?: Date | string
  }

  export type PostVersionHistoryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutPostVersionHistoriesNestedInput
    user?: UserUpdateOneRequiredWithoutPostVersionHistoryNestedInput
  }

  export type PostVersionHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionHistoryCreateManyInput = {
    id?: number
    postId: number
    userId: string
    action: string
    instanceAt?: Date | string
  }

  export type PostVersionHistoryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayTypesCreateInput = {
    name: string
    description?: string | null
    pathwayCategories?: PathwayCategoriesCreateNestedManyWithoutPathway_categoriesInput
    parent?: PathwayTypesCreateNestedOneWithoutChildrenInput
    children?: PathwayTypesCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    description?: string | null
    pathwayCategories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathway_categoriesInput
    children?: PathwayTypesUncheckedCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUpdateManyWithoutPathway_categoriesNestedInput
    parent?: PathwayTypesUpdateOneWithoutChildrenNestedInput
    children?: PathwayTypesUpdateManyWithoutParentNestedInput
  }

  export type PathwayTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesNestedInput
    children?: PathwayTypesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PathwayTypesCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    description?: string | null
  }

  export type PathwayTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayCategoriesCreateInput = {
    pathways: PathwayCreateNestedOneWithoutCategoriesInput
    pathway_categories: PathwayTypesCreateNestedOneWithoutPathwayCategoriesInput
  }

  export type PathwayCategoriesUncheckedCreateInput = {
    pathwayId: number
    pathwayTypeId: number
  }

  export type PathwayCategoriesUpdateInput = {
    pathways?: PathwayUpdateOneRequiredWithoutCategoriesNestedInput
    pathway_categories?: PathwayTypesUpdateOneRequiredWithoutPathwayCategoriesNestedInput
  }

  export type PathwayCategoriesUncheckedUpdateInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    pathwayTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PathwayCategoriesCreateManyInput = {
    pathwayId: number
    pathwayTypeId: number
  }

  export type PathwayCategoriesUpdateManyMutationInput = {

  }

  export type PathwayCategoriesUncheckedUpdateManyInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    pathwayTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentResourceTypeCreateInput = {
    type: string
    icon?: string | null
    color?: string | null
    contentResources?: ContentResourceCreateNestedManyWithoutTypeInput
  }

  export type ContentResourceTypeUncheckedCreateInput = {
    id?: number
    type: string
    icon?: string | null
    color?: string | null
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutTypeInput
  }

  export type ContentResourceTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    contentResources?: ContentResourceUpdateManyWithoutTypeNestedInput
  }

  export type ContentResourceTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    contentResources?: ContentResourceUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type ContentResourceTypeCreateManyInput = {
    id?: number
    type: string
    icon?: string | null
    color?: string | null
  }

  export type ContentResourceTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceAreaCreateInput = {
    area: string
    tagline?: string | null
    contentResources?: ContentResourceCreateNestedManyWithoutAreaInput
  }

  export type ContentResourceAreaUncheckedCreateInput = {
    id?: number
    area: string
    tagline?: string | null
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAreaInput
  }

  export type ContentResourceAreaUpdateInput = {
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    contentResources?: ContentResourceUpdateManyWithoutAreaNestedInput
  }

  export type ContentResourceAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type ContentResourceAreaCreateManyInput = {
    id?: number
    area: string
    tagline?: string | null
  }

  export type ContentResourceAreaUpdateManyMutationInput = {
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceCreateInput = {
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    date?: Date | string
    authorString?: string | null
    area: ContentResourceAreaCreateNestedOneWithoutContentResourcesInput
    author?: UserCreateNestedOneWithoutContentResourcesInput
    type: ContentResourceTypeCreateNestedOneWithoutContentResourcesInput
  }

  export type ContentResourceUncheckedCreateInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type ContentResourceUpdateInput = {
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
    area?: ContentResourceAreaUpdateOneRequiredWithoutContentResourcesNestedInput
    author?: UserUpdateOneWithoutContentResourcesNestedInput
    type?: ContentResourceTypeUpdateOneRequiredWithoutContentResourcesNestedInput
  }

  export type ContentResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceCreateManyInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type ContentResourceUpdateManyMutationInput = {
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type CountryCurrencyListRelationFilter = {
    every?: CountryCurrencyWhereInput
    some?: CountryCurrencyWhereInput
    none?: CountryCurrencyWhereInput
  }

  export type CountryLanguageListRelationFilter = {
    every?: CountryLanguageWhereInput
    some?: CountryLanguageWhereInput
    none?: CountryLanguageWhereInput
  }

  export type PathwayRestrictedNationalityListRelationFilter = {
    every?: PathwayRestrictedNationalityWhereInput
    some?: PathwayRestrictedNationalityWhereInput
    none?: PathwayRestrictedNationalityWhereInput
  }

  export type PathwayListRelationFilter = {
    every?: PathwayWhereInput
    some?: PathwayWhereInput
    none?: PathwayWhereInput
  }

  export type CountryCurrencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayRestrictedNationalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type CountryLanguageCountryCodeLanguageCodeCompoundUniqueInput = {
    countryCode: string
    languageCode: string
  }

  export type CountryLanguageCountOrderByAggregateInput = {
    countryCode?: SortOrder
    languageCode?: SortOrder
  }

  export type CountryLanguageMaxOrderByAggregateInput = {
    countryCode?: SortOrder
    languageCode?: SortOrder
  }

  export type CountryLanguageMinOrderByAggregateInput = {
    countryCode?: SortOrder
    languageCode?: SortOrder
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type CountryCurrencyCountryCodeCurrencyCodeCompoundUniqueInput = {
    countryCode: string
    currencyCode: string
  }

  export type CountryCurrencyCountOrderByAggregateInput = {
    countryCode?: SortOrder
    currencyCode?: SortOrder
  }

  export type CountryCurrencyMaxOrderByAggregateInput = {
    countryCode?: SortOrder
    currencyCode?: SortOrder
  }

  export type CountryCurrencyMinOrderByAggregateInput = {
    countryCode?: SortOrder
    currencyCode?: SortOrder
  }

  export type EnumPathwayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayType | EnumPathwayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayTypeFilter<$PrismaModel> | $Enums.PathwayType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PathwayDocumentsListRelationFilter = {
    every?: PathwayDocumentsWhereInput
    some?: PathwayDocumentsWhereInput
    none?: PathwayDocumentsWhereInput
  }

  export type PathwayCategoriesListRelationFilter = {
    every?: PathwayCategoriesWhereInput
    some?: PathwayCategoriesWhereInput
    none?: PathwayCategoriesWhereInput
  }

  export type PathwayPipelineListRelationFilter = {
    every?: PathwayPipelineWhereInput
    some?: PathwayPipelineWhereInput
    none?: PathwayPipelineWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PathwayDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayCategoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayPipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayCountOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    link?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyCode?: SortOrder
    notes?: SortOrder
    limitations?: SortOrder
    requirements?: SortOrder
    restrictions?: SortOrder
    duration?: SortOrder
    processTime?: SortOrder
    renewal?: SortOrder
    cost?: SortOrder
    createdby?: SortOrder
  }

  export type PathwayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PathwayMaxOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    link?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyCode?: SortOrder
    createdby?: SortOrder
  }

  export type PathwayMinOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    link?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currencyCode?: SortOrder
    createdby?: SortOrder
  }

  export type PathwaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPathwayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayType | EnumPathwayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayTypeWithAggregatesFilter<$PrismaModel> | $Enums.PathwayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPathwayTypeFilter<$PrismaModel>
    _max?: NestedEnumPathwayTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPathwayPipelinesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayPipelines | EnumPathwayPipelinesFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayPipelinesFilter<$PrismaModel> | $Enums.PathwayPipelines
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PathwayScalarRelationFilter = {
    is?: PathwayWhereInput
    isNot?: PathwayWhereInput
  }

  export type PathwayPipelineCountOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    pipeline?: SortOrder
    note?: SortOrder
  }

  export type PathwayPipelineAvgOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
  }

  export type PathwayPipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    pipeline?: SortOrder
    note?: SortOrder
  }

  export type PathwayPipelineMinOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    pipeline?: SortOrder
    note?: SortOrder
  }

  export type PathwayPipelineSumOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
  }

  export type EnumPathwayPipelinesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayPipelines | EnumPathwayPipelinesFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayPipelinesWithAggregatesFilter<$PrismaModel> | $Enums.PathwayPipelines
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPathwayPipelinesFilter<$PrismaModel>
    _max?: NestedEnumPathwayPipelinesFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PathwayRestrictedNationalityPathwayIdCountryCodeCompoundUniqueInput = {
    pathwayId: number
    countryCode: string
  }

  export type PathwayRestrictedNationalityCountOrderByAggregateInput = {
    pathwayId?: SortOrder
    countryCode?: SortOrder
    note?: SortOrder
  }

  export type PathwayRestrictedNationalityAvgOrderByAggregateInput = {
    pathwayId?: SortOrder
  }

  export type PathwayRestrictedNationalityMaxOrderByAggregateInput = {
    pathwayId?: SortOrder
    countryCode?: SortOrder
    note?: SortOrder
  }

  export type PathwayRestrictedNationalityMinOrderByAggregateInput = {
    pathwayId?: SortOrder
    countryCode?: SortOrder
    note?: SortOrder
  }

  export type PathwayRestrictedNationalitySumOrderByAggregateInput = {
    pathwayId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DocumentsScalarRelationFilter = {
    is?: DocumentsWhereInput
    isNot?: DocumentsWhereInput
  }

  export type PathwayDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    isRequired?: SortOrder
    link?: SortOrder
    title?: SortOrder
  }

  export type PathwayDocumentsAvgOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    cost?: SortOrder
  }

  export type PathwayDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    isRequired?: SortOrder
    link?: SortOrder
    title?: SortOrder
  }

  export type PathwayDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    cost?: SortOrder
    isRequired?: SortOrder
    link?: SortOrder
    title?: SortOrder
  }

  export type PathwayDocumentsSumOrderByAggregateInput = {
    id?: SortOrder
    pathwayId?: SortOrder
    documentId?: SortOrder
    cost?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CurrencyCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
  }

  export type EnumDocumentTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
  }

  export type DocumentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DocumentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type PostBlockListRelationFilter = {
    every?: PostBlockWhereInput
    some?: PostBlockWhereInput
    none?: PostBlockWhereInput
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type PostVersionHistoryListRelationFilter = {
    every?: PostVersionHistoryWhereInput
    some?: PostVersionHistoryWhereInput
    none?: PostVersionHistoryWhereInput
  }

  export type PostBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostVersionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    contentHTML?: SortOrder
    contentText?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    image?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    status?: SortOrder
    contentDelta?: SortOrder
    imageExt?: SortOrder
    imageKey?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    contentHTML?: SortOrder
    contentText?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    image?: SortOrder
    metaDescription?: SortOrder
    status?: SortOrder
    contentDelta?: SortOrder
    imageExt?: SortOrder
    imageKey?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    contentHTML?: SortOrder
    contentText?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    image?: SortOrder
    metaDescription?: SortOrder
    status?: SortOrder
    contentDelta?: SortOrder
    imageExt?: SortOrder
    imageKey?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostTagPostIdTagIdCompoundUniqueInput = {
    postId: number
    tagId: number
  }

  export type PostTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagAvgOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagSumOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TagHierarchyListRelationFilter = {
    every?: TagHierarchyWhereInput
    some?: TagHierarchyWhereInput
    none?: TagHierarchyWhereInput
  }

  export type TagNullableScalarRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagHierarchyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TagHierarchyParentIdChildIdCompoundUniqueInput = {
    parentId: number
    childId: number
  }

  export type TagHierarchyCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
  }

  export type TagHierarchyAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
  }

  export type TagHierarchyMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
  }

  export type TagHierarchyMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
  }

  export type TagHierarchySumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    childId?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlockFieldListRelationFilter = {
    every?: BlockFieldWhereInput
    some?: BlockFieldWhereInput
    none?: BlockFieldWhereInput
  }

  export type BlockFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    component?: SortOrder
    type?: SortOrder
  }

  export type BlockAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    component?: SortOrder
    type?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    component?: SortOrder
    type?: SortOrder
  }

  export type BlockSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlockScalarRelationFilter = {
    is?: BlockWhereInput
    isNot?: BlockWhereInput
  }

  export type BlockFieldBlockIdNameCompoundUniqueInput = {
    blockId: number
    name: string
  }

  export type BlockFieldCountOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    slug?: SortOrder
    defaultValue?: SortOrder
  }

  export type BlockFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
  }

  export type BlockFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    slug?: SortOrder
    defaultValue?: SortOrder
  }

  export type BlockFieldMinOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    slug?: SortOrder
    defaultValue?: SortOrder
  }

  export type BlockFieldSumOrderByAggregateInput = {
    id?: SortOrder
    blockId?: SortOrder
  }

  export type PostBlockCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    position?: SortOrder
  }

  export type PostBlockAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    position?: SortOrder
  }

  export type PostBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    position?: SortOrder
  }

  export type PostBlockMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    position?: SortOrder
  }

  export type PostBlockSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    blockId?: SortOrder
    position?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserRolesListRelationFilter = {
    every?: UserRolesWhereInput
    some?: UserRolesWhereInput
    none?: UserRolesWhereInput
  }

  export type UserSocialListRelationFilter = {
    every?: UserSocialWhereInput
    some?: UserSocialWhereInput
    none?: UserSocialWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type ContentResourceListRelationFilter = {
    every?: ContentResourceWhereInput
    some?: ContentResourceWhereInput
    none?: ContentResourceWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSocialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    secret?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    discordHandle?: SortOrder
    key?: SortOrder
    created?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    secret?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    discordHandle?: SortOrder
    key?: SortOrder
    created?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    secret?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    discordHandle?: SortOrder
    key?: SortOrder
    created?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type SocialScalarRelationFilter = {
    is?: SocialWhereInput
    isNot?: SocialWhereInput
  }

  export type UserSocialUserIdSocialCodeCompoundUniqueInput = {
    userId: string
    socialCode: string
  }

  export type UserSocialCountOrderByAggregateInput = {
    userId?: SortOrder
    handle?: SortOrder
    socialCode?: SortOrder
  }

  export type UserSocialMaxOrderByAggregateInput = {
    userId?: SortOrder
    handle?: SortOrder
    socialCode?: SortOrder
  }

  export type UserSocialMinOrderByAggregateInput = {
    userId?: SortOrder
    handle?: SortOrder
    socialCode?: SortOrder
  }

  export type RolesScalarRelationFilter = {
    is?: RolesWhereInput
    isNot?: RolesWhereInput
  }

  export type UserRolesUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: number
  }

  export type UserRolesCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRolesAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRolesMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRolesMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRolesSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SocialCountOrderByAggregateInput = {
    name?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    codeName?: SortOrder
    profileLinkFormat?: SortOrder
    profileEntryFormat?: SortOrder
    darkModeColor?: SortOrder
    lightModeColor?: SortOrder
  }

  export type SocialMaxOrderByAggregateInput = {
    name?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    codeName?: SortOrder
    profileLinkFormat?: SortOrder
    profileEntryFormat?: SortOrder
    darkModeColor?: SortOrder
    lightModeColor?: SortOrder
  }

  export type SocialMinOrderByAggregateInput = {
    name?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    codeName?: SortOrder
    profileLinkFormat?: SortOrder
    profileEntryFormat?: SortOrder
    darkModeColor?: SortOrder
    lightModeColor?: SortOrder
  }

  export type PostVersionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    instanceAt?: SortOrder
  }

  export type PostVersionHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type PostVersionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    instanceAt?: SortOrder
  }

  export type PostVersionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    instanceAt?: SortOrder
  }

  export type PostVersionHistorySumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type PathwayTypesNullableScalarRelationFilter = {
    is?: PathwayTypesWhereInput | null
    isNot?: PathwayTypesWhereInput | null
  }

  export type PathwayTypesListRelationFilter = {
    every?: PathwayTypesWhereInput
    some?: PathwayTypesWhereInput
    none?: PathwayTypesWhereInput
  }

  export type PathwayTypesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
  }

  export type PathwayTypesAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type PathwayTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
  }

  export type PathwayTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    description?: SortOrder
  }

  export type PathwayTypesSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type PathwayTypesScalarRelationFilter = {
    is?: PathwayTypesWhereInput
    isNot?: PathwayTypesWhereInput
  }

  export type PathwayCategoriesPathwayIdPathwayTypeIdCompoundUniqueInput = {
    pathwayId: number
    pathwayTypeId: number
  }

  export type PathwayCategoriesCountOrderByAggregateInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
  }

  export type PathwayCategoriesAvgOrderByAggregateInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
  }

  export type PathwayCategoriesMaxOrderByAggregateInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
  }

  export type PathwayCategoriesMinOrderByAggregateInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
  }

  export type PathwayCategoriesSumOrderByAggregateInput = {
    pathwayId?: SortOrder
    pathwayTypeId?: SortOrder
  }

  export type ContentResourceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ContentResourceTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContentResourceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ContentResourceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    icon?: SortOrder
    color?: SortOrder
  }

  export type ContentResourceTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContentResourceAreaCountOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    tagline?: SortOrder
  }

  export type ContentResourceAreaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContentResourceAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    tagline?: SortOrder
  }

  export type ContentResourceAreaMinOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    tagline?: SortOrder
  }

  export type ContentResourceAreaSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContentResourceAreaScalarRelationFilter = {
    is?: ContentResourceAreaWhereInput
    isNot?: ContentResourceAreaWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ContentResourceTypeScalarRelationFilter = {
    is?: ContentResourceTypeWhereInput
    isNot?: ContentResourceTypeWhereInput
  }

  export type ContentResourceCountOrderByAggregateInput = {
    id?: SortOrder
    href?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    typeId?: SortOrder
    icon?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    areaId?: SortOrder
    authorString?: SortOrder
  }

  export type ContentResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    areaId?: SortOrder
  }

  export type ContentResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    typeId?: SortOrder
    icon?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    areaId?: SortOrder
    authorString?: SortOrder
  }

  export type ContentResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    typeId?: SortOrder
    icon?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    areaId?: SortOrder
    authorString?: SortOrder
  }

  export type ContentResourceSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    areaId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountryCurrencyCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput> | CountryCurrencyCreateWithoutCountryInput[] | CountryCurrencyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCountryInput | CountryCurrencyCreateOrConnectWithoutCountryInput[]
    createMany?: CountryCurrencyCreateManyCountryInputEnvelope
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
  }

  export type CountryLanguageCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput> | CountryLanguageCreateWithoutCountryInput[] | CountryLanguageUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutCountryInput | CountryLanguageCreateOrConnectWithoutCountryInput[]
    createMany?: CountryLanguageCreateManyCountryInputEnvelope
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
  }

  export type PathwayRestrictedNationalityCreateNestedManyWithoutCountryInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput> | PathwayRestrictedNationalityCreateWithoutCountryInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput | PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput[]
    createMany?: PathwayRestrictedNationalityCreateManyCountryInputEnvelope
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutCountryInput = {
    create?: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput> | PathwayCreateWithoutCountryInput[] | PathwayUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCountryInput | PathwayCreateOrConnectWithoutCountryInput[]
    createMany?: PathwayCreateManyCountryInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type CountryCurrencyUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput> | CountryCurrencyCreateWithoutCountryInput[] | CountryCurrencyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCountryInput | CountryCurrencyCreateOrConnectWithoutCountryInput[]
    createMany?: CountryCurrencyCreateManyCountryInputEnvelope
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
  }

  export type CountryLanguageUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput> | CountryLanguageCreateWithoutCountryInput[] | CountryLanguageUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutCountryInput | CountryLanguageCreateOrConnectWithoutCountryInput[]
    createMany?: CountryLanguageCreateManyCountryInputEnvelope
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
  }

  export type PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput> | PathwayRestrictedNationalityCreateWithoutCountryInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput | PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput[]
    createMany?: PathwayRestrictedNationalityCreateManyCountryInputEnvelope
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput> | PathwayCreateWithoutCountryInput[] | PathwayUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCountryInput | PathwayCreateOrConnectWithoutCountryInput[]
    createMany?: PathwayCreateManyCountryInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type CountryCurrencyUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput> | CountryCurrencyCreateWithoutCountryInput[] | CountryCurrencyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCountryInput | CountryCurrencyCreateOrConnectWithoutCountryInput[]
    upsert?: CountryCurrencyUpsertWithWhereUniqueWithoutCountryInput | CountryCurrencyUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryCurrencyCreateManyCountryInputEnvelope
    set?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    disconnect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    delete?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    update?: CountryCurrencyUpdateWithWhereUniqueWithoutCountryInput | CountryCurrencyUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryCurrencyUpdateManyWithWhereWithoutCountryInput | CountryCurrencyUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
  }

  export type CountryLanguageUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput> | CountryLanguageCreateWithoutCountryInput[] | CountryLanguageUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutCountryInput | CountryLanguageCreateOrConnectWithoutCountryInput[]
    upsert?: CountryLanguageUpsertWithWhereUniqueWithoutCountryInput | CountryLanguageUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryLanguageCreateManyCountryInputEnvelope
    set?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    disconnect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    delete?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    update?: CountryLanguageUpdateWithWhereUniqueWithoutCountryInput | CountryLanguageUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryLanguageUpdateManyWithWhereWithoutCountryInput | CountryLanguageUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
  }

  export type PathwayRestrictedNationalityUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput> | PathwayRestrictedNationalityCreateWithoutCountryInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput | PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput[]
    upsert?: PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutCountryInput | PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PathwayRestrictedNationalityCreateManyCountryInputEnvelope
    set?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    disconnect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    delete?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    update?: PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutCountryInput | PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PathwayRestrictedNationalityUpdateManyWithWhereWithoutCountryInput | PathwayRestrictedNationalityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput> | PathwayCreateWithoutCountryInput[] | PathwayUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCountryInput | PathwayCreateOrConnectWithoutCountryInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCountryInput | PathwayUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PathwayCreateManyCountryInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCountryInput | PathwayUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCountryInput | PathwayUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type CountryCurrencyUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput> | CountryCurrencyCreateWithoutCountryInput[] | CountryCurrencyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCountryInput | CountryCurrencyCreateOrConnectWithoutCountryInput[]
    upsert?: CountryCurrencyUpsertWithWhereUniqueWithoutCountryInput | CountryCurrencyUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryCurrencyCreateManyCountryInputEnvelope
    set?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    disconnect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    delete?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    update?: CountryCurrencyUpdateWithWhereUniqueWithoutCountryInput | CountryCurrencyUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryCurrencyUpdateManyWithWhereWithoutCountryInput | CountryCurrencyUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
  }

  export type CountryLanguageUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput> | CountryLanguageCreateWithoutCountryInput[] | CountryLanguageUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutCountryInput | CountryLanguageCreateOrConnectWithoutCountryInput[]
    upsert?: CountryLanguageUpsertWithWhereUniqueWithoutCountryInput | CountryLanguageUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryLanguageCreateManyCountryInputEnvelope
    set?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    disconnect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    delete?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    update?: CountryLanguageUpdateWithWhereUniqueWithoutCountryInput | CountryLanguageUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryLanguageUpdateManyWithWhereWithoutCountryInput | CountryLanguageUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
  }

  export type PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput> | PathwayRestrictedNationalityCreateWithoutCountryInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput | PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput[]
    upsert?: PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutCountryInput | PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PathwayRestrictedNationalityCreateManyCountryInputEnvelope
    set?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    disconnect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    delete?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    update?: PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutCountryInput | PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PathwayRestrictedNationalityUpdateManyWithWhereWithoutCountryInput | PathwayRestrictedNationalityUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput> | PathwayCreateWithoutCountryInput[] | PathwayUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCountryInput | PathwayCreateOrConnectWithoutCountryInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCountryInput | PathwayUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PathwayCreateManyCountryInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCountryInput | PathwayUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCountryInput | PathwayUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutCountryLanguagesInput = {
    create?: XOR<CountryCreateWithoutCountryLanguagesInput, CountryUncheckedCreateWithoutCountryLanguagesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCountryLanguagesInput
    connect?: CountryWhereUniqueInput
  }

  export type LanguageCreateNestedOneWithoutCountryLanguagesInput = {
    create?: XOR<LanguageCreateWithoutCountryLanguagesInput, LanguageUncheckedCreateWithoutCountryLanguagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCountryLanguagesInput
    connect?: LanguageWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutCountryLanguagesNestedInput = {
    create?: XOR<CountryCreateWithoutCountryLanguagesInput, CountryUncheckedCreateWithoutCountryLanguagesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCountryLanguagesInput
    upsert?: CountryUpsertWithoutCountryLanguagesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCountryLanguagesInput, CountryUpdateWithoutCountryLanguagesInput>, CountryUncheckedUpdateWithoutCountryLanguagesInput>
  }

  export type LanguageUpdateOneRequiredWithoutCountryLanguagesNestedInput = {
    create?: XOR<LanguageCreateWithoutCountryLanguagesInput, LanguageUncheckedCreateWithoutCountryLanguagesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutCountryLanguagesInput
    upsert?: LanguageUpsertWithoutCountryLanguagesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutCountryLanguagesInput, LanguageUpdateWithoutCountryLanguagesInput>, LanguageUncheckedUpdateWithoutCountryLanguagesInput>
  }

  export type CountryCreateNestedOneWithoutCountryCurrenciesInput = {
    create?: XOR<CountryCreateWithoutCountryCurrenciesInput, CountryUncheckedCreateWithoutCountryCurrenciesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCountryCurrenciesInput
    connect?: CountryWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutCountryCurrenciesInput = {
    create?: XOR<CurrencyCreateWithoutCountryCurrenciesInput, CurrencyUncheckedCreateWithoutCountryCurrenciesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCountryCurrenciesInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutCountryCurrenciesNestedInput = {
    create?: XOR<CountryCreateWithoutCountryCurrenciesInput, CountryUncheckedCreateWithoutCountryCurrenciesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCountryCurrenciesInput
    upsert?: CountryUpsertWithoutCountryCurrenciesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutCountryCurrenciesInput, CountryUpdateWithoutCountryCurrenciesInput>, CountryUncheckedUpdateWithoutCountryCurrenciesInput>
  }

  export type CurrencyUpdateOneRequiredWithoutCountryCurrenciesNestedInput = {
    create?: XOR<CurrencyCreateWithoutCountryCurrenciesInput, CurrencyUncheckedCreateWithoutCountryCurrenciesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCountryCurrenciesInput
    upsert?: CurrencyUpsertWithoutCountryCurrenciesInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutCountryCurrenciesInput, CurrencyUpdateWithoutCountryCurrenciesInput>, CurrencyUncheckedUpdateWithoutCountryCurrenciesInput>
  }

  export type PathwayCreatenotesInput = {
    set: string[]
  }

  export type PathwayCreatelimitationsInput = {
    set: string[]
  }

  export type PathwayCreaterequirementsInput = {
    set: string[]
  }

  export type PathwayCreaterestrictionsInput = {
    set: string[]
  }

  export type PathwayDocumentsCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput> | PathwayDocumentsCreateWithoutPathwayInput[] | PathwayDocumentsUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutPathwayInput | PathwayDocumentsCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayDocumentsCreateManyPathwayInputEnvelope
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
  }

  export type PathwayCategoriesCreateNestedManyWithoutPathwaysInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput> | PathwayCategoriesCreateWithoutPathwaysInput[] | PathwayCategoriesUncheckedCreateWithoutPathwaysInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathwaysInput | PathwayCategoriesCreateOrConnectWithoutPathwaysInput[]
    createMany?: PathwayCategoriesCreateManyPathwaysInputEnvelope
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
  }

  export type PathwayPipelineCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput> | PathwayPipelineCreateWithoutPathwayInput[] | PathwayPipelineUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayPipelineCreateOrConnectWithoutPathwayInput | PathwayPipelineCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayPipelineCreateManyPathwayInputEnvelope
    connect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
  }

  export type PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput> | PathwayRestrictedNationalityCreateWithoutPathwayInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput | PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayRestrictedNationalityCreateManyPathwayInputEnvelope
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
  }

  export type CountryCreateNestedOneWithoutPathwaysInput = {
    create?: XOR<CountryCreateWithoutPathwaysInput, CountryUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPathwaysInput
    connect?: CountryWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutPathwaysInput = {
    create?: XOR<CurrencyCreateWithoutPathwaysInput, CurrencyUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPathwaysInput
    connect?: CurrencyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPathwayInput = {
    create?: XOR<UserCreateWithoutPathwayInput, UserUncheckedCreateWithoutPathwayInput>
    connectOrCreate?: UserCreateOrConnectWithoutPathwayInput
    connect?: UserWhereUniqueInput
  }

  export type PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput> | PathwayDocumentsCreateWithoutPathwayInput[] | PathwayDocumentsUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutPathwayInput | PathwayDocumentsCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayDocumentsCreateManyPathwayInputEnvelope
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
  }

  export type PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput> | PathwayCategoriesCreateWithoutPathwaysInput[] | PathwayCategoriesUncheckedCreateWithoutPathwaysInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathwaysInput | PathwayCategoriesCreateOrConnectWithoutPathwaysInput[]
    createMany?: PathwayCategoriesCreateManyPathwaysInputEnvelope
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
  }

  export type PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput> | PathwayPipelineCreateWithoutPathwayInput[] | PathwayPipelineUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayPipelineCreateOrConnectWithoutPathwayInput | PathwayPipelineCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayPipelineCreateManyPathwayInputEnvelope
    connect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
  }

  export type PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput> | PathwayRestrictedNationalityCreateWithoutPathwayInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput | PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput[]
    createMany?: PathwayRestrictedNationalityCreateManyPathwayInputEnvelope
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
  }

  export type EnumPathwayTypeFieldUpdateOperationsInput = {
    set?: $Enums.PathwayType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PathwayUpdatenotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PathwayUpdatelimitationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PathwayUpdaterequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PathwayUpdaterestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PathwayDocumentsUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput> | PathwayDocumentsCreateWithoutPathwayInput[] | PathwayDocumentsUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutPathwayInput | PathwayDocumentsCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayDocumentsUpsertWithWhereUniqueWithoutPathwayInput | PathwayDocumentsUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayDocumentsCreateManyPathwayInputEnvelope
    set?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    disconnect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    delete?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    update?: PathwayDocumentsUpdateWithWhereUniqueWithoutPathwayInput | PathwayDocumentsUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayDocumentsUpdateManyWithWhereWithoutPathwayInput | PathwayDocumentsUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
  }

  export type PathwayCategoriesUpdateManyWithoutPathwaysNestedInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput> | PathwayCategoriesCreateWithoutPathwaysInput[] | PathwayCategoriesUncheckedCreateWithoutPathwaysInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathwaysInput | PathwayCategoriesCreateOrConnectWithoutPathwaysInput[]
    upsert?: PathwayCategoriesUpsertWithWhereUniqueWithoutPathwaysInput | PathwayCategoriesUpsertWithWhereUniqueWithoutPathwaysInput[]
    createMany?: PathwayCategoriesCreateManyPathwaysInputEnvelope
    set?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    disconnect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    delete?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    update?: PathwayCategoriesUpdateWithWhereUniqueWithoutPathwaysInput | PathwayCategoriesUpdateWithWhereUniqueWithoutPathwaysInput[]
    updateMany?: PathwayCategoriesUpdateManyWithWhereWithoutPathwaysInput | PathwayCategoriesUpdateManyWithWhereWithoutPathwaysInput[]
    deleteMany?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
  }

  export type PathwayPipelineUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput> | PathwayPipelineCreateWithoutPathwayInput[] | PathwayPipelineUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayPipelineCreateOrConnectWithoutPathwayInput | PathwayPipelineCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayPipelineUpsertWithWhereUniqueWithoutPathwayInput | PathwayPipelineUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayPipelineCreateManyPathwayInputEnvelope
    set?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    disconnect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    delete?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    connect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    update?: PathwayPipelineUpdateWithWhereUniqueWithoutPathwayInput | PathwayPipelineUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayPipelineUpdateManyWithWhereWithoutPathwayInput | PathwayPipelineUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayPipelineScalarWhereInput | PathwayPipelineScalarWhereInput[]
  }

  export type PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput> | PathwayRestrictedNationalityCreateWithoutPathwayInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput | PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutPathwayInput | PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayRestrictedNationalityCreateManyPathwayInputEnvelope
    set?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    disconnect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    delete?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    update?: PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutPathwayInput | PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayRestrictedNationalityUpdateManyWithWhereWithoutPathwayInput | PathwayRestrictedNationalityUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
  }

  export type CountryUpdateOneRequiredWithoutPathwaysNestedInput = {
    create?: XOR<CountryCreateWithoutPathwaysInput, CountryUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: CountryCreateOrConnectWithoutPathwaysInput
    upsert?: CountryUpsertWithoutPathwaysInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutPathwaysInput, CountryUpdateWithoutPathwaysInput>, CountryUncheckedUpdateWithoutPathwaysInput>
  }

  export type CurrencyUpdateOneRequiredWithoutPathwaysNestedInput = {
    create?: XOR<CurrencyCreateWithoutPathwaysInput, CurrencyUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPathwaysInput
    upsert?: CurrencyUpsertWithoutPathwaysInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutPathwaysInput, CurrencyUpdateWithoutPathwaysInput>, CurrencyUncheckedUpdateWithoutPathwaysInput>
  }

  export type UserUpdateOneRequiredWithoutPathwayNestedInput = {
    create?: XOR<UserCreateWithoutPathwayInput, UserUncheckedCreateWithoutPathwayInput>
    connectOrCreate?: UserCreateOrConnectWithoutPathwayInput
    upsert?: UserUpsertWithoutPathwayInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPathwayInput, UserUpdateWithoutPathwayInput>, UserUncheckedUpdateWithoutPathwayInput>
  }

  export type PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput> | PathwayDocumentsCreateWithoutPathwayInput[] | PathwayDocumentsUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutPathwayInput | PathwayDocumentsCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayDocumentsUpsertWithWhereUniqueWithoutPathwayInput | PathwayDocumentsUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayDocumentsCreateManyPathwayInputEnvelope
    set?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    disconnect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    delete?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    update?: PathwayDocumentsUpdateWithWhereUniqueWithoutPathwayInput | PathwayDocumentsUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayDocumentsUpdateManyWithWhereWithoutPathwayInput | PathwayDocumentsUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
  }

  export type PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput> | PathwayCategoriesCreateWithoutPathwaysInput[] | PathwayCategoriesUncheckedCreateWithoutPathwaysInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathwaysInput | PathwayCategoriesCreateOrConnectWithoutPathwaysInput[]
    upsert?: PathwayCategoriesUpsertWithWhereUniqueWithoutPathwaysInput | PathwayCategoriesUpsertWithWhereUniqueWithoutPathwaysInput[]
    createMany?: PathwayCategoriesCreateManyPathwaysInputEnvelope
    set?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    disconnect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    delete?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    update?: PathwayCategoriesUpdateWithWhereUniqueWithoutPathwaysInput | PathwayCategoriesUpdateWithWhereUniqueWithoutPathwaysInput[]
    updateMany?: PathwayCategoriesUpdateManyWithWhereWithoutPathwaysInput | PathwayCategoriesUpdateManyWithWhereWithoutPathwaysInput[]
    deleteMany?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
  }

  export type PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput> | PathwayPipelineCreateWithoutPathwayInput[] | PathwayPipelineUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayPipelineCreateOrConnectWithoutPathwayInput | PathwayPipelineCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayPipelineUpsertWithWhereUniqueWithoutPathwayInput | PathwayPipelineUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayPipelineCreateManyPathwayInputEnvelope
    set?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    disconnect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    delete?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    connect?: PathwayPipelineWhereUniqueInput | PathwayPipelineWhereUniqueInput[]
    update?: PathwayPipelineUpdateWithWhereUniqueWithoutPathwayInput | PathwayPipelineUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayPipelineUpdateManyWithWhereWithoutPathwayInput | PathwayPipelineUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayPipelineScalarWhereInput | PathwayPipelineScalarWhereInput[]
  }

  export type PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput = {
    create?: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput> | PathwayRestrictedNationalityCreateWithoutPathwayInput[] | PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput[]
    connectOrCreate?: PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput | PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput[]
    upsert?: PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutPathwayInput | PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutPathwayInput[]
    createMany?: PathwayRestrictedNationalityCreateManyPathwayInputEnvelope
    set?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    disconnect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    delete?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    connect?: PathwayRestrictedNationalityWhereUniqueInput | PathwayRestrictedNationalityWhereUniqueInput[]
    update?: PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutPathwayInput | PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutPathwayInput[]
    updateMany?: PathwayRestrictedNationalityUpdateManyWithWhereWithoutPathwayInput | PathwayRestrictedNationalityUpdateManyWithWhereWithoutPathwayInput[]
    deleteMany?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
  }

  export type PathwayCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<PathwayCreateWithoutPipelinesInput, PathwayUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutPipelinesInput
    connect?: PathwayWhereUniqueInput
  }

  export type EnumPathwayPipelinesFieldUpdateOperationsInput = {
    set?: $Enums.PathwayPipelines
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PathwayUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<PathwayCreateWithoutPipelinesInput, PathwayUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutPipelinesInput
    upsert?: PathwayUpsertWithoutPipelinesInput
    connect?: PathwayWhereUniqueInput
    update?: XOR<XOR<PathwayUpdateToOneWithWhereWithoutPipelinesInput, PathwayUpdateWithoutPipelinesInput>, PathwayUncheckedUpdateWithoutPipelinesInput>
  }

  export type CountryCreateNestedOneWithoutRestrictedPathwaysInput = {
    create?: XOR<CountryCreateWithoutRestrictedPathwaysInput, CountryUncheckedCreateWithoutRestrictedPathwaysInput>
    connectOrCreate?: CountryCreateOrConnectWithoutRestrictedPathwaysInput
    connect?: CountryWhereUniqueInput
  }

  export type PathwayCreateNestedOneWithoutRestrictedNationalitiesInput = {
    create?: XOR<PathwayCreateWithoutRestrictedNationalitiesInput, PathwayUncheckedCreateWithoutRestrictedNationalitiesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutRestrictedNationalitiesInput
    connect?: PathwayWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutRestrictedPathwaysNestedInput = {
    create?: XOR<CountryCreateWithoutRestrictedPathwaysInput, CountryUncheckedCreateWithoutRestrictedPathwaysInput>
    connectOrCreate?: CountryCreateOrConnectWithoutRestrictedPathwaysInput
    upsert?: CountryUpsertWithoutRestrictedPathwaysInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutRestrictedPathwaysInput, CountryUpdateWithoutRestrictedPathwaysInput>, CountryUncheckedUpdateWithoutRestrictedPathwaysInput>
  }

  export type PathwayUpdateOneRequiredWithoutRestrictedNationalitiesNestedInput = {
    create?: XOR<PathwayCreateWithoutRestrictedNationalitiesInput, PathwayUncheckedCreateWithoutRestrictedNationalitiesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutRestrictedNationalitiesInput
    upsert?: PathwayUpsertWithoutRestrictedNationalitiesInput
    connect?: PathwayWhereUniqueInput
    update?: XOR<XOR<PathwayUpdateToOneWithWhereWithoutRestrictedNationalitiesInput, PathwayUpdateWithoutRestrictedNationalitiesInput>, PathwayUncheckedUpdateWithoutRestrictedNationalitiesInput>
  }

  export type DocumentsCreateNestedOneWithoutPathwayDocumentsInput = {
    create?: XOR<DocumentsCreateWithoutPathwayDocumentsInput, DocumentsUncheckedCreateWithoutPathwayDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutPathwayDocumentsInput
    connect?: DocumentsWhereUniqueInput
  }

  export type PathwayCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PathwayCreateWithoutDocumentsInput, PathwayUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutDocumentsInput
    connect?: PathwayWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DocumentsUpdateOneRequiredWithoutPathwayDocumentsNestedInput = {
    create?: XOR<DocumentsCreateWithoutPathwayDocumentsInput, DocumentsUncheckedCreateWithoutPathwayDocumentsInput>
    connectOrCreate?: DocumentsCreateOrConnectWithoutPathwayDocumentsInput
    upsert?: DocumentsUpsertWithoutPathwayDocumentsInput
    connect?: DocumentsWhereUniqueInput
    update?: XOR<XOR<DocumentsUpdateToOneWithWhereWithoutPathwayDocumentsInput, DocumentsUpdateWithoutPathwayDocumentsInput>, DocumentsUncheckedUpdateWithoutPathwayDocumentsInput>
  }

  export type PathwayUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PathwayCreateWithoutDocumentsInput, PathwayUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutDocumentsInput
    upsert?: PathwayUpsertWithoutDocumentsInput
    connect?: PathwayWhereUniqueInput
    update?: XOR<XOR<PathwayUpdateToOneWithWhereWithoutDocumentsInput, PathwayUpdateWithoutDocumentsInput>, PathwayUncheckedUpdateWithoutDocumentsInput>
  }

  export type CountryCurrencyCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput> | CountryCurrencyCreateWithoutCurrencyInput[] | CountryCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCurrencyInput | CountryCurrencyCreateOrConnectWithoutCurrencyInput[]
    createMany?: CountryCurrencyCreateManyCurrencyInputEnvelope
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput> | PathwayCreateWithoutCurrencyInput[] | PathwayUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCurrencyInput | PathwayCreateOrConnectWithoutCurrencyInput[]
    createMany?: PathwayCreateManyCurrencyInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type CountryCurrencyUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput> | CountryCurrencyCreateWithoutCurrencyInput[] | CountryCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCurrencyInput | CountryCurrencyCreateOrConnectWithoutCurrencyInput[]
    createMany?: CountryCurrencyCreateManyCurrencyInputEnvelope
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput> | PathwayCreateWithoutCurrencyInput[] | PathwayUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCurrencyInput | PathwayCreateOrConnectWithoutCurrencyInput[]
    createMany?: PathwayCreateManyCurrencyInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type CountryCurrencyUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput> | CountryCurrencyCreateWithoutCurrencyInput[] | CountryCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCurrencyInput | CountryCurrencyCreateOrConnectWithoutCurrencyInput[]
    upsert?: CountryCurrencyUpsertWithWhereUniqueWithoutCurrencyInput | CountryCurrencyUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: CountryCurrencyCreateManyCurrencyInputEnvelope
    set?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    disconnect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    delete?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    update?: CountryCurrencyUpdateWithWhereUniqueWithoutCurrencyInput | CountryCurrencyUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: CountryCurrencyUpdateManyWithWhereWithoutCurrencyInput | CountryCurrencyUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput> | PathwayCreateWithoutCurrencyInput[] | PathwayUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCurrencyInput | PathwayCreateOrConnectWithoutCurrencyInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCurrencyInput | PathwayUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PathwayCreateManyCurrencyInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCurrencyInput | PathwayUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCurrencyInput | PathwayUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type CountryCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput> | CountryCurrencyCreateWithoutCurrencyInput[] | CountryCurrencyUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: CountryCurrencyCreateOrConnectWithoutCurrencyInput | CountryCurrencyCreateOrConnectWithoutCurrencyInput[]
    upsert?: CountryCurrencyUpsertWithWhereUniqueWithoutCurrencyInput | CountryCurrencyUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: CountryCurrencyCreateManyCurrencyInputEnvelope
    set?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    disconnect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    delete?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    connect?: CountryCurrencyWhereUniqueInput | CountryCurrencyWhereUniqueInput[]
    update?: CountryCurrencyUpdateWithWhereUniqueWithoutCurrencyInput | CountryCurrencyUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: CountryCurrencyUpdateManyWithWhereWithoutCurrencyInput | CountryCurrencyUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput> | PathwayCreateWithoutCurrencyInput[] | PathwayUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCurrencyInput | PathwayCreateOrConnectWithoutCurrencyInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCurrencyInput | PathwayUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PathwayCreateManyCurrencyInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCurrencyInput | PathwayUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCurrencyInput | PathwayUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type DocumentsCreatetypeInput = {
    set: $Enums.DocumentType[]
  }

  export type PathwayDocumentsCreateNestedManyWithoutDocumentInput = {
    create?: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput> | PathwayDocumentsCreateWithoutDocumentInput[] | PathwayDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutDocumentInput | PathwayDocumentsCreateOrConnectWithoutDocumentInput[]
    createMany?: PathwayDocumentsCreateManyDocumentInputEnvelope
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
  }

  export type PathwayDocumentsUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput> | PathwayDocumentsCreateWithoutDocumentInput[] | PathwayDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutDocumentInput | PathwayDocumentsCreateOrConnectWithoutDocumentInput[]
    createMany?: PathwayDocumentsCreateManyDocumentInputEnvelope
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
  }

  export type DocumentsUpdatetypeInput = {
    set?: $Enums.DocumentType[]
    push?: $Enums.DocumentType | $Enums.DocumentType[]
  }

  export type PathwayDocumentsUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput> | PathwayDocumentsCreateWithoutDocumentInput[] | PathwayDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutDocumentInput | PathwayDocumentsCreateOrConnectWithoutDocumentInput[]
    upsert?: PathwayDocumentsUpsertWithWhereUniqueWithoutDocumentInput | PathwayDocumentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: PathwayDocumentsCreateManyDocumentInputEnvelope
    set?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    disconnect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    delete?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    update?: PathwayDocumentsUpdateWithWhereUniqueWithoutDocumentInput | PathwayDocumentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: PathwayDocumentsUpdateManyWithWhereWithoutDocumentInput | PathwayDocumentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
  }

  export type PathwayDocumentsUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput> | PathwayDocumentsCreateWithoutDocumentInput[] | PathwayDocumentsUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: PathwayDocumentsCreateOrConnectWithoutDocumentInput | PathwayDocumentsCreateOrConnectWithoutDocumentInput[]
    upsert?: PathwayDocumentsUpsertWithWhereUniqueWithoutDocumentInput | PathwayDocumentsUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: PathwayDocumentsCreateManyDocumentInputEnvelope
    set?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    disconnect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    delete?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    connect?: PathwayDocumentsWhereUniqueInput | PathwayDocumentsWhereUniqueInput[]
    update?: PathwayDocumentsUpdateWithWhereUniqueWithoutDocumentInput | PathwayDocumentsUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: PathwayDocumentsUpdateManyWithWhereWithoutDocumentInput | PathwayDocumentsUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
  }

  export type CountryLanguageCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput> | CountryLanguageCreateWithoutLanguageInput[] | CountryLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutLanguageInput | CountryLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: CountryLanguageCreateManyLanguageInputEnvelope
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
  }

  export type CountryLanguageUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput> | CountryLanguageCreateWithoutLanguageInput[] | CountryLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutLanguageInput | CountryLanguageCreateOrConnectWithoutLanguageInput[]
    createMany?: CountryLanguageCreateManyLanguageInputEnvelope
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
  }

  export type CountryLanguageUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput> | CountryLanguageCreateWithoutLanguageInput[] | CountryLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutLanguageInput | CountryLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: CountryLanguageUpsertWithWhereUniqueWithoutLanguageInput | CountryLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CountryLanguageCreateManyLanguageInputEnvelope
    set?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    disconnect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    delete?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    update?: CountryLanguageUpdateWithWhereUniqueWithoutLanguageInput | CountryLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CountryLanguageUpdateManyWithWhereWithoutLanguageInput | CountryLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
  }

  export type CountryLanguageUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput> | CountryLanguageCreateWithoutLanguageInput[] | CountryLanguageUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: CountryLanguageCreateOrConnectWithoutLanguageInput | CountryLanguageCreateOrConnectWithoutLanguageInput[]
    upsert?: CountryLanguageUpsertWithWhereUniqueWithoutLanguageInput | CountryLanguageUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: CountryLanguageCreateManyLanguageInputEnvelope
    set?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    disconnect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    delete?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    connect?: CountryLanguageWhereUniqueInput | CountryLanguageWhereUniqueInput[]
    update?: CountryLanguageUpdateWithWhereUniqueWithoutLanguageInput | CountryLanguageUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: CountryLanguageUpdateManyWithWhereWithoutLanguageInput | CountryLanguageUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
  }

  export type PostCreatemetaKeywordsInput = {
    set: string[]
  }

  export type PostBlockCreateNestedManyWithoutPostInput = {
    create?: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput> | PostBlockCreateWithoutPostInput[] | PostBlockUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutPostInput | PostBlockCreateOrConnectWithoutPostInput[]
    createMany?: PostBlockCreateManyPostInputEnvelope
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
  }

  export type PostTagCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostVersionHistoryCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput> | PostVersionHistoryCreateWithoutPostInput[] | PostVersionHistoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutPostInput | PostVersionHistoryCreateOrConnectWithoutPostInput[]
    createMany?: PostVersionHistoryCreateManyPostInputEnvelope
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostBlockUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput> | PostBlockCreateWithoutPostInput[] | PostBlockUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutPostInput | PostBlockCreateOrConnectWithoutPostInput[]
    createMany?: PostBlockCreateManyPostInputEnvelope
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type PostVersionHistoryUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput> | PostVersionHistoryCreateWithoutPostInput[] | PostVersionHistoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutPostInput | PostVersionHistoryCreateOrConnectWithoutPostInput[]
    createMany?: PostVersionHistoryCreateManyPostInputEnvelope
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
  }

  export type PostUpdatemetaKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type PostBlockUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput> | PostBlockCreateWithoutPostInput[] | PostBlockUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutPostInput | PostBlockCreateOrConnectWithoutPostInput[]
    upsert?: PostBlockUpsertWithWhereUniqueWithoutPostInput | PostBlockUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostBlockCreateManyPostInputEnvelope
    set?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    disconnect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    delete?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    update?: PostBlockUpdateWithWhereUniqueWithoutPostInput | PostBlockUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostBlockUpdateManyWithWhereWithoutPostInput | PostBlockUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
  }

  export type PostTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type PostVersionHistoryUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput> | PostVersionHistoryCreateWithoutPostInput[] | PostVersionHistoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutPostInput | PostVersionHistoryCreateOrConnectWithoutPostInput[]
    upsert?: PostVersionHistoryUpsertWithWhereUniqueWithoutPostInput | PostVersionHistoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVersionHistoryCreateManyPostInputEnvelope
    set?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    disconnect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    delete?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    update?: PostVersionHistoryUpdateWithWhereUniqueWithoutPostInput | PostVersionHistoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVersionHistoryUpdateManyWithWhereWithoutPostInput | PostVersionHistoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostBlockUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput> | PostBlockCreateWithoutPostInput[] | PostBlockUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutPostInput | PostBlockCreateOrConnectWithoutPostInput[]
    upsert?: PostBlockUpsertWithWhereUniqueWithoutPostInput | PostBlockUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostBlockCreateManyPostInputEnvelope
    set?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    disconnect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    delete?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    update?: PostBlockUpdateWithWhereUniqueWithoutPostInput | PostBlockUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostBlockUpdateManyWithWhereWithoutPostInput | PostBlockUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type PostVersionHistoryUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput> | PostVersionHistoryCreateWithoutPostInput[] | PostVersionHistoryUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutPostInput | PostVersionHistoryCreateOrConnectWithoutPostInput[]
    upsert?: PostVersionHistoryUpsertWithWhereUniqueWithoutPostInput | PostVersionHistoryUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVersionHistoryCreateManyPostInputEnvelope
    set?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    disconnect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    delete?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    update?: PostVersionHistoryUpdateWithWhereUniqueWithoutPostInput | PostVersionHistoryUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVersionHistoryUpdateManyWithWhereWithoutPostInput | PostVersionHistoryUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    connect?: PostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    upsert?: PostUpsertWithoutTagsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutTagsInput, PostUpdateWithoutTagsInput>, PostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type PostTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type TagHierarchyCreateNestedManyWithoutParentInput = {
    create?: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput> | TagHierarchyCreateWithoutParentInput[] | TagHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutParentInput | TagHierarchyCreateOrConnectWithoutParentInput[]
    createMany?: TagHierarchyCreateManyParentInputEnvelope
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
  }

  export type TagHierarchyCreateNestedManyWithoutChildInput = {
    create?: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput> | TagHierarchyCreateWithoutChildInput[] | TagHierarchyUncheckedCreateWithoutChildInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutChildInput | TagHierarchyCreateOrConnectWithoutChildInput[]
    createMany?: TagHierarchyCreateManyChildInputEnvelope
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
  }

  export type TagCreateNestedOneWithoutChildrenInput = {
    create?: XOR<TagCreateWithoutChildrenInput, TagUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TagCreateOrConnectWithoutChildrenInput
    connect?: TagWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutParentInput = {
    create?: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput> | TagCreateWithoutParentInput[] | TagUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagCreateOrConnectWithoutParentInput | TagCreateOrConnectWithoutParentInput[]
    createMany?: TagCreateManyParentInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type TagHierarchyUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput> | TagHierarchyCreateWithoutParentInput[] | TagHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutParentInput | TagHierarchyCreateOrConnectWithoutParentInput[]
    createMany?: TagHierarchyCreateManyParentInputEnvelope
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
  }

  export type TagHierarchyUncheckedCreateNestedManyWithoutChildInput = {
    create?: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput> | TagHierarchyCreateWithoutChildInput[] | TagHierarchyUncheckedCreateWithoutChildInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutChildInput | TagHierarchyCreateOrConnectWithoutChildInput[]
    createMany?: TagHierarchyCreateManyChildInputEnvelope
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput> | TagCreateWithoutParentInput[] | TagUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagCreateOrConnectWithoutParentInput | TagCreateOrConnectWithoutParentInput[]
    createMany?: TagCreateManyParentInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type PostTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type TagHierarchyUpdateManyWithoutParentNestedInput = {
    create?: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput> | TagHierarchyCreateWithoutParentInput[] | TagHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutParentInput | TagHierarchyCreateOrConnectWithoutParentInput[]
    upsert?: TagHierarchyUpsertWithWhereUniqueWithoutParentInput | TagHierarchyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TagHierarchyCreateManyParentInputEnvelope
    set?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    disconnect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    delete?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    update?: TagHierarchyUpdateWithWhereUniqueWithoutParentInput | TagHierarchyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TagHierarchyUpdateManyWithWhereWithoutParentInput | TagHierarchyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
  }

  export type TagHierarchyUpdateManyWithoutChildNestedInput = {
    create?: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput> | TagHierarchyCreateWithoutChildInput[] | TagHierarchyUncheckedCreateWithoutChildInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutChildInput | TagHierarchyCreateOrConnectWithoutChildInput[]
    upsert?: TagHierarchyUpsertWithWhereUniqueWithoutChildInput | TagHierarchyUpsertWithWhereUniqueWithoutChildInput[]
    createMany?: TagHierarchyCreateManyChildInputEnvelope
    set?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    disconnect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    delete?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    update?: TagHierarchyUpdateWithWhereUniqueWithoutChildInput | TagHierarchyUpdateWithWhereUniqueWithoutChildInput[]
    updateMany?: TagHierarchyUpdateManyWithWhereWithoutChildInput | TagHierarchyUpdateManyWithWhereWithoutChildInput[]
    deleteMany?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
  }

  export type TagUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<TagCreateWithoutChildrenInput, TagUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TagCreateOrConnectWithoutChildrenInput
    upsert?: TagUpsertWithoutChildrenInput
    disconnect?: TagWhereInput | boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutChildrenInput, TagUpdateWithoutChildrenInput>, TagUncheckedUpdateWithoutChildrenInput>
  }

  export type TagUpdateManyWithoutParentNestedInput = {
    create?: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput> | TagCreateWithoutParentInput[] | TagUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagCreateOrConnectWithoutParentInput | TagCreateOrConnectWithoutParentInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutParentInput | TagUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TagCreateManyParentInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutParentInput | TagUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TagUpdateManyWithWhereWithoutParentInput | TagUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type TagHierarchyUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput> | TagHierarchyCreateWithoutParentInput[] | TagHierarchyUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutParentInput | TagHierarchyCreateOrConnectWithoutParentInput[]
    upsert?: TagHierarchyUpsertWithWhereUniqueWithoutParentInput | TagHierarchyUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TagHierarchyCreateManyParentInputEnvelope
    set?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    disconnect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    delete?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    update?: TagHierarchyUpdateWithWhereUniqueWithoutParentInput | TagHierarchyUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TagHierarchyUpdateManyWithWhereWithoutParentInput | TagHierarchyUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
  }

  export type TagHierarchyUncheckedUpdateManyWithoutChildNestedInput = {
    create?: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput> | TagHierarchyCreateWithoutChildInput[] | TagHierarchyUncheckedCreateWithoutChildInput[]
    connectOrCreate?: TagHierarchyCreateOrConnectWithoutChildInput | TagHierarchyCreateOrConnectWithoutChildInput[]
    upsert?: TagHierarchyUpsertWithWhereUniqueWithoutChildInput | TagHierarchyUpsertWithWhereUniqueWithoutChildInput[]
    createMany?: TagHierarchyCreateManyChildInputEnvelope
    set?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    disconnect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    delete?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    connect?: TagHierarchyWhereUniqueInput | TagHierarchyWhereUniqueInput[]
    update?: TagHierarchyUpdateWithWhereUniqueWithoutChildInput | TagHierarchyUpdateWithWhereUniqueWithoutChildInput[]
    updateMany?: TagHierarchyUpdateManyWithWhereWithoutChildInput | TagHierarchyUpdateManyWithWhereWithoutChildInput[]
    deleteMany?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput> | TagCreateWithoutParentInput[] | TagUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TagCreateOrConnectWithoutParentInput | TagCreateOrConnectWithoutParentInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutParentInput | TagUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TagCreateManyParentInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutParentInput | TagUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TagUpdateManyWithWhereWithoutParentInput | TagUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TagCreateNestedOneWithoutChildTagInput = {
    create?: XOR<TagCreateWithoutChildTagInput, TagUncheckedCreateWithoutChildTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutChildTagInput
    connect?: TagWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutParentTagInput = {
    create?: XOR<TagCreateWithoutParentTagInput, TagUncheckedCreateWithoutParentTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutParentTagInput
    connect?: TagWhereUniqueInput
  }

  export type TagUpdateOneRequiredWithoutChildTagNestedInput = {
    create?: XOR<TagCreateWithoutChildTagInput, TagUncheckedCreateWithoutChildTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutChildTagInput
    upsert?: TagUpsertWithoutChildTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutChildTagInput, TagUpdateWithoutChildTagInput>, TagUncheckedUpdateWithoutChildTagInput>
  }

  export type TagUpdateOneRequiredWithoutParentTagNestedInput = {
    create?: XOR<TagCreateWithoutParentTagInput, TagUncheckedCreateWithoutParentTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutParentTagInput
    upsert?: TagUpsertWithoutParentTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutParentTagInput, TagUpdateWithoutParentTagInput>, TagUncheckedUpdateWithoutParentTagInput>
  }

  export type UserCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    upsert?: UserUpsertWithoutResourcesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesInput, UserUpdateWithoutResourcesInput>, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type BlockFieldCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput> | BlockFieldCreateWithoutBlockInput[] | BlockFieldUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockFieldCreateOrConnectWithoutBlockInput | BlockFieldCreateOrConnectWithoutBlockInput[]
    createMany?: BlockFieldCreateManyBlockInputEnvelope
    connect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
  }

  export type PostBlockCreateNestedManyWithoutBlockInput = {
    create?: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput> | PostBlockCreateWithoutBlockInput[] | PostBlockUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutBlockInput | PostBlockCreateOrConnectWithoutBlockInput[]
    createMany?: PostBlockCreateManyBlockInputEnvelope
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
  }

  export type BlockFieldUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput> | BlockFieldCreateWithoutBlockInput[] | BlockFieldUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockFieldCreateOrConnectWithoutBlockInput | BlockFieldCreateOrConnectWithoutBlockInput[]
    createMany?: BlockFieldCreateManyBlockInputEnvelope
    connect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
  }

  export type PostBlockUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput> | PostBlockCreateWithoutBlockInput[] | PostBlockUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutBlockInput | PostBlockCreateOrConnectWithoutBlockInput[]
    createMany?: PostBlockCreateManyBlockInputEnvelope
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
  }

  export type BlockFieldUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput> | BlockFieldCreateWithoutBlockInput[] | BlockFieldUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockFieldCreateOrConnectWithoutBlockInput | BlockFieldCreateOrConnectWithoutBlockInput[]
    upsert?: BlockFieldUpsertWithWhereUniqueWithoutBlockInput | BlockFieldUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockFieldCreateManyBlockInputEnvelope
    set?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    disconnect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    delete?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    connect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    update?: BlockFieldUpdateWithWhereUniqueWithoutBlockInput | BlockFieldUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockFieldUpdateManyWithWhereWithoutBlockInput | BlockFieldUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockFieldScalarWhereInput | BlockFieldScalarWhereInput[]
  }

  export type PostBlockUpdateManyWithoutBlockNestedInput = {
    create?: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput> | PostBlockCreateWithoutBlockInput[] | PostBlockUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutBlockInput | PostBlockCreateOrConnectWithoutBlockInput[]
    upsert?: PostBlockUpsertWithWhereUniqueWithoutBlockInput | PostBlockUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: PostBlockCreateManyBlockInputEnvelope
    set?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    disconnect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    delete?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    update?: PostBlockUpdateWithWhereUniqueWithoutBlockInput | PostBlockUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: PostBlockUpdateManyWithWhereWithoutBlockInput | PostBlockUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
  }

  export type BlockFieldUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput> | BlockFieldCreateWithoutBlockInput[] | BlockFieldUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: BlockFieldCreateOrConnectWithoutBlockInput | BlockFieldCreateOrConnectWithoutBlockInput[]
    upsert?: BlockFieldUpsertWithWhereUniqueWithoutBlockInput | BlockFieldUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: BlockFieldCreateManyBlockInputEnvelope
    set?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    disconnect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    delete?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    connect?: BlockFieldWhereUniqueInput | BlockFieldWhereUniqueInput[]
    update?: BlockFieldUpdateWithWhereUniqueWithoutBlockInput | BlockFieldUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: BlockFieldUpdateManyWithWhereWithoutBlockInput | BlockFieldUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: BlockFieldScalarWhereInput | BlockFieldScalarWhereInput[]
  }

  export type PostBlockUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput> | PostBlockCreateWithoutBlockInput[] | PostBlockUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: PostBlockCreateOrConnectWithoutBlockInput | PostBlockCreateOrConnectWithoutBlockInput[]
    upsert?: PostBlockUpsertWithWhereUniqueWithoutBlockInput | PostBlockUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: PostBlockCreateManyBlockInputEnvelope
    set?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    disconnect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    delete?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    connect?: PostBlockWhereUniqueInput | PostBlockWhereUniqueInput[]
    update?: PostBlockUpdateWithWhereUniqueWithoutBlockInput | PostBlockUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: PostBlockUpdateManyWithWhereWithoutBlockInput | PostBlockUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
  }

  export type BlockCreateNestedOneWithoutBlockFieldInput = {
    create?: XOR<BlockCreateWithoutBlockFieldInput, BlockUncheckedCreateWithoutBlockFieldInput>
    connectOrCreate?: BlockCreateOrConnectWithoutBlockFieldInput
    connect?: BlockWhereUniqueInput
  }

  export type BlockUpdateOneRequiredWithoutBlockFieldNestedInput = {
    create?: XOR<BlockCreateWithoutBlockFieldInput, BlockUncheckedCreateWithoutBlockFieldInput>
    connectOrCreate?: BlockCreateOrConnectWithoutBlockFieldInput
    upsert?: BlockUpsertWithoutBlockFieldInput
    connect?: BlockWhereUniqueInput
    update?: XOR<XOR<BlockUpdateToOneWithWhereWithoutBlockFieldInput, BlockUpdateWithoutBlockFieldInput>, BlockUncheckedUpdateWithoutBlockFieldInput>
  }

  export type BlockCreateNestedOneWithoutPostBlockInput = {
    create?: XOR<BlockCreateWithoutPostBlockInput, BlockUncheckedCreateWithoutPostBlockInput>
    connectOrCreate?: BlockCreateOrConnectWithoutPostBlockInput
    connect?: BlockWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPostBlockInput = {
    create?: XOR<PostCreateWithoutPostBlockInput, PostUncheckedCreateWithoutPostBlockInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostBlockInput
    connect?: PostWhereUniqueInput
  }

  export type BlockUpdateOneRequiredWithoutPostBlockNestedInput = {
    create?: XOR<BlockCreateWithoutPostBlockInput, BlockUncheckedCreateWithoutPostBlockInput>
    connectOrCreate?: BlockCreateOrConnectWithoutPostBlockInput
    upsert?: BlockUpsertWithoutPostBlockInput
    connect?: BlockWhereUniqueInput
    update?: XOR<XOR<BlockUpdateToOneWithWhereWithoutPostBlockInput, BlockUpdateWithoutPostBlockInput>, BlockUncheckedUpdateWithoutPostBlockInput>
  }

  export type PostUpdateOneRequiredWithoutPostBlockNestedInput = {
    create?: XOR<PostCreateWithoutPostBlockInput, PostUncheckedCreateWithoutPostBlockInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostBlockInput
    upsert?: PostUpsertWithoutPostBlockInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostBlockInput, PostUpdateWithoutPostBlockInput>, PostUncheckedUpdateWithoutPostBlockInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type PostVersionHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput> | PostVersionHistoryCreateWithoutUserInput[] | PostVersionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutUserInput | PostVersionHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PostVersionHistoryCreateManyUserInputEnvelope
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRolesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput> | UserRolesCreateWithoutUserInput[] | UserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutUserInput | UserRolesCreateOrConnectWithoutUserInput[]
    createMany?: UserRolesCreateManyUserInputEnvelope
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
  }

  export type UserSocialCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput> | UserSocialCreateWithoutUserInput[] | UserSocialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutUserInput | UserSocialCreateOrConnectWithoutUserInput[]
    createMany?: UserSocialCreateManyUserInputEnvelope
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutCMS_UserInput = {
    create?: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput> | PathwayCreateWithoutCMS_UserInput[] | PathwayUncheckedCreateWithoutCMS_UserInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCMS_UserInput | PathwayCreateOrConnectWithoutCMS_UserInput[]
    createMany?: PathwayCreateManyCMS_UserInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ContentResourceCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput> | ContentResourceCreateWithoutAuthorInput[] | ContentResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAuthorInput | ContentResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ContentResourceCreateManyAuthorInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput> | PostVersionHistoryCreateWithoutUserInput[] | PostVersionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutUserInput | PostVersionHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PostVersionHistoryCreateManyUserInputEnvelope
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRolesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput> | UserRolesCreateWithoutUserInput[] | UserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutUserInput | UserRolesCreateOrConnectWithoutUserInput[]
    createMany?: UserRolesCreateManyUserInputEnvelope
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
  }

  export type UserSocialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput> | UserSocialCreateWithoutUserInput[] | UserSocialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutUserInput | UserSocialCreateOrConnectWithoutUserInput[]
    createMany?: UserSocialCreateManyUserInputEnvelope
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutCMS_UserInput = {
    create?: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput> | PathwayCreateWithoutCMS_UserInput[] | PathwayUncheckedCreateWithoutCMS_UserInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCMS_UserInput | PathwayCreateOrConnectWithoutCMS_UserInput[]
    createMany?: PathwayCreateManyCMS_UserInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ContentResourceUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput> | ContentResourceCreateWithoutAuthorInput[] | ContentResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAuthorInput | ContentResourceCreateOrConnectWithoutAuthorInput[]
    createMany?: ContentResourceCreateManyAuthorInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PostVersionHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput> | PostVersionHistoryCreateWithoutUserInput[] | PostVersionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutUserInput | PostVersionHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PostVersionHistoryUpsertWithWhereUniqueWithoutUserInput | PostVersionHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostVersionHistoryCreateManyUserInputEnvelope
    set?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    disconnect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    delete?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    update?: PostVersionHistoryUpdateWithWhereUniqueWithoutUserInput | PostVersionHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostVersionHistoryUpdateManyWithWhereWithoutUserInput | PostVersionHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRolesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput> | UserRolesCreateWithoutUserInput[] | UserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutUserInput | UserRolesCreateOrConnectWithoutUserInput[]
    upsert?: UserRolesUpsertWithWhereUniqueWithoutUserInput | UserRolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRolesCreateManyUserInputEnvelope
    set?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    disconnect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    delete?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    update?: UserRolesUpdateWithWhereUniqueWithoutUserInput | UserRolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRolesUpdateManyWithWhereWithoutUserInput | UserRolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
  }

  export type UserSocialUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput> | UserSocialCreateWithoutUserInput[] | UserSocialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutUserInput | UserSocialCreateOrConnectWithoutUserInput[]
    upsert?: UserSocialUpsertWithWhereUniqueWithoutUserInput | UserSocialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSocialCreateManyUserInputEnvelope
    set?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    disconnect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    delete?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    update?: UserSocialUpdateWithWhereUniqueWithoutUserInput | UserSocialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSocialUpdateManyWithWhereWithoutUserInput | UserSocialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutCMS_UserNestedInput = {
    create?: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput> | PathwayCreateWithoutCMS_UserInput[] | PathwayUncheckedCreateWithoutCMS_UserInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCMS_UserInput | PathwayCreateOrConnectWithoutCMS_UserInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCMS_UserInput | PathwayUpsertWithWhereUniqueWithoutCMS_UserInput[]
    createMany?: PathwayCreateManyCMS_UserInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCMS_UserInput | PathwayUpdateWithWhereUniqueWithoutCMS_UserInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCMS_UserInput | PathwayUpdateManyWithWhereWithoutCMS_UserInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutAuthorInput | ResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutAuthorInput | ResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutAuthorInput | ResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ContentResourceUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput> | ContentResourceCreateWithoutAuthorInput[] | ContentResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAuthorInput | ContentResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutAuthorInput | ContentResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ContentResourceCreateManyAuthorInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutAuthorInput | ContentResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutAuthorInput | ContentResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput> | PostVersionHistoryCreateWithoutUserInput[] | PostVersionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVersionHistoryCreateOrConnectWithoutUserInput | PostVersionHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PostVersionHistoryUpsertWithWhereUniqueWithoutUserInput | PostVersionHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostVersionHistoryCreateManyUserInputEnvelope
    set?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    disconnect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    delete?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    connect?: PostVersionHistoryWhereUniqueInput | PostVersionHistoryWhereUniqueInput[]
    update?: PostVersionHistoryUpdateWithWhereUniqueWithoutUserInput | PostVersionHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostVersionHistoryUpdateManyWithWhereWithoutUserInput | PostVersionHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRolesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput> | UserRolesCreateWithoutUserInput[] | UserRolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutUserInput | UserRolesCreateOrConnectWithoutUserInput[]
    upsert?: UserRolesUpsertWithWhereUniqueWithoutUserInput | UserRolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRolesCreateManyUserInputEnvelope
    set?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    disconnect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    delete?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    update?: UserRolesUpdateWithWhereUniqueWithoutUserInput | UserRolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRolesUpdateManyWithWhereWithoutUserInput | UserRolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
  }

  export type UserSocialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput> | UserSocialCreateWithoutUserInput[] | UserSocialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutUserInput | UserSocialCreateOrConnectWithoutUserInput[]
    upsert?: UserSocialUpsertWithWhereUniqueWithoutUserInput | UserSocialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSocialCreateManyUserInputEnvelope
    set?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    disconnect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    delete?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    update?: UserSocialUpdateWithWhereUniqueWithoutUserInput | UserSocialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSocialUpdateManyWithWhereWithoutUserInput | UserSocialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput = {
    create?: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput> | PathwayCreateWithoutCMS_UserInput[] | PathwayUncheckedCreateWithoutCMS_UserInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutCMS_UserInput | PathwayCreateOrConnectWithoutCMS_UserInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutCMS_UserInput | PathwayUpsertWithWhereUniqueWithoutCMS_UserInput[]
    createMany?: PathwayCreateManyCMS_UserInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutCMS_UserInput | PathwayUpdateWithWhereUniqueWithoutCMS_UserInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutCMS_UserInput | PathwayUpdateManyWithWhereWithoutCMS_UserInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput> | ResourceCreateWithoutAuthorInput[] | ResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutAuthorInput | ResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutAuthorInput | ResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ResourceCreateManyAuthorInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutAuthorInput | ResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutAuthorInput | ResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput> | ContentResourceCreateWithoutAuthorInput[] | ContentResourceUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAuthorInput | ContentResourceCreateOrConnectWithoutAuthorInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutAuthorInput | ContentResourceUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ContentResourceCreateManyAuthorInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutAuthorInput | ContentResourceUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutAuthorInput | ContentResourceUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type SocialCreateNestedOneWithoutUsersInput = {
    create?: XOR<SocialCreateWithoutUsersInput, SocialUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocialCreateOrConnectWithoutUsersInput
    connect?: SocialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSocialsInput = {
    create?: XOR<UserCreateWithoutSocialsInput, UserUncheckedCreateWithoutSocialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialsInput
    connect?: UserWhereUniqueInput
  }

  export type SocialUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SocialCreateWithoutUsersInput, SocialUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SocialCreateOrConnectWithoutUsersInput
    upsert?: SocialUpsertWithoutUsersInput
    connect?: SocialWhereUniqueInput
    update?: XOR<XOR<SocialUpdateToOneWithWhereWithoutUsersInput, SocialUpdateWithoutUsersInput>, SocialUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutSocialsNestedInput = {
    create?: XOR<UserCreateWithoutSocialsInput, UserUncheckedCreateWithoutSocialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialsInput
    upsert?: UserUpsertWithoutSocialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialsInput, UserUpdateWithoutSocialsInput>, UserUncheckedUpdateWithoutSocialsInput>
  }

  export type RolesCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserRolesInput
    connect?: RolesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RolesUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserRolesInput
    upsert?: RolesUpsertWithoutUserRolesInput
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUserRolesInput, RolesUpdateWithoutUserRolesInput>, RolesUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserRolesCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput> | UserRolesCreateWithoutRoleInput[] | UserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutRoleInput | UserRolesCreateOrConnectWithoutRoleInput[]
    createMany?: UserRolesCreateManyRoleInputEnvelope
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
  }

  export type UserRolesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput> | UserRolesCreateWithoutRoleInput[] | UserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutRoleInput | UserRolesCreateOrConnectWithoutRoleInput[]
    createMany?: UserRolesCreateManyRoleInputEnvelope
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
  }

  export type UserRolesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput> | UserRolesCreateWithoutRoleInput[] | UserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutRoleInput | UserRolesCreateOrConnectWithoutRoleInput[]
    upsert?: UserRolesUpsertWithWhereUniqueWithoutRoleInput | UserRolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRolesCreateManyRoleInputEnvelope
    set?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    disconnect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    delete?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    update?: UserRolesUpdateWithWhereUniqueWithoutRoleInput | UserRolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRolesUpdateManyWithWhereWithoutRoleInput | UserRolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
  }

  export type UserRolesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput> | UserRolesCreateWithoutRoleInput[] | UserRolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRolesCreateOrConnectWithoutRoleInput | UserRolesCreateOrConnectWithoutRoleInput[]
    upsert?: UserRolesUpsertWithWhereUniqueWithoutRoleInput | UserRolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRolesCreateManyRoleInputEnvelope
    set?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    disconnect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    delete?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    connect?: UserRolesWhereUniqueInput | UserRolesWhereUniqueInput[]
    update?: UserRolesUpdateWithWhereUniqueWithoutRoleInput | UserRolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRolesUpdateManyWithWhereWithoutRoleInput | UserRolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
  }

  export type UserSocialCreateNestedManyWithoutSocialInput = {
    create?: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput> | UserSocialCreateWithoutSocialInput[] | UserSocialUncheckedCreateWithoutSocialInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutSocialInput | UserSocialCreateOrConnectWithoutSocialInput[]
    createMany?: UserSocialCreateManySocialInputEnvelope
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
  }

  export type UserSocialUncheckedCreateNestedManyWithoutSocialInput = {
    create?: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput> | UserSocialCreateWithoutSocialInput[] | UserSocialUncheckedCreateWithoutSocialInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutSocialInput | UserSocialCreateOrConnectWithoutSocialInput[]
    createMany?: UserSocialCreateManySocialInputEnvelope
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
  }

  export type UserSocialUpdateManyWithoutSocialNestedInput = {
    create?: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput> | UserSocialCreateWithoutSocialInput[] | UserSocialUncheckedCreateWithoutSocialInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutSocialInput | UserSocialCreateOrConnectWithoutSocialInput[]
    upsert?: UserSocialUpsertWithWhereUniqueWithoutSocialInput | UserSocialUpsertWithWhereUniqueWithoutSocialInput[]
    createMany?: UserSocialCreateManySocialInputEnvelope
    set?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    disconnect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    delete?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    update?: UserSocialUpdateWithWhereUniqueWithoutSocialInput | UserSocialUpdateWithWhereUniqueWithoutSocialInput[]
    updateMany?: UserSocialUpdateManyWithWhereWithoutSocialInput | UserSocialUpdateManyWithWhereWithoutSocialInput[]
    deleteMany?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
  }

  export type UserSocialUncheckedUpdateManyWithoutSocialNestedInput = {
    create?: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput> | UserSocialCreateWithoutSocialInput[] | UserSocialUncheckedCreateWithoutSocialInput[]
    connectOrCreate?: UserSocialCreateOrConnectWithoutSocialInput | UserSocialCreateOrConnectWithoutSocialInput[]
    upsert?: UserSocialUpsertWithWhereUniqueWithoutSocialInput | UserSocialUpsertWithWhereUniqueWithoutSocialInput[]
    createMany?: UserSocialCreateManySocialInputEnvelope
    set?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    disconnect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    delete?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    connect?: UserSocialWhereUniqueInput | UserSocialWhereUniqueInput[]
    update?: UserSocialUpdateWithWhereUniqueWithoutSocialInput | UserSocialUpdateWithWhereUniqueWithoutSocialInput[]
    updateMany?: UserSocialUpdateManyWithWhereWithoutSocialInput | UserSocialUpdateManyWithWhereWithoutSocialInput[]
    deleteMany?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutPostVersionHistoriesInput = {
    create?: XOR<PostCreateWithoutPostVersionHistoriesInput, PostUncheckedCreateWithoutPostVersionHistoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostVersionHistoriesInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostVersionHistoryInput = {
    create?: XOR<UserCreateWithoutPostVersionHistoryInput, UserUncheckedCreateWithoutPostVersionHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostVersionHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPostVersionHistoriesNestedInput = {
    create?: XOR<PostCreateWithoutPostVersionHistoriesInput, PostUncheckedCreateWithoutPostVersionHistoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostVersionHistoriesInput
    upsert?: PostUpsertWithoutPostVersionHistoriesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostVersionHistoriesInput, PostUpdateWithoutPostVersionHistoriesInput>, PostUncheckedUpdateWithoutPostVersionHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutPostVersionHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPostVersionHistoryInput, UserUncheckedCreateWithoutPostVersionHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostVersionHistoryInput
    upsert?: UserUpsertWithoutPostVersionHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostVersionHistoryInput, UserUpdateWithoutPostVersionHistoryInput>, UserUncheckedUpdateWithoutPostVersionHistoryInput>
  }

  export type PathwayCategoriesCreateNestedManyWithoutPathway_categoriesInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput> | PathwayCategoriesCreateWithoutPathway_categoriesInput[] | PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput | PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput[]
    createMany?: PathwayCategoriesCreateManyPathway_categoriesInputEnvelope
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
  }

  export type PathwayTypesCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PathwayTypesCreateWithoutChildrenInput, PathwayTypesUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutChildrenInput
    connect?: PathwayTypesWhereUniqueInput
  }

  export type PathwayTypesCreateNestedManyWithoutParentInput = {
    create?: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput> | PathwayTypesCreateWithoutParentInput[] | PathwayTypesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutParentInput | PathwayTypesCreateOrConnectWithoutParentInput[]
    createMany?: PathwayTypesCreateManyParentInputEnvelope
    connect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
  }

  export type PathwayCategoriesUncheckedCreateNestedManyWithoutPathway_categoriesInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput> | PathwayCategoriesCreateWithoutPathway_categoriesInput[] | PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput | PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput[]
    createMany?: PathwayCategoriesCreateManyPathway_categoriesInputEnvelope
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
  }

  export type PathwayTypesUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput> | PathwayTypesCreateWithoutParentInput[] | PathwayTypesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutParentInput | PathwayTypesCreateOrConnectWithoutParentInput[]
    createMany?: PathwayTypesCreateManyParentInputEnvelope
    connect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
  }

  export type PathwayCategoriesUpdateManyWithoutPathway_categoriesNestedInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput> | PathwayCategoriesCreateWithoutPathway_categoriesInput[] | PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput | PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput[]
    upsert?: PathwayCategoriesUpsertWithWhereUniqueWithoutPathway_categoriesInput | PathwayCategoriesUpsertWithWhereUniqueWithoutPathway_categoriesInput[]
    createMany?: PathwayCategoriesCreateManyPathway_categoriesInputEnvelope
    set?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    disconnect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    delete?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    update?: PathwayCategoriesUpdateWithWhereUniqueWithoutPathway_categoriesInput | PathwayCategoriesUpdateWithWhereUniqueWithoutPathway_categoriesInput[]
    updateMany?: PathwayCategoriesUpdateManyWithWhereWithoutPathway_categoriesInput | PathwayCategoriesUpdateManyWithWhereWithoutPathway_categoriesInput[]
    deleteMany?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
  }

  export type PathwayTypesUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PathwayTypesCreateWithoutChildrenInput, PathwayTypesUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutChildrenInput
    upsert?: PathwayTypesUpsertWithoutChildrenInput
    disconnect?: PathwayTypesWhereInput | boolean
    delete?: PathwayTypesWhereInput | boolean
    connect?: PathwayTypesWhereUniqueInput
    update?: XOR<XOR<PathwayTypesUpdateToOneWithWhereWithoutChildrenInput, PathwayTypesUpdateWithoutChildrenInput>, PathwayTypesUncheckedUpdateWithoutChildrenInput>
  }

  export type PathwayTypesUpdateManyWithoutParentNestedInput = {
    create?: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput> | PathwayTypesCreateWithoutParentInput[] | PathwayTypesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutParentInput | PathwayTypesCreateOrConnectWithoutParentInput[]
    upsert?: PathwayTypesUpsertWithWhereUniqueWithoutParentInput | PathwayTypesUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PathwayTypesCreateManyParentInputEnvelope
    set?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    disconnect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    delete?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    connect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    update?: PathwayTypesUpdateWithWhereUniqueWithoutParentInput | PathwayTypesUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PathwayTypesUpdateManyWithWhereWithoutParentInput | PathwayTypesUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PathwayTypesScalarWhereInput | PathwayTypesScalarWhereInput[]
  }

  export type PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesNestedInput = {
    create?: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput> | PathwayCategoriesCreateWithoutPathway_categoriesInput[] | PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput[]
    connectOrCreate?: PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput | PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput[]
    upsert?: PathwayCategoriesUpsertWithWhereUniqueWithoutPathway_categoriesInput | PathwayCategoriesUpsertWithWhereUniqueWithoutPathway_categoriesInput[]
    createMany?: PathwayCategoriesCreateManyPathway_categoriesInputEnvelope
    set?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    disconnect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    delete?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    connect?: PathwayCategoriesWhereUniqueInput | PathwayCategoriesWhereUniqueInput[]
    update?: PathwayCategoriesUpdateWithWhereUniqueWithoutPathway_categoriesInput | PathwayCategoriesUpdateWithWhereUniqueWithoutPathway_categoriesInput[]
    updateMany?: PathwayCategoriesUpdateManyWithWhereWithoutPathway_categoriesInput | PathwayCategoriesUpdateManyWithWhereWithoutPathway_categoriesInput[]
    deleteMany?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
  }

  export type PathwayTypesUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput> | PathwayTypesCreateWithoutParentInput[] | PathwayTypesUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutParentInput | PathwayTypesCreateOrConnectWithoutParentInput[]
    upsert?: PathwayTypesUpsertWithWhereUniqueWithoutParentInput | PathwayTypesUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PathwayTypesCreateManyParentInputEnvelope
    set?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    disconnect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    delete?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    connect?: PathwayTypesWhereUniqueInput | PathwayTypesWhereUniqueInput[]
    update?: PathwayTypesUpdateWithWhereUniqueWithoutParentInput | PathwayTypesUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PathwayTypesUpdateManyWithWhereWithoutParentInput | PathwayTypesUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PathwayTypesScalarWhereInput | PathwayTypesScalarWhereInput[]
  }

  export type PathwayCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<PathwayCreateWithoutCategoriesInput, PathwayUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutCategoriesInput
    connect?: PathwayWhereUniqueInput
  }

  export type PathwayTypesCreateNestedOneWithoutPathwayCategoriesInput = {
    create?: XOR<PathwayTypesCreateWithoutPathwayCategoriesInput, PathwayTypesUncheckedCreateWithoutPathwayCategoriesInput>
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutPathwayCategoriesInput
    connect?: PathwayTypesWhereUniqueInput
  }

  export type PathwayUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<PathwayCreateWithoutCategoriesInput, PathwayUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: PathwayCreateOrConnectWithoutCategoriesInput
    upsert?: PathwayUpsertWithoutCategoriesInput
    connect?: PathwayWhereUniqueInput
    update?: XOR<XOR<PathwayUpdateToOneWithWhereWithoutCategoriesInput, PathwayUpdateWithoutCategoriesInput>, PathwayUncheckedUpdateWithoutCategoriesInput>
  }

  export type PathwayTypesUpdateOneRequiredWithoutPathwayCategoriesNestedInput = {
    create?: XOR<PathwayTypesCreateWithoutPathwayCategoriesInput, PathwayTypesUncheckedCreateWithoutPathwayCategoriesInput>
    connectOrCreate?: PathwayTypesCreateOrConnectWithoutPathwayCategoriesInput
    upsert?: PathwayTypesUpsertWithoutPathwayCategoriesInput
    connect?: PathwayTypesWhereUniqueInput
    update?: XOR<XOR<PathwayTypesUpdateToOneWithWhereWithoutPathwayCategoriesInput, PathwayTypesUpdateWithoutPathwayCategoriesInput>, PathwayTypesUncheckedUpdateWithoutPathwayCategoriesInput>
  }

  export type ContentResourceCreateNestedManyWithoutTypeInput = {
    create?: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput> | ContentResourceCreateWithoutTypeInput[] | ContentResourceUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutTypeInput | ContentResourceCreateOrConnectWithoutTypeInput[]
    createMany?: ContentResourceCreateManyTypeInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type ContentResourceUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput> | ContentResourceCreateWithoutTypeInput[] | ContentResourceUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutTypeInput | ContentResourceCreateOrConnectWithoutTypeInput[]
    createMany?: ContentResourceCreateManyTypeInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type ContentResourceUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput> | ContentResourceCreateWithoutTypeInput[] | ContentResourceUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutTypeInput | ContentResourceCreateOrConnectWithoutTypeInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutTypeInput | ContentResourceUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ContentResourceCreateManyTypeInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutTypeInput | ContentResourceUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutTypeInput | ContentResourceUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type ContentResourceUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput> | ContentResourceCreateWithoutTypeInput[] | ContentResourceUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutTypeInput | ContentResourceCreateOrConnectWithoutTypeInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutTypeInput | ContentResourceUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ContentResourceCreateManyTypeInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutTypeInput | ContentResourceUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutTypeInput | ContentResourceUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type ContentResourceCreateNestedManyWithoutAreaInput = {
    create?: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput> | ContentResourceCreateWithoutAreaInput[] | ContentResourceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAreaInput | ContentResourceCreateOrConnectWithoutAreaInput[]
    createMany?: ContentResourceCreateManyAreaInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type ContentResourceUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput> | ContentResourceCreateWithoutAreaInput[] | ContentResourceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAreaInput | ContentResourceCreateOrConnectWithoutAreaInput[]
    createMany?: ContentResourceCreateManyAreaInputEnvelope
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
  }

  export type ContentResourceUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput> | ContentResourceCreateWithoutAreaInput[] | ContentResourceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAreaInput | ContentResourceCreateOrConnectWithoutAreaInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutAreaInput | ContentResourceUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ContentResourceCreateManyAreaInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutAreaInput | ContentResourceUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutAreaInput | ContentResourceUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type ContentResourceUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput> | ContentResourceCreateWithoutAreaInput[] | ContentResourceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ContentResourceCreateOrConnectWithoutAreaInput | ContentResourceCreateOrConnectWithoutAreaInput[]
    upsert?: ContentResourceUpsertWithWhereUniqueWithoutAreaInput | ContentResourceUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ContentResourceCreateManyAreaInputEnvelope
    set?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    disconnect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    delete?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    connect?: ContentResourceWhereUniqueInput | ContentResourceWhereUniqueInput[]
    update?: ContentResourceUpdateWithWhereUniqueWithoutAreaInput | ContentResourceUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ContentResourceUpdateManyWithWhereWithoutAreaInput | ContentResourceUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
  }

  export type ContentResourceAreaCreateNestedOneWithoutContentResourcesInput = {
    create?: XOR<ContentResourceAreaCreateWithoutContentResourcesInput, ContentResourceAreaUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: ContentResourceAreaCreateOrConnectWithoutContentResourcesInput
    connect?: ContentResourceAreaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContentResourcesInput = {
    create?: XOR<UserCreateWithoutContentResourcesInput, UserUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type ContentResourceTypeCreateNestedOneWithoutContentResourcesInput = {
    create?: XOR<ContentResourceTypeCreateWithoutContentResourcesInput, ContentResourceTypeUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: ContentResourceTypeCreateOrConnectWithoutContentResourcesInput
    connect?: ContentResourceTypeWhereUniqueInput
  }

  export type ContentResourceAreaUpdateOneRequiredWithoutContentResourcesNestedInput = {
    create?: XOR<ContentResourceAreaCreateWithoutContentResourcesInput, ContentResourceAreaUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: ContentResourceAreaCreateOrConnectWithoutContentResourcesInput
    upsert?: ContentResourceAreaUpsertWithoutContentResourcesInput
    connect?: ContentResourceAreaWhereUniqueInput
    update?: XOR<XOR<ContentResourceAreaUpdateToOneWithWhereWithoutContentResourcesInput, ContentResourceAreaUpdateWithoutContentResourcesInput>, ContentResourceAreaUncheckedUpdateWithoutContentResourcesInput>
  }

  export type UserUpdateOneWithoutContentResourcesNestedInput = {
    create?: XOR<UserCreateWithoutContentResourcesInput, UserUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentResourcesInput
    upsert?: UserUpsertWithoutContentResourcesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContentResourcesInput, UserUpdateWithoutContentResourcesInput>, UserUncheckedUpdateWithoutContentResourcesInput>
  }

  export type ContentResourceTypeUpdateOneRequiredWithoutContentResourcesNestedInput = {
    create?: XOR<ContentResourceTypeCreateWithoutContentResourcesInput, ContentResourceTypeUncheckedCreateWithoutContentResourcesInput>
    connectOrCreate?: ContentResourceTypeCreateOrConnectWithoutContentResourcesInput
    upsert?: ContentResourceTypeUpsertWithoutContentResourcesInput
    connect?: ContentResourceTypeWhereUniqueInput
    update?: XOR<XOR<ContentResourceTypeUpdateToOneWithWhereWithoutContentResourcesInput, ContentResourceTypeUpdateWithoutContentResourcesInput>, ContentResourceTypeUncheckedUpdateWithoutContentResourcesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumPathwayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayType | EnumPathwayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayTypeFilter<$PrismaModel> | $Enums.PathwayType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPathwayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayType | EnumPathwayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayType[] | ListEnumPathwayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayTypeWithAggregatesFilter<$PrismaModel> | $Enums.PathwayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPathwayTypeFilter<$PrismaModel>
    _max?: NestedEnumPathwayTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPathwayPipelinesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayPipelines | EnumPathwayPipelinesFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayPipelinesFilter<$PrismaModel> | $Enums.PathwayPipelines
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPathwayPipelinesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PathwayPipelines | EnumPathwayPipelinesFieldRefInput<$PrismaModel>
    in?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    notIn?: $Enums.PathwayPipelines[] | ListEnumPathwayPipelinesFieldRefInput<$PrismaModel>
    not?: NestedEnumPathwayPipelinesWithAggregatesFilter<$PrismaModel> | $Enums.PathwayPipelines
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPathwayPipelinesFilter<$PrismaModel>
    _max?: NestedEnumPathwayPipelinesFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CountryCurrencyCreateWithoutCountryInput = {
    currency: CurrencyCreateNestedOneWithoutCountryCurrenciesInput
  }

  export type CountryCurrencyUncheckedCreateWithoutCountryInput = {
    currencyCode: string
  }

  export type CountryCurrencyCreateOrConnectWithoutCountryInput = {
    where: CountryCurrencyWhereUniqueInput
    create: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput>
  }

  export type CountryCurrencyCreateManyCountryInputEnvelope = {
    data: CountryCurrencyCreateManyCountryInput | CountryCurrencyCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CountryLanguageCreateWithoutCountryInput = {
    language: LanguageCreateNestedOneWithoutCountryLanguagesInput
  }

  export type CountryLanguageUncheckedCreateWithoutCountryInput = {
    languageCode: string
  }

  export type CountryLanguageCreateOrConnectWithoutCountryInput = {
    where: CountryLanguageWhereUniqueInput
    create: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput>
  }

  export type CountryLanguageCreateManyCountryInputEnvelope = {
    data: CountryLanguageCreateManyCountryInput | CountryLanguageCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type PathwayRestrictedNationalityCreateWithoutCountryInput = {
    note?: string | null
    pathway: PathwayCreateNestedOneWithoutRestrictedNationalitiesInput
  }

  export type PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput = {
    pathwayId: number
    note?: string | null
  }

  export type PathwayRestrictedNationalityCreateOrConnectWithoutCountryInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    create: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput>
  }

  export type PathwayRestrictedNationalityCreateManyCountryInputEnvelope = {
    data: PathwayRestrictedNationalityCreateManyCountryInput | PathwayRestrictedNationalityCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutCountryInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutCountryInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput>
  }

  export type PathwayCreateManyCountryInputEnvelope = {
    data: PathwayCreateManyCountryInput | PathwayCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CountryCurrencyUpsertWithWhereUniqueWithoutCountryInput = {
    where: CountryCurrencyWhereUniqueInput
    update: XOR<CountryCurrencyUpdateWithoutCountryInput, CountryCurrencyUncheckedUpdateWithoutCountryInput>
    create: XOR<CountryCurrencyCreateWithoutCountryInput, CountryCurrencyUncheckedCreateWithoutCountryInput>
  }

  export type CountryCurrencyUpdateWithWhereUniqueWithoutCountryInput = {
    where: CountryCurrencyWhereUniqueInput
    data: XOR<CountryCurrencyUpdateWithoutCountryInput, CountryCurrencyUncheckedUpdateWithoutCountryInput>
  }

  export type CountryCurrencyUpdateManyWithWhereWithoutCountryInput = {
    where: CountryCurrencyScalarWhereInput
    data: XOR<CountryCurrencyUpdateManyMutationInput, CountryCurrencyUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryCurrencyScalarWhereInput = {
    AND?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
    OR?: CountryCurrencyScalarWhereInput[]
    NOT?: CountryCurrencyScalarWhereInput | CountryCurrencyScalarWhereInput[]
    countryCode?: StringFilter<"CountryCurrency"> | string
    currencyCode?: StringFilter<"CountryCurrency"> | string
  }

  export type CountryLanguageUpsertWithWhereUniqueWithoutCountryInput = {
    where: CountryLanguageWhereUniqueInput
    update: XOR<CountryLanguageUpdateWithoutCountryInput, CountryLanguageUncheckedUpdateWithoutCountryInput>
    create: XOR<CountryLanguageCreateWithoutCountryInput, CountryLanguageUncheckedCreateWithoutCountryInput>
  }

  export type CountryLanguageUpdateWithWhereUniqueWithoutCountryInput = {
    where: CountryLanguageWhereUniqueInput
    data: XOR<CountryLanguageUpdateWithoutCountryInput, CountryLanguageUncheckedUpdateWithoutCountryInput>
  }

  export type CountryLanguageUpdateManyWithWhereWithoutCountryInput = {
    where: CountryLanguageScalarWhereInput
    data: XOR<CountryLanguageUpdateManyMutationInput, CountryLanguageUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryLanguageScalarWhereInput = {
    AND?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
    OR?: CountryLanguageScalarWhereInput[]
    NOT?: CountryLanguageScalarWhereInput | CountryLanguageScalarWhereInput[]
    countryCode?: StringFilter<"CountryLanguage"> | string
    languageCode?: StringFilter<"CountryLanguage"> | string
  }

  export type PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutCountryInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    update: XOR<PathwayRestrictedNationalityUpdateWithoutCountryInput, PathwayRestrictedNationalityUncheckedUpdateWithoutCountryInput>
    create: XOR<PathwayRestrictedNationalityCreateWithoutCountryInput, PathwayRestrictedNationalityUncheckedCreateWithoutCountryInput>
  }

  export type PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutCountryInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    data: XOR<PathwayRestrictedNationalityUpdateWithoutCountryInput, PathwayRestrictedNationalityUncheckedUpdateWithoutCountryInput>
  }

  export type PathwayRestrictedNationalityUpdateManyWithWhereWithoutCountryInput = {
    where: PathwayRestrictedNationalityScalarWhereInput
    data: XOR<PathwayRestrictedNationalityUpdateManyMutationInput, PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryInput>
  }

  export type PathwayRestrictedNationalityScalarWhereInput = {
    AND?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
    OR?: PathwayRestrictedNationalityScalarWhereInput[]
    NOT?: PathwayRestrictedNationalityScalarWhereInput | PathwayRestrictedNationalityScalarWhereInput[]
    pathwayId?: IntFilter<"PathwayRestrictedNationality"> | number
    countryCode?: StringFilter<"PathwayRestrictedNationality"> | string
    note?: StringNullableFilter<"PathwayRestrictedNationality"> | string | null
  }

  export type PathwayUpsertWithWhereUniqueWithoutCountryInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutCountryInput, PathwayUncheckedUpdateWithoutCountryInput>
    create: XOR<PathwayCreateWithoutCountryInput, PathwayUncheckedCreateWithoutCountryInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutCountryInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutCountryInput, PathwayUncheckedUpdateWithoutCountryInput>
  }

  export type PathwayUpdateManyWithWhereWithoutCountryInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutCountryInput>
  }

  export type PathwayScalarWhereInput = {
    AND?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
    OR?: PathwayScalarWhereInput[]
    NOT?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
    id?: IntFilter<"Pathway"> | number
    countryCode?: StringFilter<"Pathway"> | string
    name?: StringFilter<"Pathway"> | string
    link?: StringFilter<"Pathway"> | string
    description?: StringFilter<"Pathway"> | string
    type?: EnumPathwayTypeFilter<"Pathway"> | $Enums.PathwayType
    createdAt?: DateTimeFilter<"Pathway"> | Date | string
    updatedAt?: DateTimeFilter<"Pathway"> | Date | string
    currencyCode?: StringFilter<"Pathway"> | string
    notes?: StringNullableListFilter<"Pathway">
    limitations?: StringNullableListFilter<"Pathway">
    requirements?: StringNullableListFilter<"Pathway">
    restrictions?: StringNullableListFilter<"Pathway">
    duration?: JsonNullableFilter<"Pathway">
    processTime?: JsonNullableFilter<"Pathway">
    renewal?: JsonNullableFilter<"Pathway">
    cost?: JsonNullableFilter<"Pathway">
    createdby?: StringFilter<"Pathway"> | string
  }

  export type CountryCreateWithoutCountryLanguagesInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityCreateNestedManyWithoutCountryInput
    pathways?: PathwayCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCountryLanguagesInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutCountryInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCountryLanguagesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCountryLanguagesInput, CountryUncheckedCreateWithoutCountryLanguagesInput>
  }

  export type LanguageCreateWithoutCountryLanguagesInput = {
    code: string
    name: string
  }

  export type LanguageUncheckedCreateWithoutCountryLanguagesInput = {
    code: string
    name: string
  }

  export type LanguageCreateOrConnectWithoutCountryLanguagesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCountryLanguagesInput, LanguageUncheckedCreateWithoutCountryLanguagesInput>
  }

  export type CountryUpsertWithoutCountryLanguagesInput = {
    update: XOR<CountryUpdateWithoutCountryLanguagesInput, CountryUncheckedUpdateWithoutCountryLanguagesInput>
    create: XOR<CountryCreateWithoutCountryLanguagesInput, CountryUncheckedCreateWithoutCountryLanguagesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCountryLanguagesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCountryLanguagesInput, CountryUncheckedUpdateWithoutCountryLanguagesInput>
  }

  export type CountryUpdateWithoutCountryLanguagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCountryLanguagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type LanguageUpsertWithoutCountryLanguagesInput = {
    update: XOR<LanguageUpdateWithoutCountryLanguagesInput, LanguageUncheckedUpdateWithoutCountryLanguagesInput>
    create: XOR<LanguageCreateWithoutCountryLanguagesInput, LanguageUncheckedCreateWithoutCountryLanguagesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutCountryLanguagesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutCountryLanguagesInput, LanguageUncheckedUpdateWithoutCountryLanguagesInput>
  }

  export type LanguageUpdateWithoutCountryLanguagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutCountryLanguagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateWithoutCountryCurrenciesInput = {
    code: string
    name: string
    countryLanguages?: CountryLanguageCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityCreateNestedManyWithoutCountryInput
    pathways?: PathwayCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCountryCurrenciesInput = {
    code: string
    name: string
    countryLanguages?: CountryLanguageUncheckedCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutCountryInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCountryCurrenciesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCountryCurrenciesInput, CountryUncheckedCreateWithoutCountryCurrenciesInput>
  }

  export type CurrencyCreateWithoutCountryCurrenciesInput = {
    code: string
    name: string
    symbol: string
    pathways?: PathwayCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutCountryCurrenciesInput = {
    code: string
    name: string
    symbol: string
    pathways?: PathwayUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutCountryCurrenciesInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutCountryCurrenciesInput, CurrencyUncheckedCreateWithoutCountryCurrenciesInput>
  }

  export type CountryUpsertWithoutCountryCurrenciesInput = {
    update: XOR<CountryUpdateWithoutCountryCurrenciesInput, CountryUncheckedUpdateWithoutCountryCurrenciesInput>
    create: XOR<CountryCreateWithoutCountryCurrenciesInput, CountryUncheckedCreateWithoutCountryCurrenciesInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutCountryCurrenciesInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutCountryCurrenciesInput, CountryUncheckedUpdateWithoutCountryCurrenciesInput>
  }

  export type CountryUpdateWithoutCountryCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryLanguages?: CountryLanguageUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutCountryCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryLanguages?: CountryLanguageUncheckedUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CurrencyUpsertWithoutCountryCurrenciesInput = {
    update: XOR<CurrencyUpdateWithoutCountryCurrenciesInput, CurrencyUncheckedUpdateWithoutCountryCurrenciesInput>
    create: XOR<CurrencyCreateWithoutCountryCurrenciesInput, CurrencyUncheckedCreateWithoutCountryCurrenciesInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutCountryCurrenciesInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutCountryCurrenciesInput, CurrencyUncheckedUpdateWithoutCountryCurrenciesInput>
  }

  export type CurrencyUpdateWithoutCountryCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    pathways?: PathwayUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutCountryCurrenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    pathways?: PathwayUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type PathwayDocumentsCreateWithoutPathwayInput = {
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
    document?: DocumentsCreateNestedOneWithoutPathwayDocumentsInput
  }

  export type PathwayDocumentsUncheckedCreateWithoutPathwayInput = {
    id?: number
    documentId?: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayDocumentsCreateOrConnectWithoutPathwayInput = {
    where: PathwayDocumentsWhereUniqueInput
    create: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayDocumentsCreateManyPathwayInputEnvelope = {
    data: PathwayDocumentsCreateManyPathwayInput | PathwayDocumentsCreateManyPathwayInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCategoriesCreateWithoutPathwaysInput = {
    pathway_categories: PathwayTypesCreateNestedOneWithoutPathwayCategoriesInput
  }

  export type PathwayCategoriesUncheckedCreateWithoutPathwaysInput = {
    pathwayTypeId: number
  }

  export type PathwayCategoriesCreateOrConnectWithoutPathwaysInput = {
    where: PathwayCategoriesWhereUniqueInput
    create: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput>
  }

  export type PathwayCategoriesCreateManyPathwaysInputEnvelope = {
    data: PathwayCategoriesCreateManyPathwaysInput | PathwayCategoriesCreateManyPathwaysInput[]
    skipDuplicates?: boolean
  }

  export type PathwayPipelineCreateWithoutPathwayInput = {
    pipeline: $Enums.PathwayPipelines
    note?: string | null
  }

  export type PathwayPipelineUncheckedCreateWithoutPathwayInput = {
    id?: number
    pipeline: $Enums.PathwayPipelines
    note?: string | null
  }

  export type PathwayPipelineCreateOrConnectWithoutPathwayInput = {
    where: PathwayPipelineWhereUniqueInput
    create: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayPipelineCreateManyPathwayInputEnvelope = {
    data: PathwayPipelineCreateManyPathwayInput | PathwayPipelineCreateManyPathwayInput[]
    skipDuplicates?: boolean
  }

  export type PathwayRestrictedNationalityCreateWithoutPathwayInput = {
    note?: string | null
    country: CountryCreateNestedOneWithoutRestrictedPathwaysInput
  }

  export type PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput = {
    countryCode: string
    note?: string | null
  }

  export type PathwayRestrictedNationalityCreateOrConnectWithoutPathwayInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    create: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayRestrictedNationalityCreateManyPathwayInputEnvelope = {
    data: PathwayRestrictedNationalityCreateManyPathwayInput | PathwayRestrictedNationalityCreateManyPathwayInput[]
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutPathwaysInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutPathwaysInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageUncheckedCreateNestedManyWithoutCountryInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutPathwaysInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutPathwaysInput, CountryUncheckedCreateWithoutPathwaysInput>
  }

  export type CurrencyCreateWithoutPathwaysInput = {
    code: string
    name: string
    symbol: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutPathwaysInput = {
    code: string
    name: string
    symbol: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutPathwaysInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutPathwaysInput, CurrencyUncheckedCreateWithoutPathwaysInput>
  }

  export type UserCreateWithoutPathwayInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPathwayInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPathwayInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPathwayInput, UserUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayDocumentsUpsertWithWhereUniqueWithoutPathwayInput = {
    where: PathwayDocumentsWhereUniqueInput
    update: XOR<PathwayDocumentsUpdateWithoutPathwayInput, PathwayDocumentsUncheckedUpdateWithoutPathwayInput>
    create: XOR<PathwayDocumentsCreateWithoutPathwayInput, PathwayDocumentsUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayDocumentsUpdateWithWhereUniqueWithoutPathwayInput = {
    where: PathwayDocumentsWhereUniqueInput
    data: XOR<PathwayDocumentsUpdateWithoutPathwayInput, PathwayDocumentsUncheckedUpdateWithoutPathwayInput>
  }

  export type PathwayDocumentsUpdateManyWithWhereWithoutPathwayInput = {
    where: PathwayDocumentsScalarWhereInput
    data: XOR<PathwayDocumentsUpdateManyMutationInput, PathwayDocumentsUncheckedUpdateManyWithoutPathwayInput>
  }

  export type PathwayDocumentsScalarWhereInput = {
    AND?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
    OR?: PathwayDocumentsScalarWhereInput[]
    NOT?: PathwayDocumentsScalarWhereInput | PathwayDocumentsScalarWhereInput[]
    id?: IntFilter<"PathwayDocuments"> | number
    pathwayId?: IntFilter<"PathwayDocuments"> | number
    documentId?: IntFilter<"PathwayDocuments"> | number
    description?: StringNullableFilter<"PathwayDocuments"> | string | null
    cost?: DecimalFilter<"PathwayDocuments"> | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFilter<"PathwayDocuments"> | boolean
    link?: StringNullableFilter<"PathwayDocuments"> | string | null
    title?: StringNullableFilter<"PathwayDocuments"> | string | null
  }

  export type PathwayCategoriesUpsertWithWhereUniqueWithoutPathwaysInput = {
    where: PathwayCategoriesWhereUniqueInput
    update: XOR<PathwayCategoriesUpdateWithoutPathwaysInput, PathwayCategoriesUncheckedUpdateWithoutPathwaysInput>
    create: XOR<PathwayCategoriesCreateWithoutPathwaysInput, PathwayCategoriesUncheckedCreateWithoutPathwaysInput>
  }

  export type PathwayCategoriesUpdateWithWhereUniqueWithoutPathwaysInput = {
    where: PathwayCategoriesWhereUniqueInput
    data: XOR<PathwayCategoriesUpdateWithoutPathwaysInput, PathwayCategoriesUncheckedUpdateWithoutPathwaysInput>
  }

  export type PathwayCategoriesUpdateManyWithWhereWithoutPathwaysInput = {
    where: PathwayCategoriesScalarWhereInput
    data: XOR<PathwayCategoriesUpdateManyMutationInput, PathwayCategoriesUncheckedUpdateManyWithoutPathwaysInput>
  }

  export type PathwayCategoriesScalarWhereInput = {
    AND?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
    OR?: PathwayCategoriesScalarWhereInput[]
    NOT?: PathwayCategoriesScalarWhereInput | PathwayCategoriesScalarWhereInput[]
    pathwayId?: IntFilter<"PathwayCategories"> | number
    pathwayTypeId?: IntFilter<"PathwayCategories"> | number
  }

  export type PathwayPipelineUpsertWithWhereUniqueWithoutPathwayInput = {
    where: PathwayPipelineWhereUniqueInput
    update: XOR<PathwayPipelineUpdateWithoutPathwayInput, PathwayPipelineUncheckedUpdateWithoutPathwayInput>
    create: XOR<PathwayPipelineCreateWithoutPathwayInput, PathwayPipelineUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayPipelineUpdateWithWhereUniqueWithoutPathwayInput = {
    where: PathwayPipelineWhereUniqueInput
    data: XOR<PathwayPipelineUpdateWithoutPathwayInput, PathwayPipelineUncheckedUpdateWithoutPathwayInput>
  }

  export type PathwayPipelineUpdateManyWithWhereWithoutPathwayInput = {
    where: PathwayPipelineScalarWhereInput
    data: XOR<PathwayPipelineUpdateManyMutationInput, PathwayPipelineUncheckedUpdateManyWithoutPathwayInput>
  }

  export type PathwayPipelineScalarWhereInput = {
    AND?: PathwayPipelineScalarWhereInput | PathwayPipelineScalarWhereInput[]
    OR?: PathwayPipelineScalarWhereInput[]
    NOT?: PathwayPipelineScalarWhereInput | PathwayPipelineScalarWhereInput[]
    id?: IntFilter<"PathwayPipeline"> | number
    pathwayId?: IntFilter<"PathwayPipeline"> | number
    pipeline?: EnumPathwayPipelinesFilter<"PathwayPipeline"> | $Enums.PathwayPipelines
    note?: StringNullableFilter<"PathwayPipeline"> | string | null
  }

  export type PathwayRestrictedNationalityUpsertWithWhereUniqueWithoutPathwayInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    update: XOR<PathwayRestrictedNationalityUpdateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedUpdateWithoutPathwayInput>
    create: XOR<PathwayRestrictedNationalityCreateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedCreateWithoutPathwayInput>
  }

  export type PathwayRestrictedNationalityUpdateWithWhereUniqueWithoutPathwayInput = {
    where: PathwayRestrictedNationalityWhereUniqueInput
    data: XOR<PathwayRestrictedNationalityUpdateWithoutPathwayInput, PathwayRestrictedNationalityUncheckedUpdateWithoutPathwayInput>
  }

  export type PathwayRestrictedNationalityUpdateManyWithWhereWithoutPathwayInput = {
    where: PathwayRestrictedNationalityScalarWhereInput
    data: XOR<PathwayRestrictedNationalityUpdateManyMutationInput, PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayInput>
  }

  export type CountryUpsertWithoutPathwaysInput = {
    update: XOR<CountryUpdateWithoutPathwaysInput, CountryUncheckedUpdateWithoutPathwaysInput>
    create: XOR<CountryCreateWithoutPathwaysInput, CountryUncheckedCreateWithoutPathwaysInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutPathwaysInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutPathwaysInput, CountryUncheckedUpdateWithoutPathwaysInput>
  }

  export type CountryUpdateWithoutPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUncheckedUpdateManyWithoutCountryNestedInput
    restrictedPathways?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CurrencyUpsertWithoutPathwaysInput = {
    update: XOR<CurrencyUpdateWithoutPathwaysInput, CurrencyUncheckedUpdateWithoutPathwaysInput>
    create: XOR<CurrencyCreateWithoutPathwaysInput, CurrencyUncheckedCreateWithoutPathwaysInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutPathwaysInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutPathwaysInput, CurrencyUncheckedUpdateWithoutPathwaysInput>
  }

  export type CurrencyUpdateWithoutPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type UserUpsertWithoutPathwayInput = {
    update: XOR<UserUpdateWithoutPathwayInput, UserUncheckedUpdateWithoutPathwayInput>
    create: XOR<UserCreateWithoutPathwayInput, UserUncheckedCreateWithoutPathwayInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPathwayInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPathwayInput, UserUncheckedUpdateWithoutPathwayInput>
  }

  export type UserUpdateWithoutPathwayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPathwayInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PathwayCreateWithoutPipelinesInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutPipelinesInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutPipelinesInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutPipelinesInput, PathwayUncheckedCreateWithoutPipelinesInput>
  }

  export type PathwayUpsertWithoutPipelinesInput = {
    update: XOR<PathwayUpdateWithoutPipelinesInput, PathwayUncheckedUpdateWithoutPipelinesInput>
    create: XOR<PathwayCreateWithoutPipelinesInput, PathwayUncheckedCreateWithoutPipelinesInput>
    where?: PathwayWhereInput
  }

  export type PathwayUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: PathwayWhereInput
    data: XOR<PathwayUpdateWithoutPipelinesInput, PathwayUncheckedUpdateWithoutPipelinesInput>
  }

  export type PathwayUpdateWithoutPipelinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutPipelinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type CountryCreateWithoutRestrictedPathwaysInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageCreateNestedManyWithoutCountryInput
    pathways?: PathwayCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutRestrictedPathwaysInput = {
    code: string
    name: string
    countryCurrencies?: CountryCurrencyUncheckedCreateNestedManyWithoutCountryInput
    countryLanguages?: CountryLanguageUncheckedCreateNestedManyWithoutCountryInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutRestrictedPathwaysInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutRestrictedPathwaysInput, CountryUncheckedCreateWithoutRestrictedPathwaysInput>
  }

  export type PathwayCreateWithoutRestrictedNationalitiesInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutRestrictedNationalitiesInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutRestrictedNationalitiesInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutRestrictedNationalitiesInput, PathwayUncheckedCreateWithoutRestrictedNationalitiesInput>
  }

  export type CountryUpsertWithoutRestrictedPathwaysInput = {
    update: XOR<CountryUpdateWithoutRestrictedPathwaysInput, CountryUncheckedUpdateWithoutRestrictedPathwaysInput>
    create: XOR<CountryCreateWithoutRestrictedPathwaysInput, CountryUncheckedCreateWithoutRestrictedPathwaysInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutRestrictedPathwaysInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutRestrictedPathwaysInput, CountryUncheckedUpdateWithoutRestrictedPathwaysInput>
  }

  export type CountryUpdateWithoutRestrictedPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutRestrictedPathwaysInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCurrencies?: CountryCurrencyUncheckedUpdateManyWithoutCountryNestedInput
    countryLanguages?: CountryLanguageUncheckedUpdateManyWithoutCountryNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type PathwayUpsertWithoutRestrictedNationalitiesInput = {
    update: XOR<PathwayUpdateWithoutRestrictedNationalitiesInput, PathwayUncheckedUpdateWithoutRestrictedNationalitiesInput>
    create: XOR<PathwayCreateWithoutRestrictedNationalitiesInput, PathwayUncheckedCreateWithoutRestrictedNationalitiesInput>
    where?: PathwayWhereInput
  }

  export type PathwayUpdateToOneWithWhereWithoutRestrictedNationalitiesInput = {
    where?: PathwayWhereInput
    data: XOR<PathwayUpdateWithoutRestrictedNationalitiesInput, PathwayUncheckedUpdateWithoutRestrictedNationalitiesInput>
  }

  export type PathwayUpdateWithoutRestrictedNationalitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutRestrictedNationalitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type DocumentsCreateWithoutPathwayDocumentsInput = {
    name: string
    description?: string | null
    type?: DocumentsCreatetypeInput | $Enums.DocumentType[]
  }

  export type DocumentsUncheckedCreateWithoutPathwayDocumentsInput = {
    id?: number
    name: string
    description?: string | null
    type?: DocumentsCreatetypeInput | $Enums.DocumentType[]
  }

  export type DocumentsCreateOrConnectWithoutPathwayDocumentsInput = {
    where: DocumentsWhereUniqueInput
    create: XOR<DocumentsCreateWithoutPathwayDocumentsInput, DocumentsUncheckedCreateWithoutPathwayDocumentsInput>
  }

  export type PathwayCreateWithoutDocumentsInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutDocumentsInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutDocumentsInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutDocumentsInput, PathwayUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentsUpsertWithoutPathwayDocumentsInput = {
    update: XOR<DocumentsUpdateWithoutPathwayDocumentsInput, DocumentsUncheckedUpdateWithoutPathwayDocumentsInput>
    create: XOR<DocumentsCreateWithoutPathwayDocumentsInput, DocumentsUncheckedCreateWithoutPathwayDocumentsInput>
    where?: DocumentsWhereInput
  }

  export type DocumentsUpdateToOneWithWhereWithoutPathwayDocumentsInput = {
    where?: DocumentsWhereInput
    data: XOR<DocumentsUpdateWithoutPathwayDocumentsInput, DocumentsUncheckedUpdateWithoutPathwayDocumentsInput>
  }

  export type DocumentsUpdateWithoutPathwayDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
  }

  export type DocumentsUncheckedUpdateWithoutPathwayDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: DocumentsUpdatetypeInput | $Enums.DocumentType[]
  }

  export type PathwayUpsertWithoutDocumentsInput = {
    update: XOR<PathwayUpdateWithoutDocumentsInput, PathwayUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PathwayCreateWithoutDocumentsInput, PathwayUncheckedCreateWithoutDocumentsInput>
    where?: PathwayWhereInput
  }

  export type PathwayUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PathwayWhereInput
    data: XOR<PathwayUpdateWithoutDocumentsInput, PathwayUncheckedUpdateWithoutDocumentsInput>
  }

  export type PathwayUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type CountryCurrencyCreateWithoutCurrencyInput = {
    country: CountryCreateNestedOneWithoutCountryCurrenciesInput
  }

  export type CountryCurrencyUncheckedCreateWithoutCurrencyInput = {
    countryCode: string
  }

  export type CountryCurrencyCreateOrConnectWithoutCurrencyInput = {
    where: CountryCurrencyWhereUniqueInput
    create: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type CountryCurrencyCreateManyCurrencyInputEnvelope = {
    data: CountryCurrencyCreateManyCurrencyInput | CountryCurrencyCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutCurrencyInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutCurrencyInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutCurrencyInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput>
  }

  export type PathwayCreateManyCurrencyInputEnvelope = {
    data: PathwayCreateManyCurrencyInput | PathwayCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type CountryCurrencyUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: CountryCurrencyWhereUniqueInput
    update: XOR<CountryCurrencyUpdateWithoutCurrencyInput, CountryCurrencyUncheckedUpdateWithoutCurrencyInput>
    create: XOR<CountryCurrencyCreateWithoutCurrencyInput, CountryCurrencyUncheckedCreateWithoutCurrencyInput>
  }

  export type CountryCurrencyUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: CountryCurrencyWhereUniqueInput
    data: XOR<CountryCurrencyUpdateWithoutCurrencyInput, CountryCurrencyUncheckedUpdateWithoutCurrencyInput>
  }

  export type CountryCurrencyUpdateManyWithWhereWithoutCurrencyInput = {
    where: CountryCurrencyScalarWhereInput
    data: XOR<CountryCurrencyUpdateManyMutationInput, CountryCurrencyUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type PathwayUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutCurrencyInput, PathwayUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PathwayCreateWithoutCurrencyInput, PathwayUncheckedCreateWithoutCurrencyInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutCurrencyInput, PathwayUncheckedUpdateWithoutCurrencyInput>
  }

  export type PathwayUpdateManyWithWhereWithoutCurrencyInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type PathwayDocumentsCreateWithoutDocumentInput = {
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
    pathway: PathwayCreateNestedOneWithoutDocumentsInput
  }

  export type PathwayDocumentsUncheckedCreateWithoutDocumentInput = {
    id?: number
    pathwayId: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayDocumentsCreateOrConnectWithoutDocumentInput = {
    where: PathwayDocumentsWhereUniqueInput
    create: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput>
  }

  export type PathwayDocumentsCreateManyDocumentInputEnvelope = {
    data: PathwayDocumentsCreateManyDocumentInput | PathwayDocumentsCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type PathwayDocumentsUpsertWithWhereUniqueWithoutDocumentInput = {
    where: PathwayDocumentsWhereUniqueInput
    update: XOR<PathwayDocumentsUpdateWithoutDocumentInput, PathwayDocumentsUncheckedUpdateWithoutDocumentInput>
    create: XOR<PathwayDocumentsCreateWithoutDocumentInput, PathwayDocumentsUncheckedCreateWithoutDocumentInput>
  }

  export type PathwayDocumentsUpdateWithWhereUniqueWithoutDocumentInput = {
    where: PathwayDocumentsWhereUniqueInput
    data: XOR<PathwayDocumentsUpdateWithoutDocumentInput, PathwayDocumentsUncheckedUpdateWithoutDocumentInput>
  }

  export type PathwayDocumentsUpdateManyWithWhereWithoutDocumentInput = {
    where: PathwayDocumentsScalarWhereInput
    data: XOR<PathwayDocumentsUpdateManyMutationInput, PathwayDocumentsUncheckedUpdateManyWithoutDocumentInput>
  }

  export type CountryLanguageCreateWithoutLanguageInput = {
    country: CountryCreateNestedOneWithoutCountryLanguagesInput
  }

  export type CountryLanguageUncheckedCreateWithoutLanguageInput = {
    countryCode: string
  }

  export type CountryLanguageCreateOrConnectWithoutLanguageInput = {
    where: CountryLanguageWhereUniqueInput
    create: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type CountryLanguageCreateManyLanguageInputEnvelope = {
    data: CountryLanguageCreateManyLanguageInput | CountryLanguageCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type CountryLanguageUpsertWithWhereUniqueWithoutLanguageInput = {
    where: CountryLanguageWhereUniqueInput
    update: XOR<CountryLanguageUpdateWithoutLanguageInput, CountryLanguageUncheckedUpdateWithoutLanguageInput>
    create: XOR<CountryLanguageCreateWithoutLanguageInput, CountryLanguageUncheckedCreateWithoutLanguageInput>
  }

  export type CountryLanguageUpdateWithWhereUniqueWithoutLanguageInput = {
    where: CountryLanguageWhereUniqueInput
    data: XOR<CountryLanguageUpdateWithoutLanguageInput, CountryLanguageUncheckedUpdateWithoutLanguageInput>
  }

  export type CountryLanguageUpdateManyWithWhereWithoutLanguageInput = {
    where: CountryLanguageScalarWhereInput
    data: XOR<CountryLanguageUpdateManyMutationInput, CountryLanguageUncheckedUpdateManyWithoutLanguageInput>
  }

  export type PostBlockCreateWithoutPostInput = {
    type: string
    content: string
    position: number
    block: BlockCreateNestedOneWithoutPostBlockInput
  }

  export type PostBlockUncheckedCreateWithoutPostInput = {
    id?: number
    blockId: number
    type: string
    content: string
    position: number
  }

  export type PostBlockCreateOrConnectWithoutPostInput = {
    where: PostBlockWhereUniqueInput
    create: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput>
  }

  export type PostBlockCreateManyPostInputEnvelope = {
    data: PostBlockCreateManyPostInput | PostBlockCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostTagCreateWithoutPostInput = {
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateWithoutPostInput = {
    tagId: number
  }

  export type PostTagCreateOrConnectWithoutPostInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateManyPostInputEnvelope = {
    data: PostTagCreateManyPostInput | PostTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostVersionHistoryCreateWithoutPostInput = {
    action: string
    instanceAt?: Date | string
    user: UserCreateNestedOneWithoutPostVersionHistoryInput
  }

  export type PostVersionHistoryUncheckedCreateWithoutPostInput = {
    id?: number
    userId: string
    action: string
    instanceAt?: Date | string
  }

  export type PostVersionHistoryCreateOrConnectWithoutPostInput = {
    where: PostVersionHistoryWhereUniqueInput
    create: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput>
  }

  export type PostVersionHistoryCreateManyPostInputEnvelope = {
    data: PostVersionHistoryCreateManyPostInput | PostVersionHistoryCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostBlockUpsertWithWhereUniqueWithoutPostInput = {
    where: PostBlockWhereUniqueInput
    update: XOR<PostBlockUpdateWithoutPostInput, PostBlockUncheckedUpdateWithoutPostInput>
    create: XOR<PostBlockCreateWithoutPostInput, PostBlockUncheckedCreateWithoutPostInput>
  }

  export type PostBlockUpdateWithWhereUniqueWithoutPostInput = {
    where: PostBlockWhereUniqueInput
    data: XOR<PostBlockUpdateWithoutPostInput, PostBlockUncheckedUpdateWithoutPostInput>
  }

  export type PostBlockUpdateManyWithWhereWithoutPostInput = {
    where: PostBlockScalarWhereInput
    data: XOR<PostBlockUpdateManyMutationInput, PostBlockUncheckedUpdateManyWithoutPostInput>
  }

  export type PostBlockScalarWhereInput = {
    AND?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
    OR?: PostBlockScalarWhereInput[]
    NOT?: PostBlockScalarWhereInput | PostBlockScalarWhereInput[]
    id?: IntFilter<"PostBlock"> | number
    postId?: IntFilter<"PostBlock"> | number
    blockId?: IntFilter<"PostBlock"> | number
    type?: StringFilter<"PostBlock"> | string
    content?: StringFilter<"PostBlock"> | string
    position?: IntFilter<"PostBlock"> | number
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    postId?: IntFilter<"PostTag"> | number
    tagId?: IntFilter<"PostTag"> | number
  }

  export type PostVersionHistoryUpsertWithWhereUniqueWithoutPostInput = {
    where: PostVersionHistoryWhereUniqueInput
    update: XOR<PostVersionHistoryUpdateWithoutPostInput, PostVersionHistoryUncheckedUpdateWithoutPostInput>
    create: XOR<PostVersionHistoryCreateWithoutPostInput, PostVersionHistoryUncheckedCreateWithoutPostInput>
  }

  export type PostVersionHistoryUpdateWithWhereUniqueWithoutPostInput = {
    where: PostVersionHistoryWhereUniqueInput
    data: XOR<PostVersionHistoryUpdateWithoutPostInput, PostVersionHistoryUncheckedUpdateWithoutPostInput>
  }

  export type PostVersionHistoryUpdateManyWithWhereWithoutPostInput = {
    where: PostVersionHistoryScalarWhereInput
    data: XOR<PostVersionHistoryUpdateManyMutationInput, PostVersionHistoryUncheckedUpdateManyWithoutPostInput>
  }

  export type PostVersionHistoryScalarWhereInput = {
    AND?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
    OR?: PostVersionHistoryScalarWhereInput[]
    NOT?: PostVersionHistoryScalarWhereInput | PostVersionHistoryScalarWhereInput[]
    id?: IntFilter<"PostVersionHistory"> | number
    postId?: IntFilter<"PostVersionHistory"> | number
    userId?: StringFilter<"PostVersionHistory"> | string
    action?: StringFilter<"PostVersionHistory"> | string
    instanceAt?: DateTimeFilter<"PostVersionHistory"> | Date | string
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PostCreateWithoutTagsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryCreateNestedManyWithoutPostInput
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    name: string
    color?: string
    childTag?: TagHierarchyCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyCreateNestedManyWithoutChildInput
    parent?: TagCreateNestedOneWithoutChildrenInput
    children?: TagCreateNestedManyWithoutParentInput
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
    childTag?: TagHierarchyUncheckedCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyUncheckedCreateNestedManyWithoutChildInput
    children?: TagUncheckedCreateNestedManyWithoutParentInput
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type PostUpsertWithoutTagsInput = {
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutTagsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUncheckedUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    childTag?: TagHierarchyUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUpdateManyWithoutChildNestedInput
    parent?: TagUpdateOneWithoutChildrenNestedInput
    children?: TagUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    childTag?: TagHierarchyUncheckedUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUncheckedUpdateManyWithoutChildNestedInput
    children?: TagUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PostTagCreateWithoutTagInput = {
    post: PostCreateNestedOneWithoutTagsInput
  }

  export type PostTagUncheckedCreateWithoutTagInput = {
    postId: number
  }

  export type PostTagCreateOrConnectWithoutTagInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagCreateManyTagInputEnvelope = {
    data: PostTagCreateManyTagInput | PostTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagHierarchyCreateWithoutParentInput = {
    child: TagCreateNestedOneWithoutParentTagInput
  }

  export type TagHierarchyUncheckedCreateWithoutParentInput = {
    id?: number
    parentId: number
  }

  export type TagHierarchyCreateOrConnectWithoutParentInput = {
    where: TagHierarchyWhereUniqueInput
    create: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput>
  }

  export type TagHierarchyCreateManyParentInputEnvelope = {
    data: TagHierarchyCreateManyParentInput | TagHierarchyCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TagHierarchyCreateWithoutChildInput = {
    parent: TagCreateNestedOneWithoutChildTagInput
  }

  export type TagHierarchyUncheckedCreateWithoutChildInput = {
    id?: number
    childId: number
  }

  export type TagHierarchyCreateOrConnectWithoutChildInput = {
    where: TagHierarchyWhereUniqueInput
    create: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput>
  }

  export type TagHierarchyCreateManyChildInputEnvelope = {
    data: TagHierarchyCreateManyChildInput | TagHierarchyCreateManyChildInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutChildrenInput = {
    name: string
    color?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyCreateNestedManyWithoutChildInput
    parent?: TagCreateNestedOneWithoutChildrenInput
  }

  export type TagUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyUncheckedCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyUncheckedCreateNestedManyWithoutChildInput
  }

  export type TagCreateOrConnectWithoutChildrenInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutChildrenInput, TagUncheckedCreateWithoutChildrenInput>
  }

  export type TagCreateWithoutParentInput = {
    name: string
    color?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyCreateNestedManyWithoutChildInput
    children?: TagCreateNestedManyWithoutParentInput
  }

  export type TagUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    color?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyUncheckedCreateNestedManyWithoutParentInput
    parentTag?: TagHierarchyUncheckedCreateNestedManyWithoutChildInput
    children?: TagUncheckedCreateNestedManyWithoutParentInput
  }

  export type TagCreateOrConnectWithoutParentInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput>
  }

  export type TagCreateManyParentInputEnvelope = {
    data: TagCreateManyParentInput | TagCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
  }

  export type PostTagUpdateManyWithWhereWithoutTagInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TagHierarchyUpsertWithWhereUniqueWithoutParentInput = {
    where: TagHierarchyWhereUniqueInput
    update: XOR<TagHierarchyUpdateWithoutParentInput, TagHierarchyUncheckedUpdateWithoutParentInput>
    create: XOR<TagHierarchyCreateWithoutParentInput, TagHierarchyUncheckedCreateWithoutParentInput>
  }

  export type TagHierarchyUpdateWithWhereUniqueWithoutParentInput = {
    where: TagHierarchyWhereUniqueInput
    data: XOR<TagHierarchyUpdateWithoutParentInput, TagHierarchyUncheckedUpdateWithoutParentInput>
  }

  export type TagHierarchyUpdateManyWithWhereWithoutParentInput = {
    where: TagHierarchyScalarWhereInput
    data: XOR<TagHierarchyUpdateManyMutationInput, TagHierarchyUncheckedUpdateManyWithoutParentInput>
  }

  export type TagHierarchyScalarWhereInput = {
    AND?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
    OR?: TagHierarchyScalarWhereInput[]
    NOT?: TagHierarchyScalarWhereInput | TagHierarchyScalarWhereInput[]
    id?: IntFilter<"TagHierarchy"> | number
    parentId?: IntFilter<"TagHierarchy"> | number
    childId?: IntFilter<"TagHierarchy"> | number
  }

  export type TagHierarchyUpsertWithWhereUniqueWithoutChildInput = {
    where: TagHierarchyWhereUniqueInput
    update: XOR<TagHierarchyUpdateWithoutChildInput, TagHierarchyUncheckedUpdateWithoutChildInput>
    create: XOR<TagHierarchyCreateWithoutChildInput, TagHierarchyUncheckedCreateWithoutChildInput>
  }

  export type TagHierarchyUpdateWithWhereUniqueWithoutChildInput = {
    where: TagHierarchyWhereUniqueInput
    data: XOR<TagHierarchyUpdateWithoutChildInput, TagHierarchyUncheckedUpdateWithoutChildInput>
  }

  export type TagHierarchyUpdateManyWithWhereWithoutChildInput = {
    where: TagHierarchyScalarWhereInput
    data: XOR<TagHierarchyUpdateManyMutationInput, TagHierarchyUncheckedUpdateManyWithoutChildInput>
  }

  export type TagUpsertWithoutChildrenInput = {
    update: XOR<TagUpdateWithoutChildrenInput, TagUncheckedUpdateWithoutChildrenInput>
    create: XOR<TagCreateWithoutChildrenInput, TagUncheckedCreateWithoutChildrenInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutChildrenInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutChildrenInput, TagUncheckedUpdateWithoutChildrenInput>
  }

  export type TagUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUpdateManyWithoutChildNestedInput
    parent?: TagUpdateOneWithoutChildrenNestedInput
  }

  export type TagUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUncheckedUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUncheckedUpdateManyWithoutChildNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutParentInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutParentInput, TagUncheckedUpdateWithoutParentInput>
    create: XOR<TagCreateWithoutParentInput, TagUncheckedCreateWithoutParentInput>
  }

  export type TagUpdateWithWhereUniqueWithoutParentInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutParentInput, TagUncheckedUpdateWithoutParentInput>
  }

  export type TagUpdateManyWithWhereWithoutParentInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutParentInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    parentId?: IntNullableFilter<"Tag"> | number | null
    color?: StringFilter<"Tag"> | string
  }

  export type TagCreateWithoutChildTagInput = {
    name: string
    color?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    parentTag?: TagHierarchyCreateNestedManyWithoutChildInput
    parent?: TagCreateNestedOneWithoutChildrenInput
    children?: TagCreateNestedManyWithoutParentInput
  }

  export type TagUncheckedCreateWithoutChildTagInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    parentTag?: TagHierarchyUncheckedCreateNestedManyWithoutChildInput
    children?: TagUncheckedCreateNestedManyWithoutParentInput
  }

  export type TagCreateOrConnectWithoutChildTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutChildTagInput, TagUncheckedCreateWithoutChildTagInput>
  }

  export type TagCreateWithoutParentTagInput = {
    name: string
    color?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyCreateNestedManyWithoutParentInput
    parent?: TagCreateNestedOneWithoutChildrenInput
    children?: TagCreateNestedManyWithoutParentInput
  }

  export type TagUncheckedCreateWithoutParentTagInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    childTag?: TagHierarchyUncheckedCreateNestedManyWithoutParentInput
    children?: TagUncheckedCreateNestedManyWithoutParentInput
  }

  export type TagCreateOrConnectWithoutParentTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutParentTagInput, TagUncheckedCreateWithoutParentTagInput>
  }

  export type TagUpsertWithoutChildTagInput = {
    update: XOR<TagUpdateWithoutChildTagInput, TagUncheckedUpdateWithoutChildTagInput>
    create: XOR<TagCreateWithoutChildTagInput, TagUncheckedCreateWithoutChildTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutChildTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutChildTagInput, TagUncheckedUpdateWithoutChildTagInput>
  }

  export type TagUpdateWithoutChildTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    parentTag?: TagHierarchyUpdateManyWithoutChildNestedInput
    parent?: TagUpdateOneWithoutChildrenNestedInput
    children?: TagUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateWithoutChildTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    parentTag?: TagHierarchyUncheckedUpdateManyWithoutChildNestedInput
    children?: TagUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TagUpsertWithoutParentTagInput = {
    update: XOR<TagUpdateWithoutParentTagInput, TagUncheckedUpdateWithoutParentTagInput>
    create: XOR<TagCreateWithoutParentTagInput, TagUncheckedCreateWithoutParentTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutParentTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutParentTagInput, TagUncheckedUpdateWithoutParentTagInput>
  }

  export type TagUpdateWithoutParentTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUpdateManyWithoutParentNestedInput
    parent?: TagUpdateOneWithoutChildrenNestedInput
    children?: TagUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateWithoutParentTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUncheckedUpdateManyWithoutParentNestedInput
    children?: TagUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserCreateWithoutResourcesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
  }

  export type UserUpsertWithoutResourcesInput = {
    update: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type UserUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BlockFieldCreateWithoutBlockInput = {
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
  }

  export type BlockFieldUncheckedCreateWithoutBlockInput = {
    id?: number
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
  }

  export type BlockFieldCreateOrConnectWithoutBlockInput = {
    where: BlockFieldWhereUniqueInput
    create: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput>
  }

  export type BlockFieldCreateManyBlockInputEnvelope = {
    data: BlockFieldCreateManyBlockInput | BlockFieldCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type PostBlockCreateWithoutBlockInput = {
    type: string
    content: string
    position: number
    post: PostCreateNestedOneWithoutPostBlockInput
  }

  export type PostBlockUncheckedCreateWithoutBlockInput = {
    id?: number
    postId: number
    type: string
    content: string
    position: number
  }

  export type PostBlockCreateOrConnectWithoutBlockInput = {
    where: PostBlockWhereUniqueInput
    create: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput>
  }

  export type PostBlockCreateManyBlockInputEnvelope = {
    data: PostBlockCreateManyBlockInput | PostBlockCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type BlockFieldUpsertWithWhereUniqueWithoutBlockInput = {
    where: BlockFieldWhereUniqueInput
    update: XOR<BlockFieldUpdateWithoutBlockInput, BlockFieldUncheckedUpdateWithoutBlockInput>
    create: XOR<BlockFieldCreateWithoutBlockInput, BlockFieldUncheckedCreateWithoutBlockInput>
  }

  export type BlockFieldUpdateWithWhereUniqueWithoutBlockInput = {
    where: BlockFieldWhereUniqueInput
    data: XOR<BlockFieldUpdateWithoutBlockInput, BlockFieldUncheckedUpdateWithoutBlockInput>
  }

  export type BlockFieldUpdateManyWithWhereWithoutBlockInput = {
    where: BlockFieldScalarWhereInput
    data: XOR<BlockFieldUpdateManyMutationInput, BlockFieldUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockFieldScalarWhereInput = {
    AND?: BlockFieldScalarWhereInput | BlockFieldScalarWhereInput[]
    OR?: BlockFieldScalarWhereInput[]
    NOT?: BlockFieldScalarWhereInput | BlockFieldScalarWhereInput[]
    id?: IntFilter<"BlockField"> | number
    blockId?: IntFilter<"BlockField"> | number
    name?: StringFilter<"BlockField"> | string
    type?: StringFilter<"BlockField"> | string
    options?: StringNullableFilter<"BlockField"> | string | null
    slug?: StringFilter<"BlockField"> | string
    defaultValue?: StringNullableFilter<"BlockField"> | string | null
  }

  export type PostBlockUpsertWithWhereUniqueWithoutBlockInput = {
    where: PostBlockWhereUniqueInput
    update: XOR<PostBlockUpdateWithoutBlockInput, PostBlockUncheckedUpdateWithoutBlockInput>
    create: XOR<PostBlockCreateWithoutBlockInput, PostBlockUncheckedCreateWithoutBlockInput>
  }

  export type PostBlockUpdateWithWhereUniqueWithoutBlockInput = {
    where: PostBlockWhereUniqueInput
    data: XOR<PostBlockUpdateWithoutBlockInput, PostBlockUncheckedUpdateWithoutBlockInput>
  }

  export type PostBlockUpdateManyWithWhereWithoutBlockInput = {
    where: PostBlockScalarWhereInput
    data: XOR<PostBlockUpdateManyMutationInput, PostBlockUncheckedUpdateManyWithoutBlockInput>
  }

  export type BlockCreateWithoutBlockFieldInput = {
    slug: string
    name: string
    component: string
    type?: string
    postBlock?: PostBlockCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutBlockFieldInput = {
    id?: number
    slug: string
    name: string
    component: string
    type?: string
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutBlockFieldInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockFieldInput, BlockUncheckedCreateWithoutBlockFieldInput>
  }

  export type BlockUpsertWithoutBlockFieldInput = {
    update: XOR<BlockUpdateWithoutBlockFieldInput, BlockUncheckedUpdateWithoutBlockFieldInput>
    create: XOR<BlockCreateWithoutBlockFieldInput, BlockUncheckedCreateWithoutBlockFieldInput>
    where?: BlockWhereInput
  }

  export type BlockUpdateToOneWithWhereWithoutBlockFieldInput = {
    where?: BlockWhereInput
    data: XOR<BlockUpdateWithoutBlockFieldInput, BlockUncheckedUpdateWithoutBlockFieldInput>
  }

  export type BlockUpdateWithoutBlockFieldInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    postBlock?: PostBlockUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    postBlock?: PostBlockUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type BlockCreateWithoutPostBlockInput = {
    slug: string
    name: string
    component: string
    type?: string
    blockField?: BlockFieldCreateNestedManyWithoutBlockInput
  }

  export type BlockUncheckedCreateWithoutPostBlockInput = {
    id?: number
    slug: string
    name: string
    component: string
    type?: string
    blockField?: BlockFieldUncheckedCreateNestedManyWithoutBlockInput
  }

  export type BlockCreateOrConnectWithoutPostBlockInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutPostBlockInput, BlockUncheckedCreateWithoutPostBlockInput>
  }

  export type PostCreateWithoutPostBlockInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    tags?: PostTagCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryCreateNestedManyWithoutPostInput
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPostBlockInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostBlockInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostBlockInput, PostUncheckedCreateWithoutPostBlockInput>
  }

  export type BlockUpsertWithoutPostBlockInput = {
    update: XOR<BlockUpdateWithoutPostBlockInput, BlockUncheckedUpdateWithoutPostBlockInput>
    create: XOR<BlockCreateWithoutPostBlockInput, BlockUncheckedCreateWithoutPostBlockInput>
    where?: BlockWhereInput
  }

  export type BlockUpdateToOneWithWhereWithoutPostBlockInput = {
    where?: BlockWhereInput
    data: XOR<BlockUpdateWithoutPostBlockInput, BlockUncheckedUpdateWithoutPostBlockInput>
  }

  export type BlockUpdateWithoutPostBlockInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    blockField?: BlockFieldUpdateManyWithoutBlockNestedInput
  }

  export type BlockUncheckedUpdateWithoutPostBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    component?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    blockField?: BlockFieldUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type PostUpsertWithoutPostBlockInput = {
    update: XOR<PostUpdateWithoutPostBlockInput, PostUncheckedUpdateWithoutPostBlockInput>
    create: XOR<PostCreateWithoutPostBlockInput, PostUncheckedCreateWithoutPostBlockInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostBlockInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostBlockInput, PostUncheckedUpdateWithoutPostBlockInput>
  }

  export type PostUpdateWithoutPostBlockInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostTagUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPostBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PostVersionHistoryCreateWithoutUserInput = {
    action: string
    instanceAt?: Date | string
    post: PostCreateNestedOneWithoutPostVersionHistoriesInput
  }

  export type PostVersionHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    action: string
    instanceAt?: Date | string
  }

  export type PostVersionHistoryCreateOrConnectWithoutUserInput = {
    where: PostVersionHistoryWhereUniqueInput
    create: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput>
  }

  export type PostVersionHistoryCreateManyUserInputEnvelope = {
    data: PostVersionHistoryCreateManyUserInput | PostVersionHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    postVersionHistories?: PostVersionHistoryUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRolesCreateWithoutUserInput = {
    role: RolesCreateNestedOneWithoutUserRolesInput
  }

  export type UserRolesUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type UserRolesCreateOrConnectWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    create: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput>
  }

  export type UserRolesCreateManyUserInputEnvelope = {
    data: UserRolesCreateManyUserInput | UserRolesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSocialCreateWithoutUserInput = {
    handle: string
    social: SocialCreateNestedOneWithoutUsersInput
  }

  export type UserSocialUncheckedCreateWithoutUserInput = {
    handle: string
    socialCode: string
  }

  export type UserSocialCreateOrConnectWithoutUserInput = {
    where: UserSocialWhereUniqueInput
    create: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput>
  }

  export type UserSocialCreateManyUserInputEnvelope = {
    data: UserSocialCreateManyUserInput | UserSocialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutCMS_UserInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
  }

  export type PathwayUncheckedCreateWithoutCMS_UserInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    categories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathwaysInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutCMS_UserInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput>
  }

  export type PathwayCreateManyCMS_UserInputEnvelope = {
    data: PathwayCreateManyCMS_UserInput | PathwayCreateManyCMS_UserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutAuthorInput = {
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
  }

  export type ResourceUncheckedCreateWithoutAuthorInput = {
    id?: number
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
  }

  export type ResourceCreateOrConnectWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ResourceCreateManyAuthorInputEnvelope = {
    data: ResourceCreateManyAuthorInput | ResourceCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ContentResourceCreateWithoutAuthorInput = {
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    date?: Date | string
    authorString?: string | null
    area: ContentResourceAreaCreateNestedOneWithoutContentResourcesInput
    type: ContentResourceTypeCreateNestedOneWithoutContentResourcesInput
  }

  export type ContentResourceUncheckedCreateWithoutAuthorInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type ContentResourceCreateOrConnectWithoutAuthorInput = {
    where: ContentResourceWhereUniqueInput
    create: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ContentResourceCreateManyAuthorInputEnvelope = {
    data: ContentResourceCreateManyAuthorInput | ContentResourceCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostVersionHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PostVersionHistoryWhereUniqueInput
    update: XOR<PostVersionHistoryUpdateWithoutUserInput, PostVersionHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PostVersionHistoryCreateWithoutUserInput, PostVersionHistoryUncheckedCreateWithoutUserInput>
  }

  export type PostVersionHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PostVersionHistoryWhereUniqueInput
    data: XOR<PostVersionHistoryUpdateWithoutUserInput, PostVersionHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PostVersionHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PostVersionHistoryScalarWhereInput
    data: XOR<PostVersionHistoryUpdateManyMutationInput, PostVersionHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: StringFilter<"Post"> | string
    contentHTML?: StringFilter<"Post"> | string
    contentText?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    slug?: StringFilter<"Post"> | string
    image?: BoolFilter<"Post"> | boolean
    metaDescription?: StringNullableFilter<"Post"> | string | null
    metaKeywords?: StringNullableListFilter<"Post">
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    contentDelta?: StringFilter<"Post"> | string
    imageExt?: StringNullableFilter<"Post"> | string | null
    imageKey?: StringNullableFilter<"Post"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserRolesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    update: XOR<UserRolesUpdateWithoutUserInput, UserRolesUncheckedUpdateWithoutUserInput>
    create: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput>
  }

  export type UserRolesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    data: XOR<UserRolesUpdateWithoutUserInput, UserRolesUncheckedUpdateWithoutUserInput>
  }

  export type UserRolesUpdateManyWithWhereWithoutUserInput = {
    where: UserRolesScalarWhereInput
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRolesScalarWhereInput = {
    AND?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
    OR?: UserRolesScalarWhereInput[]
    NOT?: UserRolesScalarWhereInput | UserRolesScalarWhereInput[]
    userId?: StringFilter<"UserRoles"> | string
    roleId?: IntFilter<"UserRoles"> | number
  }

  export type UserSocialUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSocialWhereUniqueInput
    update: XOR<UserSocialUpdateWithoutUserInput, UserSocialUncheckedUpdateWithoutUserInput>
    create: XOR<UserSocialCreateWithoutUserInput, UserSocialUncheckedCreateWithoutUserInput>
  }

  export type UserSocialUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSocialWhereUniqueInput
    data: XOR<UserSocialUpdateWithoutUserInput, UserSocialUncheckedUpdateWithoutUserInput>
  }

  export type UserSocialUpdateManyWithWhereWithoutUserInput = {
    where: UserSocialScalarWhereInput
    data: XOR<UserSocialUpdateManyMutationInput, UserSocialUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSocialScalarWhereInput = {
    AND?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
    OR?: UserSocialScalarWhereInput[]
    NOT?: UserSocialScalarWhereInput | UserSocialScalarWhereInput[]
    userId?: StringFilter<"UserSocial"> | string
    handle?: StringFilter<"UserSocial"> | string
    socialCode?: StringFilter<"UserSocial"> | string
  }

  export type PathwayUpsertWithWhereUniqueWithoutCMS_UserInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutCMS_UserInput, PathwayUncheckedUpdateWithoutCMS_UserInput>
    create: XOR<PathwayCreateWithoutCMS_UserInput, PathwayUncheckedCreateWithoutCMS_UserInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutCMS_UserInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutCMS_UserInput, PathwayUncheckedUpdateWithoutCMS_UserInput>
  }

  export type PathwayUpdateManyWithWhereWithoutCMS_UserInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutCMS_UserInput>
  }

  export type ResourceUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutAuthorInput, ResourceUncheckedUpdateWithoutAuthorInput>
    create: XOR<ResourceCreateWithoutAuthorInput, ResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutAuthorInput, ResourceUncheckedUpdateWithoutAuthorInput>
  }

  export type ResourceUpdateManyWithWhereWithoutAuthorInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: IntFilter<"Resource"> | number
    name?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    authorId?: StringFilter<"Resource"> | string
    content?: StringFilter<"Resource"> | string
  }

  export type ContentResourceUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ContentResourceWhereUniqueInput
    update: XOR<ContentResourceUpdateWithoutAuthorInput, ContentResourceUncheckedUpdateWithoutAuthorInput>
    create: XOR<ContentResourceCreateWithoutAuthorInput, ContentResourceUncheckedCreateWithoutAuthorInput>
  }

  export type ContentResourceUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ContentResourceWhereUniqueInput
    data: XOR<ContentResourceUpdateWithoutAuthorInput, ContentResourceUncheckedUpdateWithoutAuthorInput>
  }

  export type ContentResourceUpdateManyWithWhereWithoutAuthorInput = {
    where: ContentResourceScalarWhereInput
    data: XOR<ContentResourceUpdateManyMutationInput, ContentResourceUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ContentResourceScalarWhereInput = {
    AND?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
    OR?: ContentResourceScalarWhereInput[]
    NOT?: ContentResourceScalarWhereInput | ContentResourceScalarWhereInput[]
    id?: IntFilter<"ContentResource"> | number
    href?: JsonFilter<"ContentResource">
    title?: StringFilter<"ContentResource"> | string
    subtitle?: StringNullableFilter<"ContentResource"> | string | null
    typeId?: IntFilter<"ContentResource"> | number
    icon?: StringNullableFilter<"ContentResource"> | string | null
    authorId?: StringNullableFilter<"ContentResource"> | string | null
    date?: DateTimeFilter<"ContentResource"> | Date | string
    areaId?: IntFilter<"ContentResource"> | number
    authorString?: StringNullableFilter<"ContentResource"> | string | null
  }

  export type SocialCreateWithoutUsersInput = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
  }

  export type SocialUncheckedCreateWithoutUsersInput = {
    name: string
    url: string
    icon: string
    codeName: string
    profileLinkFormat: string
    profileEntryFormat: string
    darkModeColor: string
    lightModeColor: string
  }

  export type SocialCreateOrConnectWithoutUsersInput = {
    where: SocialWhereUniqueInput
    create: XOR<SocialCreateWithoutUsersInput, SocialUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutSocialsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSocialsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSocialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialsInput, UserUncheckedCreateWithoutSocialsInput>
  }

  export type SocialUpsertWithoutUsersInput = {
    update: XOR<SocialUpdateWithoutUsersInput, SocialUncheckedUpdateWithoutUsersInput>
    create: XOR<SocialCreateWithoutUsersInput, SocialUncheckedCreateWithoutUsersInput>
    where?: SocialWhereInput
  }

  export type SocialUpdateToOneWithWhereWithoutUsersInput = {
    where?: SocialWhereInput
    data: XOR<SocialUpdateWithoutUsersInput, SocialUncheckedUpdateWithoutUsersInput>
  }

  export type SocialUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
  }

  export type SocialUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    codeName?: StringFieldUpdateOperationsInput | string
    profileLinkFormat?: StringFieldUpdateOperationsInput | string
    profileEntryFormat?: StringFieldUpdateOperationsInput | string
    darkModeColor?: StringFieldUpdateOperationsInput | string
    lightModeColor?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutSocialsInput = {
    update: XOR<UserUpdateWithoutSocialsInput, UserUncheckedUpdateWithoutSocialsInput>
    create: XOR<UserCreateWithoutSocialsInput, UserUncheckedCreateWithoutSocialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialsInput, UserUncheckedUpdateWithoutSocialsInput>
  }

  export type UserUpdateWithoutSocialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type RolesCreateWithoutUserRolesInput = {
    name: string
  }

  export type RolesUncheckedCreateWithoutUserRolesInput = {
    id?: number
    name: string
  }

  export type RolesCreateOrConnectWithoutUserRolesInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RolesUpsertWithoutUserRolesInput = {
    update: XOR<RolesUpdateWithoutUserRolesInput, RolesUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUserRolesInput, RolesUncheckedUpdateWithoutUserRolesInput>
  }

  export type RolesUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserRolesCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRolesUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRolesCreateOrConnectWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    create: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput>
  }

  export type UserRolesCreateManyRoleInputEnvelope = {
    data: UserRolesCreateManyRoleInput | UserRolesCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRolesUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    update: XOR<UserRolesUpdateWithoutRoleInput, UserRolesUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput>
  }

  export type UserRolesUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    data: XOR<UserRolesUpdateWithoutRoleInput, UserRolesUncheckedUpdateWithoutRoleInput>
  }

  export type UserRolesUpdateManyWithWhereWithoutRoleInput = {
    where: UserRolesScalarWhereInput
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserSocialCreateWithoutSocialInput = {
    handle: string
    user: UserCreateNestedOneWithoutSocialsInput
  }

  export type UserSocialUncheckedCreateWithoutSocialInput = {
    userId: string
    handle: string
  }

  export type UserSocialCreateOrConnectWithoutSocialInput = {
    where: UserSocialWhereUniqueInput
    create: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput>
  }

  export type UserSocialCreateManySocialInputEnvelope = {
    data: UserSocialCreateManySocialInput | UserSocialCreateManySocialInput[]
    skipDuplicates?: boolean
  }

  export type UserSocialUpsertWithWhereUniqueWithoutSocialInput = {
    where: UserSocialWhereUniqueInput
    update: XOR<UserSocialUpdateWithoutSocialInput, UserSocialUncheckedUpdateWithoutSocialInput>
    create: XOR<UserSocialCreateWithoutSocialInput, UserSocialUncheckedCreateWithoutSocialInput>
  }

  export type UserSocialUpdateWithWhereUniqueWithoutSocialInput = {
    where: UserSocialWhereUniqueInput
    data: XOR<UserSocialUpdateWithoutSocialInput, UserSocialUncheckedUpdateWithoutSocialInput>
  }

  export type UserSocialUpdateManyWithWhereWithoutSocialInput = {
    where: UserSocialScalarWhereInput
    data: XOR<UserSocialUpdateManyMutationInput, UserSocialUncheckedUpdateManyWithoutSocialInput>
  }

  export type PostCreateWithoutPostVersionHistoriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPostVersionHistoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
    postBlock?: PostBlockUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostVersionHistoriesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostVersionHistoriesInput, PostUncheckedCreateWithoutPostVersionHistoriesInput>
  }

  export type UserCreateWithoutPostVersionHistoryInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPostVersionHistoryInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
    contentResources?: ContentResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPostVersionHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostVersionHistoryInput, UserUncheckedCreateWithoutPostVersionHistoryInput>
  }

  export type PostUpsertWithoutPostVersionHistoriesInput = {
    update: XOR<PostUpdateWithoutPostVersionHistoriesInput, PostUncheckedUpdateWithoutPostVersionHistoriesInput>
    create: XOR<PostCreateWithoutPostVersionHistoriesInput, PostUncheckedCreateWithoutPostVersionHistoriesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostVersionHistoriesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostVersionHistoriesInput, PostUncheckedUpdateWithoutPostVersionHistoriesInput>
  }

  export type PostUpdateWithoutPostVersionHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPostVersionHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPostVersionHistoryInput = {
    update: XOR<UserUpdateWithoutPostVersionHistoryInput, UserUncheckedUpdateWithoutPostVersionHistoryInput>
    create: XOR<UserCreateWithoutPostVersionHistoryInput, UserUncheckedCreateWithoutPostVersionHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostVersionHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostVersionHistoryInput, UserUncheckedUpdateWithoutPostVersionHistoryInput>
  }

  export type UserUpdateWithoutPostVersionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPostVersionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
    contentResources?: ContentResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PathwayCategoriesCreateWithoutPathway_categoriesInput = {
    pathways: PathwayCreateNestedOneWithoutCategoriesInput
  }

  export type PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput = {
    pathwayId: number
  }

  export type PathwayCategoriesCreateOrConnectWithoutPathway_categoriesInput = {
    where: PathwayCategoriesWhereUniqueInput
    create: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput>
  }

  export type PathwayCategoriesCreateManyPathway_categoriesInputEnvelope = {
    data: PathwayCategoriesCreateManyPathway_categoriesInput | PathwayCategoriesCreateManyPathway_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type PathwayTypesCreateWithoutChildrenInput = {
    name: string
    description?: string | null
    pathwayCategories?: PathwayCategoriesCreateNestedManyWithoutPathway_categoriesInput
    parent?: PathwayTypesCreateNestedOneWithoutChildrenInput
  }

  export type PathwayTypesUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    parentId?: number | null
    description?: string | null
    pathwayCategories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathway_categoriesInput
  }

  export type PathwayTypesCreateOrConnectWithoutChildrenInput = {
    where: PathwayTypesWhereUniqueInput
    create: XOR<PathwayTypesCreateWithoutChildrenInput, PathwayTypesUncheckedCreateWithoutChildrenInput>
  }

  export type PathwayTypesCreateWithoutParentInput = {
    name: string
    description?: string | null
    pathwayCategories?: PathwayCategoriesCreateNestedManyWithoutPathway_categoriesInput
    children?: PathwayTypesCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    description?: string | null
    pathwayCategories?: PathwayCategoriesUncheckedCreateNestedManyWithoutPathway_categoriesInput
    children?: PathwayTypesUncheckedCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesCreateOrConnectWithoutParentInput = {
    where: PathwayTypesWhereUniqueInput
    create: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput>
  }

  export type PathwayTypesCreateManyParentInputEnvelope = {
    data: PathwayTypesCreateManyParentInput | PathwayTypesCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCategoriesUpsertWithWhereUniqueWithoutPathway_categoriesInput = {
    where: PathwayCategoriesWhereUniqueInput
    update: XOR<PathwayCategoriesUpdateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedUpdateWithoutPathway_categoriesInput>
    create: XOR<PathwayCategoriesCreateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedCreateWithoutPathway_categoriesInput>
  }

  export type PathwayCategoriesUpdateWithWhereUniqueWithoutPathway_categoriesInput = {
    where: PathwayCategoriesWhereUniqueInput
    data: XOR<PathwayCategoriesUpdateWithoutPathway_categoriesInput, PathwayCategoriesUncheckedUpdateWithoutPathway_categoriesInput>
  }

  export type PathwayCategoriesUpdateManyWithWhereWithoutPathway_categoriesInput = {
    where: PathwayCategoriesScalarWhereInput
    data: XOR<PathwayCategoriesUpdateManyMutationInput, PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesInput>
  }

  export type PathwayTypesUpsertWithoutChildrenInput = {
    update: XOR<PathwayTypesUpdateWithoutChildrenInput, PathwayTypesUncheckedUpdateWithoutChildrenInput>
    create: XOR<PathwayTypesCreateWithoutChildrenInput, PathwayTypesUncheckedCreateWithoutChildrenInput>
    where?: PathwayTypesWhereInput
  }

  export type PathwayTypesUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PathwayTypesWhereInput
    data: XOR<PathwayTypesUpdateWithoutChildrenInput, PathwayTypesUncheckedUpdateWithoutChildrenInput>
  }

  export type PathwayTypesUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUpdateManyWithoutPathway_categoriesNestedInput
    parent?: PathwayTypesUpdateOneWithoutChildrenNestedInput
  }

  export type PathwayTypesUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesNestedInput
  }

  export type PathwayTypesUpsertWithWhereUniqueWithoutParentInput = {
    where: PathwayTypesWhereUniqueInput
    update: XOR<PathwayTypesUpdateWithoutParentInput, PathwayTypesUncheckedUpdateWithoutParentInput>
    create: XOR<PathwayTypesCreateWithoutParentInput, PathwayTypesUncheckedCreateWithoutParentInput>
  }

  export type PathwayTypesUpdateWithWhereUniqueWithoutParentInput = {
    where: PathwayTypesWhereUniqueInput
    data: XOR<PathwayTypesUpdateWithoutParentInput, PathwayTypesUncheckedUpdateWithoutParentInput>
  }

  export type PathwayTypesUpdateManyWithWhereWithoutParentInput = {
    where: PathwayTypesScalarWhereInput
    data: XOR<PathwayTypesUpdateManyMutationInput, PathwayTypesUncheckedUpdateManyWithoutParentInput>
  }

  export type PathwayTypesScalarWhereInput = {
    AND?: PathwayTypesScalarWhereInput | PathwayTypesScalarWhereInput[]
    OR?: PathwayTypesScalarWhereInput[]
    NOT?: PathwayTypesScalarWhereInput | PathwayTypesScalarWhereInput[]
    id?: IntFilter<"PathwayTypes"> | number
    name?: StringFilter<"PathwayTypes"> | string
    parentId?: IntNullableFilter<"PathwayTypes"> | number | null
    description?: StringNullableFilter<"PathwayTypes"> | string | null
  }

  export type PathwayCreateWithoutCategoriesInput = {
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsCreateNestedManyWithoutPathwayInput
    pipelines?: PathwayPipelineCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityCreateNestedManyWithoutPathwayInput
    country: CountryCreateNestedOneWithoutPathwaysInput
    currency: CurrencyCreateNestedOneWithoutPathwaysInput
    CMS_User: UserCreateNestedOneWithoutPathwayInput
  }

  export type PathwayUncheckedCreateWithoutCategoriesInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
    documents?: PathwayDocumentsUncheckedCreateNestedManyWithoutPathwayInput
    pipelines?: PathwayPipelineUncheckedCreateNestedManyWithoutPathwayInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedCreateNestedManyWithoutPathwayInput
  }

  export type PathwayCreateOrConnectWithoutCategoriesInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutCategoriesInput, PathwayUncheckedCreateWithoutCategoriesInput>
  }

  export type PathwayTypesCreateWithoutPathwayCategoriesInput = {
    name: string
    description?: string | null
    parent?: PathwayTypesCreateNestedOneWithoutChildrenInput
    children?: PathwayTypesCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesUncheckedCreateWithoutPathwayCategoriesInput = {
    id?: number
    name: string
    parentId?: number | null
    description?: string | null
    children?: PathwayTypesUncheckedCreateNestedManyWithoutParentInput
  }

  export type PathwayTypesCreateOrConnectWithoutPathwayCategoriesInput = {
    where: PathwayTypesWhereUniqueInput
    create: XOR<PathwayTypesCreateWithoutPathwayCategoriesInput, PathwayTypesUncheckedCreateWithoutPathwayCategoriesInput>
  }

  export type PathwayUpsertWithoutCategoriesInput = {
    update: XOR<PathwayUpdateWithoutCategoriesInput, PathwayUncheckedUpdateWithoutCategoriesInput>
    create: XOR<PathwayCreateWithoutCategoriesInput, PathwayUncheckedCreateWithoutCategoriesInput>
    where?: PathwayWhereInput
  }

  export type PathwayUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: PathwayWhereInput
    data: XOR<PathwayUpdateWithoutCategoriesInput, PathwayUncheckedUpdateWithoutCategoriesInput>
  }

  export type PathwayUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type PathwayTypesUpsertWithoutPathwayCategoriesInput = {
    update: XOR<PathwayTypesUpdateWithoutPathwayCategoriesInput, PathwayTypesUncheckedUpdateWithoutPathwayCategoriesInput>
    create: XOR<PathwayTypesCreateWithoutPathwayCategoriesInput, PathwayTypesUncheckedCreateWithoutPathwayCategoriesInput>
    where?: PathwayTypesWhereInput
  }

  export type PathwayTypesUpdateToOneWithWhereWithoutPathwayCategoriesInput = {
    where?: PathwayTypesWhereInput
    data: XOR<PathwayTypesUpdateWithoutPathwayCategoriesInput, PathwayTypesUncheckedUpdateWithoutPathwayCategoriesInput>
  }

  export type PathwayTypesUpdateWithoutPathwayCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: PathwayTypesUpdateOneWithoutChildrenNestedInput
    children?: PathwayTypesUpdateManyWithoutParentNestedInput
  }

  export type PathwayTypesUncheckedUpdateWithoutPathwayCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    children?: PathwayTypesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ContentResourceCreateWithoutTypeInput = {
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    date?: Date | string
    authorString?: string | null
    area: ContentResourceAreaCreateNestedOneWithoutContentResourcesInput
    author?: UserCreateNestedOneWithoutContentResourcesInput
  }

  export type ContentResourceUncheckedCreateWithoutTypeInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type ContentResourceCreateOrConnectWithoutTypeInput = {
    where: ContentResourceWhereUniqueInput
    create: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput>
  }

  export type ContentResourceCreateManyTypeInputEnvelope = {
    data: ContentResourceCreateManyTypeInput | ContentResourceCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContentResourceUpsertWithWhereUniqueWithoutTypeInput = {
    where: ContentResourceWhereUniqueInput
    update: XOR<ContentResourceUpdateWithoutTypeInput, ContentResourceUncheckedUpdateWithoutTypeInput>
    create: XOR<ContentResourceCreateWithoutTypeInput, ContentResourceUncheckedCreateWithoutTypeInput>
  }

  export type ContentResourceUpdateWithWhereUniqueWithoutTypeInput = {
    where: ContentResourceWhereUniqueInput
    data: XOR<ContentResourceUpdateWithoutTypeInput, ContentResourceUncheckedUpdateWithoutTypeInput>
  }

  export type ContentResourceUpdateManyWithWhereWithoutTypeInput = {
    where: ContentResourceScalarWhereInput
    data: XOR<ContentResourceUpdateManyMutationInput, ContentResourceUncheckedUpdateManyWithoutTypeInput>
  }

  export type ContentResourceCreateWithoutAreaInput = {
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    date?: Date | string
    authorString?: string | null
    author?: UserCreateNestedOneWithoutContentResourcesInput
    type: ContentResourceTypeCreateNestedOneWithoutContentResourcesInput
  }

  export type ContentResourceUncheckedCreateWithoutAreaInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    authorString?: string | null
  }

  export type ContentResourceCreateOrConnectWithoutAreaInput = {
    where: ContentResourceWhereUniqueInput
    create: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput>
  }

  export type ContentResourceCreateManyAreaInputEnvelope = {
    data: ContentResourceCreateManyAreaInput | ContentResourceCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ContentResourceUpsertWithWhereUniqueWithoutAreaInput = {
    where: ContentResourceWhereUniqueInput
    update: XOR<ContentResourceUpdateWithoutAreaInput, ContentResourceUncheckedUpdateWithoutAreaInput>
    create: XOR<ContentResourceCreateWithoutAreaInput, ContentResourceUncheckedCreateWithoutAreaInput>
  }

  export type ContentResourceUpdateWithWhereUniqueWithoutAreaInput = {
    where: ContentResourceWhereUniqueInput
    data: XOR<ContentResourceUpdateWithoutAreaInput, ContentResourceUncheckedUpdateWithoutAreaInput>
  }

  export type ContentResourceUpdateManyWithWhereWithoutAreaInput = {
    where: ContentResourceScalarWhereInput
    data: XOR<ContentResourceUpdateManyMutationInput, ContentResourceUncheckedUpdateManyWithoutAreaInput>
  }

  export type ContentResourceAreaCreateWithoutContentResourcesInput = {
    area: string
    tagline?: string | null
  }

  export type ContentResourceAreaUncheckedCreateWithoutContentResourcesInput = {
    id?: number
    area: string
    tagline?: string | null
  }

  export type ContentResourceAreaCreateOrConnectWithoutContentResourcesInput = {
    where: ContentResourceAreaWhereUniqueInput
    create: XOR<ContentResourceAreaCreateWithoutContentResourcesInput, ContentResourceAreaUncheckedCreateWithoutContentResourcesInput>
  }

  export type UserCreateWithoutContentResourcesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRolesCreateNestedManyWithoutUserInput
    socials?: UserSocialCreateNestedManyWithoutUserInput
    Pathway?: PathwayCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutContentResourcesInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    secret?: string | null
    firstName?: string | null
    lastName?: string | null
    discordHandle?: string | null
    key?: string | null
    created?: Date | string
    postVersionHistory?: PostVersionHistoryUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    socials?: UserSocialUncheckedCreateNestedManyWithoutUserInput
    Pathway?: PathwayUncheckedCreateNestedManyWithoutCMS_UserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutContentResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContentResourcesInput, UserUncheckedCreateWithoutContentResourcesInput>
  }

  export type ContentResourceTypeCreateWithoutContentResourcesInput = {
    type: string
    icon?: string | null
    color?: string | null
  }

  export type ContentResourceTypeUncheckedCreateWithoutContentResourcesInput = {
    id?: number
    type: string
    icon?: string | null
    color?: string | null
  }

  export type ContentResourceTypeCreateOrConnectWithoutContentResourcesInput = {
    where: ContentResourceTypeWhereUniqueInput
    create: XOR<ContentResourceTypeCreateWithoutContentResourcesInput, ContentResourceTypeUncheckedCreateWithoutContentResourcesInput>
  }

  export type ContentResourceAreaUpsertWithoutContentResourcesInput = {
    update: XOR<ContentResourceAreaUpdateWithoutContentResourcesInput, ContentResourceAreaUncheckedUpdateWithoutContentResourcesInput>
    create: XOR<ContentResourceAreaCreateWithoutContentResourcesInput, ContentResourceAreaUncheckedCreateWithoutContentResourcesInput>
    where?: ContentResourceAreaWhereInput
  }

  export type ContentResourceAreaUpdateToOneWithWhereWithoutContentResourcesInput = {
    where?: ContentResourceAreaWhereInput
    data: XOR<ContentResourceAreaUpdateWithoutContentResourcesInput, ContentResourceAreaUncheckedUpdateWithoutContentResourcesInput>
  }

  export type ContentResourceAreaUpdateWithoutContentResourcesInput = {
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceAreaUncheckedUpdateWithoutContentResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    area?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutContentResourcesInput = {
    update: XOR<UserUpdateWithoutContentResourcesInput, UserUncheckedUpdateWithoutContentResourcesInput>
    create: XOR<UserCreateWithoutContentResourcesInput, UserUncheckedCreateWithoutContentResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContentResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContentResourcesInput, UserUncheckedUpdateWithoutContentResourcesInput>
  }

  export type UserUpdateWithoutContentResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRolesUpdateManyWithoutUserNestedInput
    socials?: UserSocialUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutContentResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    discordHandle?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    postVersionHistory?: PostVersionHistoryUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    socials?: UserSocialUncheckedUpdateManyWithoutUserNestedInput
    Pathway?: PathwayUncheckedUpdateManyWithoutCMS_UserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ContentResourceTypeUpsertWithoutContentResourcesInput = {
    update: XOR<ContentResourceTypeUpdateWithoutContentResourcesInput, ContentResourceTypeUncheckedUpdateWithoutContentResourcesInput>
    create: XOR<ContentResourceTypeCreateWithoutContentResourcesInput, ContentResourceTypeUncheckedCreateWithoutContentResourcesInput>
    where?: ContentResourceTypeWhereInput
  }

  export type ContentResourceTypeUpdateToOneWithWhereWithoutContentResourcesInput = {
    where?: ContentResourceTypeWhereInput
    data: XOR<ContentResourceTypeUpdateWithoutContentResourcesInput, ContentResourceTypeUncheckedUpdateWithoutContentResourcesInput>
  }

  export type ContentResourceTypeUpdateWithoutContentResourcesInput = {
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceTypeUncheckedUpdateWithoutContentResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryCurrencyCreateManyCountryInput = {
    currencyCode: string
  }

  export type CountryLanguageCreateManyCountryInput = {
    languageCode: string
  }

  export type PathwayRestrictedNationalityCreateManyCountryInput = {
    pathwayId: number
    note?: string | null
  }

  export type PathwayCreateManyCountryInput = {
    id?: number
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
  }

  export type CountryCurrencyUpdateWithoutCountryInput = {
    currency?: CurrencyUpdateOneRequiredWithoutCountryCurrenciesNestedInput
  }

  export type CountryCurrencyUncheckedUpdateWithoutCountryInput = {
    currencyCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCurrencyUncheckedUpdateManyWithoutCountryInput = {
    currencyCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryLanguageUpdateWithoutCountryInput = {
    language?: LanguageUpdateOneRequiredWithoutCountryLanguagesNestedInput
  }

  export type CountryLanguageUncheckedUpdateWithoutCountryInput = {
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryLanguageUncheckedUpdateManyWithoutCountryInput = {
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayRestrictedNationalityUpdateWithoutCountryInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: PathwayUpdateOneRequiredWithoutRestrictedNationalitiesNestedInput
  }

  export type PathwayRestrictedNationalityUncheckedUpdateWithoutCountryInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityUncheckedUpdateManyWithoutCountryInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayDocumentsCreateManyPathwayInput = {
    id?: number
    documentId?: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayCategoriesCreateManyPathwaysInput = {
    pathwayTypeId: number
  }

  export type PathwayPipelineCreateManyPathwayInput = {
    id?: number
    pipeline: $Enums.PathwayPipelines
    note?: string | null
  }

  export type PathwayRestrictedNationalityCreateManyPathwayInput = {
    countryCode: string
    note?: string | null
  }

  export type PathwayDocumentsUpdateWithoutPathwayInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentsUpdateOneRequiredWithoutPathwayDocumentsNestedInput
  }

  export type PathwayDocumentsUncheckedUpdateWithoutPathwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayDocumentsUncheckedUpdateManyWithoutPathwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayCategoriesUpdateWithoutPathwaysInput = {
    pathway_categories?: PathwayTypesUpdateOneRequiredWithoutPathwayCategoriesNestedInput
  }

  export type PathwayCategoriesUncheckedUpdateWithoutPathwaysInput = {
    pathwayTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PathwayCategoriesUncheckedUpdateManyWithoutPathwaysInput = {
    pathwayTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PathwayPipelineUpdateWithoutPathwayInput = {
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayPipelineUncheckedUpdateWithoutPathwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayPipelineUncheckedUpdateManyWithoutPathwayInput = {
    id?: IntFieldUpdateOperationsInput | number
    pipeline?: EnumPathwayPipelinesFieldUpdateOperationsInput | $Enums.PathwayPipelines
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityUpdateWithoutPathwayInput = {
    note?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutRestrictedPathwaysNestedInput
  }

  export type PathwayRestrictedNationalityUncheckedUpdateWithoutPathwayInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryCurrencyCreateManyCurrencyInput = {
    countryCode: string
  }

  export type PathwayCreateManyCurrencyInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby: string
  }

  export type CountryCurrencyUpdateWithoutCurrencyInput = {
    country?: CountryUpdateOneRequiredWithoutCountryCurrenciesNestedInput
  }

  export type CountryCurrencyUncheckedUpdateWithoutCurrencyInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCurrencyUncheckedUpdateManyWithoutCurrencyInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayUpdateWithoutCurrencyInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    CMS_User?: UserUpdateOneRequiredWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    createdby?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayDocumentsCreateManyDocumentInput = {
    id?: number
    pathwayId: number
    description?: string | null
    cost?: Decimal | DecimalJsLike | number | string
    isRequired?: boolean
    link?: string | null
    title?: string | null
  }

  export type PathwayDocumentsUpdateWithoutDocumentInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: PathwayUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PathwayDocumentsUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PathwayDocumentsUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    pathwayId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CountryLanguageCreateManyLanguageInput = {
    countryCode: string
  }

  export type CountryLanguageUpdateWithoutLanguageInput = {
    country?: CountryUpdateOneRequiredWithoutCountryLanguagesNestedInput
  }

  export type CountryLanguageUncheckedUpdateWithoutLanguageInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryLanguageUncheckedUpdateManyWithoutLanguageInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type PostBlockCreateManyPostInput = {
    id?: number
    blockId: number
    type: string
    content: string
    position: number
  }

  export type PostTagCreateManyPostInput = {
    tagId: number
  }

  export type PostVersionHistoryCreateManyPostInput = {
    id?: number
    userId: string
    action: string
    instanceAt?: Date | string
  }

  export type PostBlockUpdateWithoutPostInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    block?: BlockUpdateOneRequiredWithoutPostBlockNestedInput
  }

  export type PostBlockUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostBlockUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostTagUpdateWithoutPostInput = {
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutPostInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PostTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type PostVersionHistoryUpdateWithoutPostInput = {
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostVersionHistoryNestedInput
  }

  export type PostVersionHistoryUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionHistoryUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateManyTagInput = {
    postId: number
  }

  export type TagHierarchyCreateManyParentInput = {
    id?: number
    parentId: number
  }

  export type TagHierarchyCreateManyChildInput = {
    id?: number
    childId: number
  }

  export type TagCreateManyParentInput = {
    id?: number
    name: string
    color?: string
  }

  export type PostTagUpdateWithoutTagInput = {
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutTagInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type PostTagUncheckedUpdateManyWithoutTagInput = {
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type TagHierarchyUpdateWithoutParentInput = {
    child?: TagUpdateOneRequiredWithoutParentTagNestedInput
  }

  export type TagHierarchyUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
  }

  export type TagHierarchyUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
  }

  export type TagHierarchyUpdateWithoutChildInput = {
    parent?: TagUpdateOneRequiredWithoutChildTagNestedInput
  }

  export type TagHierarchyUncheckedUpdateWithoutChildInput = {
    id?: IntFieldUpdateOperationsInput | number
    childId?: IntFieldUpdateOperationsInput | number
  }

  export type TagHierarchyUncheckedUpdateManyWithoutChildInput = {
    id?: IntFieldUpdateOperationsInput | number
    childId?: IntFieldUpdateOperationsInput | number
  }

  export type TagUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUpdateManyWithoutChildNestedInput
    children?: TagUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    childTag?: TagHierarchyUncheckedUpdateManyWithoutParentNestedInput
    parentTag?: TagHierarchyUncheckedUpdateManyWithoutChildNestedInput
    children?: TagUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TagUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type BlockFieldCreateManyBlockInput = {
    id?: number
    name: string
    type: string
    options?: string | null
    slug: string
    defaultValue?: string | null
  }

  export type PostBlockCreateManyBlockInput = {
    id?: number
    postId: number
    type: string
    content: string
    position: number
  }

  export type BlockFieldUpdateWithoutBlockInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockFieldUncheckedUpdateWithoutBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockFieldUncheckedUpdateManyWithoutBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostBlockUpdateWithoutBlockInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutPostBlockNestedInput
  }

  export type PostBlockUncheckedUpdateWithoutBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostBlockUncheckedUpdateManyWithoutBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PostVersionHistoryCreateManyUserInput = {
    id?: number
    postId: number
    action: string
    instanceAt?: Date | string
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contentHTML: string
    contentText: string
    subtitle?: string | null
    slug: string
    image?: boolean
    metaDescription?: string | null
    metaKeywords?: PostCreatemetaKeywordsInput | string[]
    status?: $Enums.ContentStatus
    contentDelta?: string
    imageExt?: string | null
    imageKey?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserRolesCreateManyUserInput = {
    roleId: number
  }

  export type UserSocialCreateManyUserInput = {
    handle: string
    socialCode: string
  }

  export type PathwayCreateManyCMS_UserInput = {
    id?: number
    countryCode: string
    name: string
    link: string
    description: string
    type: $Enums.PathwayType
    createdAt?: Date | string
    updatedAt?: Date | string
    currencyCode: string
    notes?: PathwayCreatenotesInput | string[]
    limitations?: PathwayCreatelimitationsInput | string[]
    requirements?: PathwayCreaterequirementsInput | string[]
    restrictions?: PathwayCreaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResourceCreateManyAuthorInput = {
    id?: number
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: string
  }

  export type ContentResourceCreateManyAuthorInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type PostVersionHistoryUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutPostVersionHistoriesNestedInput
  }

  export type PostVersionHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVersionHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    instanceAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
    postBlock?: PostBlockUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    postVersionHistories?: PostVersionHistoryUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHTML?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    image?: BoolFieldUpdateOperationsInput | boolean
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: PostUpdatemetaKeywordsInput | string[]
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    contentDelta?: StringFieldUpdateOperationsInput | string
    imageExt?: NullableStringFieldUpdateOperationsInput | string | null
    imageKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesUpdateWithoutUserInput = {
    role?: RolesUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRolesUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRolesUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserSocialUpdateWithoutUserInput = {
    handle?: StringFieldUpdateOperationsInput | string
    social?: SocialUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSocialUncheckedUpdateWithoutUserInput = {
    handle?: StringFieldUpdateOperationsInput | string
    socialCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialUncheckedUpdateManyWithoutUserInput = {
    handle?: StringFieldUpdateOperationsInput | string
    socialCode?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayUpdateWithoutCMS_UserInput = {
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUpdateManyWithoutPathwayNestedInput
    country?: CountryUpdateOneRequiredWithoutPathwaysNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutPathwaysNestedInput
  }

  export type PathwayUncheckedUpdateWithoutCMS_UserInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
    documents?: PathwayDocumentsUncheckedUpdateManyWithoutPathwayNestedInput
    categories?: PathwayCategoriesUncheckedUpdateManyWithoutPathwaysNestedInput
    pipelines?: PathwayPipelineUncheckedUpdateManyWithoutPathwayNestedInput
    restrictedNationalities?: PathwayRestrictedNationalityUncheckedUpdateManyWithoutPathwayNestedInput
  }

  export type PathwayUncheckedUpdateManyWithoutCMS_UserInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumPathwayTypeFieldUpdateOperationsInput | $Enums.PathwayType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currencyCode?: StringFieldUpdateOperationsInput | string
    notes?: PathwayUpdatenotesInput | string[]
    limitations?: PathwayUpdatelimitationsInput | string[]
    requirements?: PathwayUpdaterequirementsInput | string[]
    restrictions?: PathwayUpdaterestrictionsInput | string[]
    duration?: NullableJsonNullValueInput | InputJsonValue
    processTime?: NullableJsonNullValueInput | InputJsonValue
    renewal?: NullableJsonNullValueInput | InputJsonValue
    cost?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResourceUpdateWithoutAuthorInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ContentResourceUpdateWithoutAuthorInput = {
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
    area?: ContentResourceAreaUpdateOneRequiredWithoutContentResourcesNestedInput
    type?: ContentResourceTypeUpdateOneRequiredWithoutContentResourcesNestedInput
  }

  export type ContentResourceUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRolesCreateManyRoleInput = {
    userId: string
  }

  export type UserRolesUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRolesUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRolesUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialCreateManySocialInput = {
    userId: string
    handle: string
  }

  export type UserSocialUpdateWithoutSocialInput = {
    handle?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSocialsNestedInput
  }

  export type UserSocialUncheckedUpdateWithoutSocialInput = {
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialUncheckedUpdateManyWithoutSocialInput = {
    userId?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
  }

  export type PathwayCategoriesCreateManyPathway_categoriesInput = {
    pathwayId: number
  }

  export type PathwayTypesCreateManyParentInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type PathwayCategoriesUpdateWithoutPathway_categoriesInput = {
    pathways?: PathwayUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type PathwayCategoriesUncheckedUpdateWithoutPathway_categoriesInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
  }

  export type PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesInput = {
    pathwayId?: IntFieldUpdateOperationsInput | number
  }

  export type PathwayTypesUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUpdateManyWithoutPathway_categoriesNestedInput
    children?: PathwayTypesUpdateManyWithoutParentNestedInput
  }

  export type PathwayTypesUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pathwayCategories?: PathwayCategoriesUncheckedUpdateManyWithoutPathway_categoriesNestedInput
    children?: PathwayTypesUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PathwayTypesUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceCreateManyTypeInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    areaId: number
    authorString?: string | null
  }

  export type ContentResourceUpdateWithoutTypeInput = {
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
    area?: ContentResourceAreaUpdateOneRequiredWithoutContentResourcesNestedInput
    author?: UserUpdateOneWithoutContentResourcesNestedInput
  }

  export type ContentResourceUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceUncheckedUpdateManyWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceCreateManyAreaInput = {
    id?: number
    href?: JsonNullValueInput | InputJsonValue
    title: string
    subtitle?: string | null
    typeId: number
    icon?: string | null
    authorId?: string | null
    date?: Date | string
    authorString?: string | null
  }

  export type ContentResourceUpdateWithoutAreaInput = {
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
    author?: UserUpdateOneWithoutContentResourcesNestedInput
    type?: ContentResourceTypeUpdateOneRequiredWithoutContentResourcesNestedInput
  }

  export type ContentResourceUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentResourceUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    href?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    typeId?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    authorString?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}